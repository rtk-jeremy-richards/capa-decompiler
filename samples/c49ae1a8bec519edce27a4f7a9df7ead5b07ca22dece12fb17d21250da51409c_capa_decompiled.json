{
    "null": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1",
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid main(ulong argc)\n\n{\n    char cVar1;\n    char cVar2;\n    int32_t iVar3;\n    ulong *puVar4;\n    uint32_t *puVar5;\n    int64_t iVar6;\n    ulong uVar7;\n    int64_t arg1;\n    uchar *lpMultiByteStr;\n    int64_t iVar8;\n    char *pcVar9;\n    uchar *arg2;\n    char *arg2_00;\n    ulong in_R8;\n    ulong in_R9;\n    bool bVar10;\n    ulong var_4f30h;\n    char acStack16440 [4096];\n    uchar auStack12344 [4096];\n    uchar auStack8248 [8192];\n    uint64_t uStack56;\n    ulong uStack48;\n    \n    // [00] -r-x section size 147456 named .text\n    uStack48 = 0x140001011;\n    puVar4 = fcn.14000bb48();\n    uVar7 = *puVar4;\n    uStack48 = 0x140001019;\n    puVar5 = fcn.14000bb40();\n    uStack48 = 0x140001023;\n    puVar4 = fcn.1400063c0(*puVar5, uVar7);\n    uStack48 = 0x14000282e;\n    iVar6 = fcn.140009a10();\n    iVar6 = -iVar6;\n    uStack56 = *0x140037018 ^ &stack0xffffffffffffffd8 + iVar6;\n    *(&stack0xffffffffffffffd0 + iVar6) = 0x140002852;\n    uVar7 = fcn.14000cb50(2);\n    *(&stack0xffffffffffffffd0 + iVar6) = 0x14000285c;\n    fcn.140010a64(uVar7, 0, in_R8, in_R9);\n    *(&stack0xffffffffffffffd0 + iVar6) = 0x140002863;\n    arg1 = fcn.140001b60(0);\n    if (arg1 == 0) goto code_r0x000140002914;\n    uVar7 = *puVar4;\n    *(&stack0xffffffffffffffd0 + iVar6) = 0x14000287c;\n    iVar3 = fcn.140002c80(&stack0x00000008 + iVar6, uVar7);\n    if (iVar3 == 0) goto code_r0x000140002914;\n    *(&stack0xffffffffffffffd0 + iVar6) = 0x140002895;\n    iVar3 = fcn.140002b50(&stack0xffffffffffffcfc8, &stack0x00000008 + iVar6);\n    if (iVar3 == 0) goto code_r0x000140002914;\n    *(&stack0xffffffffffffffd0 + iVar6) = 0x1400028aa;\n    iVar3 = fcn.140002c00(&stack0xffffffffffffbfc8, &stack0x00000008 + iVar6);\n    if (iVar3 == 0) goto code_r0x000140002914;\n    *(&stack0xffffffffffffffd0 + iVar6) = 0x1400028ba;\n    lpMultiByteStr = fcn.1400056f0(\"_MEIPASS2\");\n    bVar10 = lpMultiByteStr == NULL;\n    *(&stack0xffffffffffffffd0 + iVar6) = 0x1400028d3;\n    fcn.140005c90(\"_MEIPASS2\");\n    *(&stack0xffffffffffffffd0 + iVar6) = 0x1400028e0;\n    iVar3 = fcn.140001a70(arg1, &stack0x00000008 + iVar6);\n    if (iVar3 == 0) {\n        *(&stack0xffffffffffffffd0 + iVar6) = 0x1400028f3;\n        iVar3 = fcn.140001a70(arg1, &stack0xffffffffffffcfc8);\n        if (iVar3 == 0) {\n            *(&stack0xffffffffffffffd0 + iVar6) = 0x14000290f;\n            fcn.140001c70(\"Cannot open self %s or archive %s\\n\", &stack0x00000008 + iVar6, &stack0xffffffffffffcfc8, \n                          in_R9);\n            goto code_r0x000140002914;\n        }\n    }\n    *(arg1 + 0x4080) = argc;\n    *(arg1 + 0x4088) = puVar4;\n    if (lpMultiByteStr == NULL) {\n        *(&stack0xffffffffffffffd0 + iVar6) = 0x140002955;\n        iVar3 = fcn.140002740(arg1);\n        if (iVar3 == 0) {\n            lpMultiByteStr = &stack0xffffffffffffbfc8;\n            goto code_r0x000140002960;\n        }\n    }\n    else {\ncode_r0x000140002960:\n        uVar7 = 0x1000;\n        *(&stack0xffffffffffffffd0 + iVar6) = 0x140002975;\n        arg2 = lpMultiByteStr;\n        iVar8 = fcn.1400068b0(&stack0xffffffffffffdfc8, lpMultiByteStr, 0x1000);\n        if (iVar8 == 0) {\n            *(&stack0xffffffffffffffd0 + iVar6) = 0x140002986;\n            fcn.140001c70(\"Failed to convert DLL search path!\\n\", arg2, uVar7, in_R9);\n            goto code_r0x000140002914;\n        }\n        *(&stack0xffffffffffffffd0 + iVar6) = 0x140002995;\n        (*_sym.imp.KERNEL32.dll_SetDllDirectoryW)(&stack0xffffffffffffdfc8);\n    }\n    *(&stack0xffffffffffffffd0 + iVar6) = 0x14000299a;\n    uVar7 = fcn.140004c10();\n    *(&stack0xfffffffffffffff8 + iVar6) = uVar7;\n    if (bVar10) {\n        *(&stack0xffffffffffffffd0 + iVar6) = 0x1400029b2;\n        iVar3 = fcn.1400048f0(uVar7, arg1, 0);\n        if (iVar3 != 0) goto code_r0x0001400029f0;\n        *(&stack0xffffffffffffffd0 + iVar6) = 0x1400029c3;\n        iVar3 = fcn.1400044a0(arg1);\n        if (iVar3 != 0) {\ncode_r0x0001400029e6:\n            *(&stack0xffffffffffffffd0 + iVar6) = 0x1400029f0;\n            fcn.140004710(*(&stack0xfffffffffffffff8 + iVar6));\n            goto code_r0x0001400029f0;\n        }\n        *(&stack0xffffffffffffffd0 + iVar6) = 0x1400029d1;\n        iVar3 = fcn.140004430(*(&stack0xfffffffffffffff8 + iVar6));\n        if (iVar3 != 0) goto code_r0x0001400029e6;\n        *(&stack0xffffffffffffffd0 + iVar6) = 0x1400029e4;\n        fcn.140004aa0(*(&stack0xfffffffffffffff8 + iVar6), &stack0x00000008 + iVar6);\n    }\n    else {\ncode_r0x0001400029f0:\n        *(&stack0xffffffffffffffd0 + iVar6) = 0x1400029fa;\n        fcn.140004b90(&stack0xfffffffffffffff8 + iVar6);\n    }\n    if (lpMultiByteStr == NULL) {\n        *(&stack0xffffffffffffffd0 + iVar6) = 0x140002ab3;\n        iVar3 = fcn.140002550(arg1, *(&stack0xfffffffffffffff8 + iVar6));\n        if (iVar3 == 0) {\n            pcVar9 = arg1 + 0x2078;\n            arg2_00 = &stack0xffffffffffffbfc8;\n            if (*pcVar9 != '\\0') {\n                arg2_00 = pcVar9;\n            }\n            *(&stack0xffffffffffffffd0 + iVar6) = 0x140002adb;\n            fcn.140005c20(\"_MEIPASS2\", arg2_00);\n            *(&stack0xffffffffffffffd0 + iVar6) = 0x140002ae7;\n            fcn.1400056f0(\"_MEIPASS2\");\n            *(&stack0xffffffffffffffd0 + iVar6) = 0x140002aef;\n            iVar3 = fcn.140004290(arg1);\n            if (iVar3 != -1) {\n                *(&stack0xffffffffffffffd0 + iVar6) = 0x140002afd;\n                fcn.1400027a0();\n                *(&stack0xffffffffffffffd0 + iVar6) = 0x140002b10;\n                fcn.140005cd0(&stack0x00000008 + iVar6, arg1, argc, puVar4);\n                *(&stack0xffffffffffffffd0 + iVar6) = 0x140002b1c;\n                fcn.140004710(*(&stack0xfffffffffffffff8 + iVar6));\n                *(&stack0xffffffffffffffd0 + iVar6) = 0x140002b26;\n                fcn.140004b90(&stack0xfffffffffffffff8 + iVar6);\n                if (*(arg1 + 0x4078) == 1) {\n                    *(&stack0xffffffffffffffd0 + iVar6) = 0x140002b37;\n                    fcn.140005990(pcVar9);\n                }\n                *(&stack0xffffffffffffffd0 + iVar6) = 0x140002b3f;\n                fcn.140001b20(arg1);\n            }\n        }\n    }\n    else {\n        pcVar9 = &stack0xffffffffffffbfc8;\n        iVar8 = lpMultiByteStr - pcVar9;\n        do {\n            cVar1 = *pcVar9;\n            cVar2 = pcVar9[iVar8];\n            if (cVar1 != cVar2) break;\n            pcVar9 = pcVar9 + 1;\n        } while (cVar2 != '\\0');\n        if (cVar1 != cVar2) {\n            pcVar9 = arg1 + 0x2078;\n            *(&stack0xffffffffffffffd0 + iVar6) = 0x140002a45;\n            iVar3 = fcn.1400027b0(pcVar9, 0x1000, 0x140025804, lpMultiByteStr);\n            if (0xfff < iVar3) goto code_r0x000140002914;\n            *(arg1 + 0x4078) = 1;\n            do {\n                cVar1 = *pcVar9;\n                pcVar9[0x1000] = cVar1;\n                pcVar9 = pcVar9 + 1;\n            } while (cVar1 != '\\0');\n        }\n        *(&stack0xffffffffffffffd0 + iVar6) = 0x140002a79;\n        fcn.1400026b0(arg1);\n        *(&stack0xffffffffffffffd0 + iVar6) = 0x140002a81;\n        fcn.1400022e0(arg1);\n        *(&stack0xffffffffffffffd0 + iVar6) = 0x140002a8b;\n        fcn.1400026a0(arg1);\n        *(&stack0xffffffffffffffd0 + iVar6) = 0x140002a95;\n        fcn.140004710(*(&stack0xfffffffffffffff8 + iVar6));\n        *(&stack0xffffffffffffffd0 + iVar6) = 0x140002a9f;\n        fcn.140004b90(&stack0xfffffffffffffff8 + iVar6);\n    }\ncode_r0x000140002914:\n    *(&stack0xffffffffffffffd0 + iVar6) = 0x140002923;\n    fcn.140009a80(uStack56 ^ &stack0xffffffffffffffd8 + iVar6);\n    return;\n}\n",
        "token_count": 2714
    },
    "14000143": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint64_t fcn.140001430(int64_t *arg1, int64_t arg2, ulong arg3)\n\n{\n    int64_t arg3_00;\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint64_t uVar3;\n    int64_t arg4;\n    int64_t iVar4;\n    int64_t iVar5;\n    char *arg1_00;\n    char *arg2_00;\n    uint64_t arg2_01;\n    uint64_t uVar6;\n    ulong in_R9;\n    int64_t arg4_00;\n    \n    uVar3 = fcn.140005480(arg1, arg2, arg3, in_R9);\n    if (uVar3 == -1) {\n        return uVar3;\n    }\n    arg3_00 = arg2 + 0x12;\n    arg4 = fcn.1400057a0(arg1 + 0x40f);\n    if (arg4 == 0) {\n        fcn.140001c30(\"fopen\", \"Failed to extract %s: failed to open target file!\\n\", arg3_00, in_R9);\n        return 0xffffffff;\n    }\n    iVar4 = *arg1;\n    if (iVar4 == 0) {\n        iVar4 = fcn.140002d90(arg1 + 0xf);\n        *arg1 = iVar4;\n        if (iVar4 == 0) {\n            fcn.140001c70(\"Failed to extract %s: failed to open archive file!\\n\", arg3_00, arg3, in_R9);\n            uVar3 = 0xffffffff;\n            goto code_r0x000140001607;\n        }\n    }\n    iVar1 = fcn.14000c1c0(iVar4, *(arg2 + 4) + arg1[1], 0);\n    if (iVar1 < 0) {\n        fcn.140001c30(\"fseek\", \"Failed to extract %s: failed to seek to the entry\\'s data!\\n\", arg3_00, in_R9);\n        uVar3 = 0xffffffff;\n    }\n    else if (*(arg2 + 0x10) == '\\x01') {\n        uVar2 = fcn.140001040(arg1, arg2, arg4, 0);\n        uVar3 = uVar2;\n    }\n    else {\n        uVar3 = 0;\n        iVar4 = fcn.14000c998(0x2000);\n        if (iVar4 == 0) {\n            fcn.140001c30(\"malloc\", \"Failed to extract %s: failed to allocate temporary buffer!\\n\", arg3_00, in_R9);\n            uVar3 = 0xffffffff;\n        }\n        else {\n            for (uVar6 = *(arg2 + 0xc); uVar6 != 0; uVar6 = uVar6 - arg2_01) {\n                arg4_00 = *arg1;\n                arg2_01 = uVar6;\n                if (0x2000 < uVar6) {\n                    arg2_01 = 0x2000;\n                }\n                iVar5 = fcn.14000bef0(iVar4, arg2_01, 1, arg4_00);\n                if (iVar5 == 0) {\n                    arg2_00 = \"Failed to extract %s: failed to read data chunk!\\n\";\n                    arg1_00 = \"fread\";\ncode_r0x0001400015e3:\n                    fcn.140001c30(arg1_00, arg2_00, arg3_00, arg4_00);\n                    uVar3 = 0xffffffff;\n                    break;\n                }\n                arg4_00 = arg4;\n                iVar5 = fcn.14000c8f8(iVar4, arg2_01, 1, arg4);\n                if (iVar5 == 0) {\n                    arg2_00 = \"Failed to extract %s: failed to write data chunk!\\n\";\n                    arg1_00 = \"fwrite\";\n                    goto code_r0x0001400015e3;\n                }\n            }\n            fcn.14000c984(iVar4);\n        }\n    }\ncode_r0x000140001607:\n    if (*arg1 != 0) {\n        fcn.14000bbd4(*arg1);\n        *arg1 = 0;\n    }\n    fcn.14000bbd4(arg4);\n    return uVar3;\n}\n",
        "token_count": 984
    },
    "140001df": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid fcn.140001df0(int64_t *param_1, ulong param_2)\n\n{\n    uint8_t *puVar1;\n    char cVar2;\n    char cVar3;\n    int64_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int64_t iVar7;\n    uchar *puVar8;\n    int64_t iVar9;\n    uint8_t *puVar10;\n    uint64_t arg2;\n    char *pcVar11;\n    uchar *arg2_00;\n    ulong arg2_01;\n    ulong unaff_RDI;\n    uint32_t uVar12;\n    uchar *arg4;\n    ulong unaff_R14;\n    int64_t aiStackX8 [3];\n    uint8_t auStackX38 [2];\n    ulong var_3f50h;\n    ulong var_4f50h;\n    char acStack16424 [4096];\n    char acStack12328 [4096];\n    uchar auStack8232 [4096];\n    uchar auStack4136 [4096];\n    uint64_t uStack40;\n    ulong uStack32;\n    uint64_t arg3;\n    \n    uStack32 = 0x140001e06;\n    iVar7 = fcn.140009a10();\n    iVar7 = -iVar7;\n    uStack40 = *0x140037018 ^ &stack0xffffffffffffffe8 + iVar7;\n    iVar9 = *param_1;\n    *(&stack0xffffffffffffffe0 + iVar7) = 0x140001e3b;\n    iVar5 = fcn.1400027b0(&stack0xffffffffffffbfd8, 0x1000, 0x140025804, param_2);\n    if (0xfff < iVar5) goto code_r0x000140001f9b;\n    *(&stack0xffffffffffffffe0 + iVar7) = 0x140001e57;\n    puVar8 = fcn.14000ae08(&stack0xffffffffffffbfd8, 0x3a);\n    if (puVar8 == NULL) goto code_r0x000140001f9b;\n    pcVar11 = puVar8 + 1;\n    *puVar8 = 0;\n    iVar4 = iVar7 - pcVar11;\n    do {\n        cVar2 = *pcVar11;\n        pcVar11[&stack0x00000038 + iVar4] = cVar2;\n        pcVar11 = pcVar11 + 1;\n    } while (cVar2 != '\\0');\n    if ((acStack16424[0] == '\\0') || ((&stack0x00000038)[iVar7] == '\\0')) goto code_r0x000140001f9b;\n    *(&stack0x00005078 + iVar7) = unaff_RDI;\n    *(&stack0x00005080 + iVar7) = unaff_R14;\n    *(&stack0xffffffffffffffe0 + iVar7) = 0x140001eb7;\n    fcn.140002c00(&stack0xffffffffffffefd8, &stack0xffffffffffffbfd8);\n    *(&stack0x00000018 + iVar7) = &stack0x00000038 + iVar7;\n    *(&stack0x00000010 + iVar7) = 0x140025854;\n    arg4 = 0x140025854;\n    *(&stack0x00000008 + iVar7) = &stack0xffffffffffffefd8;\n    puVar8 = iVar9 + 0x1078;\n    pcVar11 = \"%s%s%s%s%s\";\n    *(&stack0xffffffffffffffe0 + iVar7) = 0x140001ef6;\n    iVar5 = fcn.140002240(&stack0xffffffffffffdfd8, \"%s%s%s%s%s\", puVar8, 0x140025854);\n    if (iVar5 == 0) {\ncode_r0x000140001f47:\n        *(&stack0xffffffffffffffe0 + iVar7) = 0x140001f4f;\n        iVar5 = fcn.140005480(iVar9, pcVar11, puVar8, arg4);\n        if (iVar5 != -1) {\n            puVar8 = &stack0x00000038 + iVar7;\n            *(&stack0xffffffffffffffe0 + iVar7) = 0x140001f6c;\n            iVar5 = fcn.140005360(&stack0xffffffffffffdfd8, iVar9 + 0x2078);\n            if (iVar5 != -1) goto code_r0x000140001f9b;\n        }\n        arg2_00 = &stack0x00000038 + iVar7;\n        pcVar11 = \"Error copying %s\\n\";\n    }\n    else {\n        arg4 = 0x140025854;\n        *(&stack0x00000028 + iVar7) = &stack0x00000038 + iVar7;\n        puVar8 = iVar9 + 0x1078;\n        *(&stack0x00000020 + iVar7) = 0x140025854;\n        *(&stack0x00000018 + iVar7) = &stack0xffffffffffffefd8;\n        pcVar11 = \"%s%s%s%s%s%s%s\";\n        *(&stack0x00000010 + iVar7) = 0x140025854;\n        *(&stack0x00000008 + iVar7) = 0x14002587c;\n        *(&stack0xffffffffffffffe0 + iVar7) = 0x140001f43;\n        iVar5 = fcn.140002240(&stack0xffffffffffffdfd8, \"%s%s%s%s%s%s%s\", puVar8, 0x140025854);\n        if (iVar5 == 0) goto code_r0x000140001f47;\n        arg4 = 0x140025854;\n        puVar8 = iVar9 + 0x1078;\n        *(&stack0x00000008 + iVar7) = &stack0xffffffffffffbfd8;\n        pcVar11 = \"%s%s%s.pkg\";\n        *(&stack0xffffffffffffffe0 + iVar7) = 0x140001fde;\n        iVar5 = fcn.140002240(&stack0xffffffffffffcfd8, \"%s%s%s.pkg\", puVar8, 0x140025854);\n        if (iVar5 == 0) {\ncode_r0x000140002040:\n            iVar9 = *param_1;\n            *(&stack0xffffffffffffffe0 + iVar7) = 0x140002048;\n            iVar5 = fcn.140005480(iVar9, pcVar11, puVar8, arg4);\n            if (iVar5 != -1) {\n                iVar9 = param_1[1];\n                iVar5 = 1;\n                if (iVar9 != 0) {\n                    arg4 = 0x1;\n                    do {\n                        pcVar11 = iVar9 + 0x78;\n                        puVar8 = &stack0xffffffffffffcfd8 + -pcVar11;\n                        do {\n                            cVar2 = *pcVar11;\n                            cVar3 = pcVar11[puVar8];\n                            if (cVar2 != cVar3) break;\n                            pcVar11 = pcVar11 + 1;\n                        } while (cVar3 != '\\0');\n                        if (cVar2 == cVar3) {\n                            if (iVar9 != 0) goto code_r0x000140002185;\n                            arg2_00 = &stack0xffffffffffffcfd8;\n                            pcVar11 = \"Archive not found: %s\\n\";\n                            goto code_r0x000140001f81;\n                        }\n                        iVar9 = param_1[arg4 + 1];\n                        arg4 = arg4 + 1;\n                        iVar5 = iVar5 + 1;\n                    } while (iVar9 != 0);\n                }\n                *(&stack0xffffffffffffffe0 + iVar7) = 0x14000209f;\n                iVar9 = fcn.140001b60();\n                if (iVar9 != 0) {\n                    arg2_01 = 0x1000;\n                    arg4 = &stack0xffffffffffffcfd8;\n                    puVar8 = 0x140025804;\n                    *(&stack0xffffffffffffffe0 + iVar7) = 0x1400020c7;\n                    iVar6 = fcn.1400027b0(iVar9 + 0x78, 0x1000, 0x140025804, arg4);\n                    if (iVar6 < 0x1000) {\n                        arg4 = *param_1 + 0x1078;\n                        puVar8 = 0x140025804;\n                        arg2_01 = 0x1000;\n                        *(&stack0xffffffffffffffe0 + iVar7) = 0x1400020f4;\n                        iVar6 = fcn.1400027b0(iVar9 + 0x1078, 0x1000, 0x140025804, arg4);\n                        if (0xfff < iVar6) goto code_r0x000140002202;\n                        arg4 = *param_1 + 0x2078;\n                        puVar8 = 0x140025804;\n                        arg2_01 = 0x1000;\n                        *(&stack0xffffffffffffffe0 + iVar7) = 0x140002121;\n                        iVar6 = fcn.1400027b0(iVar9 + 0x2078, 0x1000, 0x140025804, arg4);\n                        if (0xfff < iVar6) goto code_r0x000140002202;\n                        *(iVar9 + 0x4078) = *(*param_1 + 0x4078);\n                        *(&stack0xffffffffffffffe0 + iVar7) = 0x140002143;\n                        iVar6 = fcn.140001790(iVar9);\n                        if (iVar6 == 0) {\n                            param_1[iVar5] = iVar9;\ncode_r0x000140002185:\n                            arg2 = *(iVar9 + 0x10);\n                            if (arg2 < *(iVar9 + 0x18)) {\n                                do {\n                                    puVar10 = arg2 + 0x12;\n                                    puVar8 = &stack0x00000038 + (iVar7 - puVar10);\n                                    do {\n                                        puVar1 = puVar10 + puVar8;\n                                        uVar12 = *puVar10 - *puVar1;\n                                        arg3 = uVar12;\n                                        if (uVar12 != 0) break;\n                                        puVar10 = puVar10 + 1;\n                                    } while (*puVar1 != 0);\n                                    if (uVar12 == 0) {\n                                        *(&stack0xffffffffffffffe0 + iVar7) = 0x1400021c5;\n                                        iVar5 = fcn.140001430(iVar9, arg2, arg3);\n                                        if (iVar5 != 0) {\n                                            *(&stack0xffffffffffffffe0 + iVar7) = 0x1400021f5;\n                                            fcn.140001c70(\"Error extracting %s\\n\", &stack0x00000038 + iVar7, arg3, \n                                                          puVar8);\n                                            *(&stack0xffffffffffffffe0 + iVar7) = 0x1400021fd;\n                                            fcn.140001b20(iVar9);\n                                            break;\n                                        }\n                                    }\n                                    *(&stack0xffffffffffffffe0 + iVar7) = 0x1400021d4;\n                                    arg2 = fcn.140001760(iVar9, arg2, arg3, puVar8);\n                                } while (arg2 < *(iVar9 + 0x18));\n                            }\n                            goto code_r0x000140001f9b;\n                        }\n                        puVar8 = &stack0xffffffffffffcfd8;\n                        *(&stack0xffffffffffffffe0 + iVar7) = 0x140002161;\n                        fcn.140001c30(\"malloc\", \"Error opening archive %s\\n\", puVar8, arg4);\n                    }\n                    else {\ncode_r0x000140002202:\n                        *(&stack0xffffffffffffffe0 + iVar7) = 0x14000220e;\n                        fcn.140001c70(\"Archive path exceeds PATH_MAX\\n\", arg2_01, puVar8, arg4);\n                    }\n                    *(&stack0xffffffffffffffe0 + iVar7) = 0x140002216;\n                    fcn.140001b20(iVar9);\n                }\n            }\n        }\n        else {\n            arg4 = 0x140025854;\n            puVar8 = iVar9 + 0x1078;\n            *(&stack0x00000008 + iVar7) = &stack0xffffffffffffbfd8;\n            pcVar11 = \"%s%s%s.exe\";\n            *(&stack0xffffffffffffffe0 + iVar7) = 0x14000200b;\n            iVar5 = fcn.140002240(&stack0xffffffffffffcfd8, \"%s%s%s.exe\", puVar8, 0x140025854);\n            if (iVar5 == 0) goto code_r0x000140002040;\n            arg4 = 0x140025854;\n            puVar8 = iVar9 + 0x1078;\n            *(&stack0x00000008 + iVar7) = &stack0xffffffffffffbfd8;\n            pcVar11 = \"%s%s%s\";\n            *(&stack0xffffffffffffffe0 + iVar7) = 0x140002038;\n            iVar5 = fcn.140002240(&stack0xffffffffffffcfd8, \"%s%s%s\", puVar8, 0x140025854);\n            if (iVar5 == 0) goto code_r0x000140002040;\n        }\n        arg2_00 = &stack0xffffffffffffcfd8;\n        pcVar11 = \"Archive not found: %s\\n\";\n    }\ncode_r0x000140001f81:\n    *(&stack0xffffffffffffffe0 + iVar7) = 0x140001f86;\n    fcn.140001c70(pcVar11, arg2_00, puVar8, arg4);\ncode_r0x000140001f9b:\n    *(&stack0xffffffffffffffe0 + iVar7) = 0x140001faa;\n    fcn.140009a80(uStack40 ^ &stack0xffffffffffffffe8 + iVar7);\n    return;\n}\n",
        "token_count": 3177
    },
    "14000255": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nvoid fcn.140002550(int64_t arg1, int64_t arg2)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint64_t arg2_00;\n    int64_t iVar3;\n    ulong in_R8;\n    ulong in_R9;\n    uchar auStack232 [32];\n    int64_t iStack200;\n    uchar auStack192 [16];\n    uchar auStack176 [16];\n    uchar auStack160 [16];\n    uchar auStack144 [16];\n    uchar auStack128 [16];\n    uchar auStack112 [16];\n    uchar auStack96 [16];\n    uchar auStack80 [16];\n    uchar auStack64 [16];\n    ulong uStack48;\n    uint64_t uStack40;\n    \n    uStack40 = *0x140037018 ^ auStack232;\n    arg2_00 = *(arg1 + 0x10);\n    auStack192 = ZEXT816(0);\n    auStack176 = ZEXT816(0);\n    auStack160 = ZEXT816(0);\n    auStack144 = ZEXT816(0);\n    auStack128 = ZEXT816(0);\n    auStack112 = ZEXT816(0);\n    uStack48 = 0;\n    auStack96 = ZEXT816(0);\n    auStack80 = ZEXT816(0);\n    auStack64 = ZEXT816(0);\n    iStack200 = arg1;\n    if (arg2_00 < *(arg1 + 0x18)) {\n        do {\n            uVar1 = *(arg2_00 + 0x11) - 0x5a;\n            if ((uVar1 < 0x1f) && ((0x40000101U >> (uVar1 & 0x1f) & 1) != 0)) {\n                if (arg2 != 0) {\n                    fcn.140004c50(arg2, arg2_00);\n                }\n                iVar2 = fcn.140001430(arg1, arg2_00, in_R8);\n                if (iVar2 != 0) break;\n            }\n            else if ((*(arg2_00 + 0x11) == 100) && (iVar2 = fcn.140001df0(&iStack200, arg2_00 + 0x12),  iVar2 == -1))\n            break;\n            arg2_00 = fcn.140001760(arg1, arg2_00, in_R8, in_R9);\n        } while (arg2_00 < *(arg1 + 0x18));\n    }\n    iVar3 = 1;\n    while (auStack192._0_8_ != 0) {\n        fcn.140001b20(auStack192._0_8_);\n        iVar3 = iVar3 + 1;\n        auStack192._0_8_ = *(auStack192 + iVar3 * 8 + -8);\n    }\n    fcn.140009a80(uStack40 ^ auStack232);\n    return;\n}\n",
        "token_count": 662
    },
    "14000b6a": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuchar fcn.14000b6a0(void)\n\n{\n    if (*0x140037040 != 0xffffffff) {\n        fcn.14000b8c4(*0x140037040);\n        *0x140037040 = 0xffffffff;\n    }\n    return 1;\n}\n",
        "token_count": 65
    },
    "14000e0e": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nulong fcn.14000e0e8(int64_t arg1)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint *puVar3;\n    int64_t arg1_00;\n    \n    arg1_00 = arg1;\n    cVar1 = fcn.14000e1cc(arg1);\n    if (cVar1 != '\\0') {\n        if ((((*(*(arg1 + 0x468) + 0x14) >> 0xc & 1) == 0) || (*(*(arg1 + 0x468) + 8) != 0)) &&\n           (iVar2 = fcn.140019b8c(*(arg1 + 0x41), *(arg1 + 0x468)),  iVar2 == -1)) {\n            *(arg1 + 0x28) = 0xffffffff;\n        }\n        else {\n            *(arg1 + 0x28) = *(arg1 + 0x28) + 1;\n        }\n        return 1;\n    }\n    puVar3 = fcn.140015850(arg1_00);\n    *puVar3 = 0x16;\n    fcn.140015730();\n    return 0;\n}\n",
        "token_count": 268
    },
    "1400132b": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuint fcn.1400132b4(int64_t arg1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    int64_t iVar4;\n    \n    if (arg1 != 0) {\n        fcn.14000cbc0(arg1);\n        LOCK();\n        *(arg1 + 0x14) = *(arg1 + 0x14) & 0xffffffe7;\n        iVar1 = fcn.1400149ec(arg1);\n        if ((iVar1 == -1) || (iVar1 = fcn.1400149ec(arg1),  iVar1 == -2)) {\n            iVar4 = 0x140037270;\n        }\n        else {\n            iVar1 = fcn.1400149ec(arg1);\n            uVar2 = fcn.1400149ec(arg1);\n            iVar4 = *((iVar1 >> 6) * 8 + 0x140046a00) + (uVar2 & 0x3f) * 0x48;\n        }\n        *(iVar4 + 0x38) = *(iVar4 + 0x38) & 0xfd;\n        fcn.14000cbcc(arg1);\n        return 0;\n    }\n    puVar3 = fcn.140015850(0);\n    *puVar3 = 0x16;\n    fcn.140015730();\n    return 0x16;\n}\n",
        "token_count": 316
    },
    "140018db": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\nuchar fcn.140018dbc(void)\n\n{\n    if (*0x1400372b8 != 0xffffffff) {\n        fcn.140018094(*0x1400372b8);\n        *0x1400372b8 = 0xffffffff;\n    }\n    return 1;\n}\n",
        "token_count": 65
    },
    "14001a18": {
        "rules": [
            "check if file exists/c301f2ef4d414d12851aaf7cbada9e20/bb34a6814d684c5e93a48a12384793c1"
        ],
        "decompiled_code": "\n// WARNING: Variable defined which should be unmapped: var_10h\n// WARNING: Variable defined which should be unmapped: var_1ch\n// WARNING: Variable defined which should be unmapped: var_24h\n// WARNING: Variable defined which should be unmapped: var_30h\n// WARNING: Variable defined which should be unmapped: var_3ch\n\nvoid fcn.14001a180(uint64_t arg1, ulong arg2, ulong arg3, ulong arg4, ulong noname_4, ulong noname_5, ulong noname_6, \n                  ulong noname_7, ulong noname_8, ulong noname_9, ulong noname_10, ulong arg_68h, ulong arg_70h, \n                  ulong arg_78h)\n\n{\n    code *pcVar1;\n    char cVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    uint32_t uVar5;\n    int64_t iVar6;\n    uint32_t uVar7;\n    uchar auStack184 [32];\n    ulong uStack152;\n    uint32_t uStack136;\n    uint uStack132;\n    uint uStack128;\n    int32_t iStack124;\n    uint32_t uStack120;\n    uint32_t uStack116;\n    uint32_t uStack112;\n    uint32_t uStack104;\n    uint32_t uStack100;\n    int32_t iStack92;\n    uint64_t var_48h;\n    ulong var_3ch;\n    ulong var_30h;\n    ulong var_24h;\n    ulong var_1ch;\n    ulong var_10h;\n    \n    var_48h = *0x140037018 ^ auStack184;\n    uVar5 = arg1 - 0x76c;\n    iVar3 = arg2;\n    iVar6 = iVar3;\n    uStack136 = arg4;\n    if ((((0x45 < uVar5) && (uVar5 < 0x44e)) && (uVar7 = iVar3 - 1,  uVar7 < 0xc)) && (0 < arg3)) {\n        if (*(iVar6 * 4 + 0x140031cb8) - *(iVar6 * 4 + 0x140031cb4) < arg3) {\n            arg1 = uVar5;\n            cVar2 = fcn.140019ef4(arg1, arg2);\n            if (((cVar2 == '\\0') || (iVar3 != 2)) || (0x1d < arg3)) goto code_r0x00014001a13c;\n        }\n        arg1 = 0x140031cb8;\n        if (((uStack136 < 0x18) && (noname_4 < 0x3c)) && (noname_5 < 0x3c)) {\n            arg3._0_4_ = arg3 + *(iVar6 * 4 + 0x140031cb4);\n            cVar2 = fcn.140019ef4(uVar5, arg2);\n            if ((cVar2 != '\\0') && (2 < iVar3)) {\n                arg3._0_4_ = arg3 + 1;\n            }\n            fcn.140020404();\n            iStack124 = 0;\n            uStack128 = 0;\n            uStack132 = 0;\n            iVar3 = fcn.14001f800(&iStack124);\n            if (((iVar3 != 0) || (iVar3 = fcn.14001f830(&uStack128),  iVar3 != 0)) ||\n               (iVar3 = fcn.14001f860(&uStack132),  iVar3 != 0)) {\n                uStack152 = 0;\n                fcn.140015750(0, 0, 0, 0);\n                pcVar1 = swi(3);\n                (*pcVar1)();\n                return;\n            }\n            if (noname_6 != 1) {\n                uStack112 = uStack136;\n                uStack116 = noname_4;\n                uStack120 = noname_5;\n                uStack104 = uVar7;\n                uStack100 = uVar5;\n                iStack92 = arg3;\n                if ((noname_6 == -1) && (iStack124 != 0)) {\n                    fcn.140020444(&uStack120);\n                }\n            }\n            goto code_r0x00014001a14b;\n        }\n    }\ncode_r0x00014001a13c:\n    puVar4 = fcn.140015850(arg1);\n    *puVar4 = 0x16;\ncode_r0x00014001a14b:\n    fcn.140009a80(var_48h ^ auStack184);\n    return;\n}\n",
        "token_count": 1044
    },
    "14000104": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint32_t fcn.140001040(int64_t *arg1, int64_t arg2, int64_t arg3, int64_t arg4)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int64_t noname_0;\n    int64_t arg2_00;\n    uint64_t uVar4;\n    int64_t iVar5;\n    uint64_t arg3_00;\n    int64_t arg3_01;\n    int64_t iVar6;\n    uint64_t uVar7;\n    int64_t iStack152;\n    uint uStack144;\n    int64_t iStack136;\n    uint32_t uStack128;\n    ulong uStack104;\n    ulong uStack96;\n    ulong uStack88;\n    \n    arg2_00 = 0;\n    uStack104 = 0;\n    uStack96 = 0;\n    uStack88 = 0;\n    uStack144 = 0;\n    iStack152 = 0;\n    iVar6 = arg4;\n    uVar1 = fcn.140008770(&iStack152, \"1.2.11\", 0x58);\n    if (uVar1 != 0) {\n        fcn.140001c70(\"Failed to extract %s: inflateInit() failed with return code %d!\\n\", arg2 + 0x12, uVar1, iVar6);\n        return 0xffffffff;\n    }\n    noname_0 = fcn.14000c998(0x2000);\n    if (noname_0 == 0) {\n        fcn.140001c30(\"malloc\", \"Failed to extract %s: failed to allocate temporary input buffer!\\n\", arg2 + 0x12, iVar6\n                     );\n    }\n    else {\n        arg2_00 = fcn.14000c998(0x2000);\n        if (arg2_00 == 0) {\n            fcn.140001c30(\"malloc\", \"Failed to extract %s: failed to allocate temporary output buffer!\\n\", arg2 + 0x12, \n                          iVar6);\n        }\n        else {\n            uVar7 = *(arg2 + 8);\n            do {\n                iVar6 = *arg1;\n                arg3_00 = uVar7;\n                if (0x2000 < uVar7) {\n                    arg3_00 = 0x2000;\n                }\n                uVar4 = fcn.14000bef0(noname_0, 1, arg3_00, iVar6);\n                if ((uVar4 != arg3_00) || (iVar2 = fcn.14000bc64(*arg1),  iVar2 != 0)) {\n                    uVar1 = 0xffffffff;\n                    goto code_r0x00014000125c;\n                }\n                uVar7 = uVar7 - arg3_00;\n                uStack144 = arg3_00;\n                iStack152 = noname_0;\n                do {\n                    uStack128 = 0x2000;\n                    iStack136 = arg2_00;\n                    uVar3 = fcn.140006c30(&iStack152, 0);\n                    uVar1 = 0xffffffff;\n                    if (uVar3 + 4 < 3) goto code_r0x000140001231;\n                    if (uVar3 == 2) {\n                        uVar3 = 0xfffffffd;\n                        goto code_r0x000140001231;\n                    }\n                    arg3_01 = 0x2000 - uStack128;\n                    if (arg3 == 0) {\n                        if (arg4 != 0) {\n                            fcn.14000a790(arg4, arg2_00, arg3_01);\n                            arg4 = arg4 + arg3_01;\n                        }\n                    }\n                    else {\n                        iVar6 = arg3;\n                        iVar5 = fcn.14000c8f8(arg2_00, 1, arg3_01, arg3);\n                        if ((iVar5 != arg3_01) || (iVar2 = fcn.14000bc64(arg3),  iVar2 != 0)) {\n                            uVar3 = 0xffffffff;\n                            goto code_r0x000140001231;\n                        }\n                    }\n                } while (uStack128 == 0);\n                if (uVar3 == 1) {\n                    uVar1 = 0;\n                    goto code_r0x00014000125c;\n                }\n            } while (uVar7 != 0);\ncode_r0x000140001231:\n            fcn.140001c70(\"Failed to extract %s: decompression resulted in return code %d!\\n\", arg2 + 0x12, uVar3, iVar6\n                         );\n        }\n    }\ncode_r0x00014000125c:\n    fcn.140008460(&iStack152);\n    fcn.14000c984(noname_0);\n    fcn.14000c984(arg2_00);\n    return uVar1;\n}\n",
        "token_count": 1098
    },
    "1400012a": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nint64_t fcn.1400012a0(int64_t *arg1, int64_t arg2)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    int64_t iVar3;\n    uint64_t uVar4;\n    int64_t noname_0;\n    uint64_t arg2_00;\n    ulong in_R8;\n    ulong in_R9;\n    int64_t arg4;\n    \n    iVar2 = *arg1;\n    if (iVar2 == 0) {\n        iVar2 = fcn.140002d90(arg1 + 0xf);\n        *arg1 = iVar2;\n        if (iVar2 == 0) {\n            fcn.140001c70(\"Failed to extract %s: failed to open archive file!\\n\", arg2 + 0x12, in_R8, in_R9);\n            return 0;\n        }\n    }\n    iVar1 = fcn.14000c1c0(iVar2, *(arg2 + 4) + arg1[1], 0);\n    if (iVar1 < 0) {\n        fcn.140001c30(\"fseek\", \"Failed to extract %s: failed to seek to the entry\\'s data!\\n\", arg2 + 0x12, in_R9);\n        return 0;\n    }\n    iVar2 = fcn.14000c998(*(arg2 + 0xc));\n    if (iVar2 == 0) {\n        fcn.140001c30(\"malloc\", \"Failed to extract %s: failed to allocate data buffer (%u bytes)!\\n\", arg2 + 0x12, \n                      *(arg2 + 0xc));\n    }\n    else if (*(arg2 + 0x10) == '\\x01') {\n        iVar1 = fcn.140001040(arg1, arg2, 0, iVar2);\n        if (iVar1 != 0) {\ncode_r0x0001400013e5:\n            fcn.14000c984(iVar2);\n            iVar2 = 0;\n        }\n    }\n    else {\n        noname_0 = iVar2;\n        for (uVar4 = *(arg2 + 0xc); uVar4 != 0; uVar4 = uVar4 - arg2_00) {\n            arg4 = *arg1;\n            arg2_00 = uVar4;\n            if (0x2000 < uVar4) {\n                arg2_00 = 0x2000;\n            }\n            iVar3 = fcn.14000bef0(noname_0, arg2_00, 1, arg4);\n            if (iVar3 == 0) {\n                fcn.140001c30(\"fread\", \"Failed to extract %s: failed to read data chunk!\\n\", arg2 + 0x12, arg4);\n                goto code_r0x0001400013e5;\n            }\n            noname_0 = noname_0 + arg2_00;\n        }\n    }\n    if (*arg1 != 0) {\n        fcn.14000bbd4(*arg1);\n        *arg1 = 0;\n    }\n    return iVar2;\n}\n",
        "token_count": 693
    },
    "1400016c": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nchar * fcn.1400016c0(int64_t arg1, int64_t arg2, int64_t arg3, ulong arg4)\n\n{\n    int32_t iVar1;\n    int32_t *piVar2;\n    char *pcVar3;\n    int64_t arg2_00;\n    int64_t arg3_00;\n    int64_t iVar4;\n    \n    piVar2 = *(arg1 + 0x10);\n    arg3_00 = -1;\n    do {\n        iVar4 = arg3_00;\n        arg3_00 = iVar4 + 1;\n    } while (*(arg3_00 + arg2) != '\\0');\n    arg2_00 = arg2;\n    if (piVar2 < *(arg1 + 0x18)) {\n        do {\n            if ((*(piVar2 + 0x11) == 'o') &&\n               (arg2_00 = arg2,  arg3 = arg3_00,  iVar1 = fcn.14000c9b0(piVar2 + 0x12, arg2, arg3_00),  iVar1 == 0)) {\n                pcVar3 = piVar2 + iVar4 + 0x13;\n                if (*pcVar3 != '\\0') {\n                    return piVar2 + iVar4 + 0x14;\n                }\n                return pcVar3;\n            }\n            piVar2 = *piVar2 + piVar2;\n            if (piVar2 < *(arg1 + 0x10)) {\n                fcn.140001c70(\"Cannot read Table of Contents.\\n\", arg2_00, arg3, arg4);\n                return NULL;\n            }\n        } while (piVar2 < *(arg1 + 0x18));\n    }\n    return NULL;\n}\n",
        "token_count": 391
    },
    "14000179": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nulong fcn.140001790(int64_t *arg1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int64_t iVar3;\n    int64_t iVar4;\n    uint64_t uVar5;\n    uint64_t uVar6;\n    int32_t *piVar7;\n    uint32_t *arg2;\n    uint32_t uVar8;\n    int64_t iVar9;\n    char *arg2_00;\n    int64_t arg2_01;\n    ulong uVar10;\n    int64_t in_R9;\n    \n    iVar3 = *arg1;\n    if (iVar3 == 0) {\n        iVar3 = fcn.140002d90(arg1 + 0xf);\n        *arg1 = iVar3;\n        if (iVar3 == 0) {\n            return 0xffffffff;\n        }\n    }\n    iVar4 = fcn.14000c998(0x2000);\n    iVar9 = 0;\n    if (((iVar4 != 0) && (iVar2 = fcn.14000c1c0(iVar3, 0, 2),  iVar9 = 0,  -1 < iVar2)) &&\n       (uVar5 = fcn.14000c698(iVar3),  7 < uVar5)) {\n        do {\n            arg2_01 = uVar5 - 0x2000;\n            if (uVar5 < 0x2000) {\n                arg2_01 = 0;\n            }\n            uVar5 = uVar5 - arg2_01;\n            if (((uVar5 < 8) || (iVar2 = fcn.14000c1c0(iVar3, arg2_01, 0),  iVar2 < 0)) ||\n               (in_R9 = iVar3,  uVar6 = fcn.14000bef0(iVar4, 1, uVar5, iVar3),  uVar6 != uVar5)) break;\n            iVar9 = uVar5 - 7;\n            if (iVar9 != 0) {\n                piVar7 = iVar4 + -1 + iVar9;\n                do {\n                    if ((*piVar7 == str.MEI_f_v._0_4_) && (piVar7[1] == *0x1400253f8)) {\n                        iVar9 = arg2_01 + -1 + iVar9;\n                        goto code_r0x0001400018b6;\n                    }\n                    piVar7 = piVar7 + -1;\n                    iVar9 = iVar9 + -1;\n                } while (iVar9 != 0);\n            }\n            uVar5 = arg2_01 + 7;\n        } while (arg2_01 != 0);\n        fcn.14000c984(iVar4);\n        return 0xffffffff;\n    }\ncode_r0x0001400018b6:\n    fcn.14000c984(iVar4);\n    if (iVar9 != 0) {\n        uVar10 = 0;\n        iVar2 = fcn.14000c1c0(*arg1, iVar9, 0);\n        if (-1 < iVar2) {\n            iVar3 = *arg1;\n            uVar10 = 1;\n            iVar4 = fcn.14000bef0(arg1 + 4, 0x58, 1, iVar3);\n            if (iVar4 == 0) {\n                arg2_00 = \"Failed to read cookie!\\n\";\n            }\n            else {\n                uVar8 = *(arg1 + 5);\n                uVar10 = 0;\n                uVar1 = *(arg1 + 0x2c);\n                *(arg1 + 0x2c) = uVar1 >> 0x18 | (uVar1 & 0xff0000) >> 8 | (uVar1 & 0xff00) << 8 | uVar1 << 0x18;\n                uVar1 = *(arg1 + 6);\n                *(arg1 + 6) = uVar1 >> 0x18 | (uVar1 & 0xff0000) >> 8 | (uVar1 & 0xff00) << 8 | uVar1 << 0x18;\n                uVar1 = *(arg1 + 0x34);\n                uVar8 = uVar8 >> 0x18 | (uVar8 & 0xff0000) >> 8 | (uVar8 & 0xff00) << 8 | uVar8 << 0x18;\n                *(arg1 + 5) = uVar8;\n                *0x140037c24 = uVar1 >> 0x18 | (uVar1 & 0xff0000) >> 8 | (uVar1 & 0xff00) << 8 | uVar1 << 0x18;\n                *(arg1 + 0x34) = *0x140037c24;\n                arg1[1] = (iVar9 - uVar8) + 0x58;\n                *(arg1 + 0x407c) = 0;\n                fcn.14000c1c0(*arg1, *(arg1 + 0x2c) + arg1[1], 0);\n                iVar9 = fcn.14000c998(*(arg1 + 6));\n                arg1[2] = iVar9;\n                if (iVar9 == 0) {\n                    fcn.140001c30(\"malloc\", \"Could not allocate buffer for TOC!\\n\", uVar10, iVar3);\n                    return 0xffffffff;\n                }\n                iVar4 = *(arg1 + 6);\n                uVar10 = 1;\n                iVar3 = *arg1;\n                iVar9 = fcn.14000bef0(iVar9, iVar4, 1, iVar3);\n                if (iVar9 != 0) {\n                    arg1[3] = *(arg1 + 6) + arg1[2];\n                    iVar2 = fcn.14000bc64(*arg1);\n                    if (iVar2 != 0) {\n                        fcn.140001c70(\"Error on file.\\n\", iVar4, uVar10, iVar3);\n                        return 0xffffffff;\n                    }\n                    arg2 = arg1[2];\n                    if (arg2 < arg1[3]) {\n                        do {\n                            uVar8 = arg2[1];\n                            uVar1 = *arg2;\n                            arg2[1] = uVar8 >> 0x18 | (uVar8 & 0xff0000) >> 8 | (uVar8 & 0xff00) << 8 | uVar8 << 0x18;\n                            uVar8 = arg2[2];\n                            arg2[2] = uVar8 >> 0x18 | (uVar8 & 0xff0000) >> 8 | (uVar8 & 0xff00) << 8 | uVar8 << 0x18;\n                            uVar8 = arg2[3];\n                            arg2[3] = uVar8 >> 0x18 | (uVar8 & 0xff0000) >> 8 | (uVar8 & 0xff00) << 8 | uVar8 << 0x18;\n                            uVar8 = uVar1 >> 0x18 | (uVar1 & 0xff0000) >> 8 | (uVar1 & 0xff00) << 8 | uVar1 << 0x18;\n                            *arg2 = uVar8;\n                            arg2 = uVar8 + arg2;\n                            if (arg2 < arg1[2]) {\n                                fcn.140001c70(\"Cannot read Table of Contents.\\n\", arg2, uVar10, iVar3);\n                                break;\n                            }\n                        } while (arg2 < arg1[3]);\n                    }\n                    if (*arg1 != 0) {\n                        fcn.14000bbd4(*arg1);\n                        *arg1 = 0;\n                    }\n                    return 0;\n                }\n                arg2_00 = \"Could not read full TOC!\\n\";\n            }\n            fcn.140001c30(\"fread\", arg2_00, uVar10, iVar3);\n            return 0xffffffff;\n        }\n        fcn.140001c30(\"fseek\", \"Failed to seek to cookie position!\\n\", uVar10, in_R9);\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 1847
    },
    "140001a7": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nulong fcn.140001a70(int64_t *arg1, char *arg2)\n\n{\n    char cVar1;\n    int32_t iVar2;\n    uint64_t uVar3;\n    char *pcVar4;\n    int64_t *arg1_00;\n    \n    uVar3 = 0xffffffffffffffff;\n    do {\n        uVar3 = uVar3 + 1;\n    } while (arg2[uVar3] != '\\0');\n    if (uVar3 < 0x1000) {\n        pcVar4 = arg2;\n        do {\n            cVar1 = *pcVar4;\n            pcVar4[arg1 + (0x78 - arg2)] = cVar1;\n            pcVar4 = pcVar4 + 1;\n        } while (cVar1 != '\\0');\n        arg1_00 = arg1 + 0x20f;\n        fcn.140002c00(arg1_00, arg2);\n        *(arg1 + 0x80f) = 0;\n        do {\n            cVar1 = *arg1_00;\n            *(arg1_00 + 0x400) = cVar1;\n            arg1_00 = arg1_00 + 1;\n        } while (cVar1 != '\\0');\n        iVar2 = fcn.140001790(arg1);\n        if (iVar2 == 0) {\n            return 1;\n        }\n        if (*arg1 != 0) {\n            fcn.14000bbd4(*arg1);\n            *arg1 = 0;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 351
    },
    "1400026a": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.1400026a0(int64_t arg1)\n\n{\n    if (*(arg1 + 0x407c) == 1) {\n        (**0x140037cc0)(\n                       \"import sys; sys.stdout.flush();                 (sys.__stdout__.flush if sys.__stdout__                 is not sys.stdout else (lambda: None))()\"\n                       );\n        (**0x140037cc0)(\n                       \"import sys; sys.stderr.flush();                 (sys.__stderr__.flush if sys.__stderr__                 is not sys.stderr else (lambda: None))()\"\n                       );\n    // WARNING: Could not recover jumptable at 0x00014000376b. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**0x140037c78)();\n        return;\n    }\n    return;\n}\n",
        "token_count": 175
    },
    "140002b5": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nulong fcn.140002b50(int64_t arg1, char *arg2)\n\n{\n    char cVar1;\n    int64_t iVar2;\n    int64_t iVar3;\n    \n    iVar3 = arg1 - arg2;\n    do {\n        cVar1 = *arg2;\n        arg2[iVar3] = cVar1;\n        arg2 = arg2 + 1;\n    } while (cVar1 != '\\0');\n    iVar3 = -1;\n    do {\n        iVar2 = iVar3;\n        iVar3 = iVar2 + 1;\n    } while (*(arg1 + 1 + iVar2) != '\\0');\n    *(iVar2 + -2 + arg1) = 0x676b70;\n    return 1;\n}\n",
        "token_count": 165
    },
    "140002c0": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nulong fcn.140002c00(ushort *arg1, ulong arg2)\n\n{\n    int64_t iVar1;\n    int32_t iVar2;\n    int64_t iVar3;\n    uchar *puVar4;\n    \n    iVar2 = fcn.1400027b0(arg1, 0x1000, 0x140025804, arg2);\n    if (0xfff < iVar2) {\n        return 0;\n    }\n    iVar1 = -1;\n    do {\n        iVar3 = iVar1;\n        iVar1 = iVar3 + 1;\n    } while (*(arg1 + iVar3 + 1) != '\\0');\n    if (*(iVar3 + arg1) == '\\\\') {\n        *(iVar3 + arg1) = 0;\n    }\n    puVar4 = fcn.14000ae88(arg1, 0x5c);\n    if (puVar4 != NULL) {\n        *puVar4 = 0;\n        return 1;\n    }\n    *arg1 = 0x2e;\n    return 1;\n}\n",
        "token_count": 232
    },
    "140002e1": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nint64_t fcn.140002e10(int64_t arg1, ulong arg2, int64_t arg3)\n\n{\n    int64_t iVar1;\n    int32_t iVar2;\n    uint64_t uVar3;\n    uint64_t uVar5;\n    int64_t iVar6;\n    uint64_t uVar4;\n    \n    iVar2 = fcn.1400027b0(arg1, 0x1000, 0x140025804, arg2);\n    uVar5 = iVar2;\n    if (uVar5 < 0xfff) {\n        if (*((uVar5 - 1) + arg1) != '\\\\') {\n            *(uVar5 + arg1) = 0x5c;\n            uVar5 = uVar5 + 2;\n        }\n        uVar5 = 0x1000 - uVar5;\n        uVar3 = 0xffffffffffffffff;\n        do {\n            uVar4 = uVar3;\n            uVar3 = uVar4 + 1;\n        } while (*(arg3 + uVar3) != '\\0');\n        if (uVar3 < uVar5) {\n            if (*(uVar4 + arg3) == '\\\\') {\n                fcn.140010aa0(arg1, arg3, uVar5);\n                iVar1 = -1;\n                do {\n                    iVar6 = iVar1;\n                    iVar1 = iVar6 + 1;\n                } while (*(arg1 + 1 + iVar6) != '\\0');\n                *(iVar6 + arg1) = 0;\n                return arg1;\n            }\n            fcn.140010aa0(arg1, arg3, uVar5);\n            return arg1;\n        }\n    }\n    return 0;\n}\n",
        "token_count": 377
    },
    "14000378": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nulong fcn.140003780(int64_t arg1)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    uint64_t arg2;\n    int64_t iVar3;\n    char *arg3;\n    char *arg4;\n    \n    iVar3 = -1;\n    do {\n        iVar3 = iVar3 + 1;\n    } while (*(arg1 + 0x3078 + iVar3) != '\\0');\n    arg4 = \"strict\";\n    arg3 = \"utf-8\";\n    iVar2 = (**0x140037d80)();\n    if (iVar2 != 0) {\n        (**0x140037d50)(\"_MEIPASS\", iVar2);\n        arg2 = *(arg1 + 0x10);\n        if (arg2 < *(arg1 + 0x18)) {\n            do {\n                if ((*(arg2 + 0x11) + 0xb3U & 0xdf) == 0) {\n                    iVar3 = fcn.1400012a0(arg1, arg2);\n                    if (*0x140037c24 < 0x25) {\n                        iVar1 = *(arg2 + 0xc) + -0xc;\n                        iVar2 = iVar3 + 0xc;\n                    }\n                    else {\n                        iVar1 = *(arg2 + 0xc) + -0x10;\n                        iVar2 = iVar3 + 0x10;\n                    }\n                    iVar2 = (**0x140037d90)(iVar2, iVar1);\n                    if ((iVar2 == 0) || (iVar2 = (**0x140037cc8)(arg2 + 0x12, iVar2),  iVar2 == 0)) {\n                        fcn.140001c70(\"Module object for %s is NULL!\\n\", arg2 + 0x12, arg3, arg4);\n                    }\n                    iVar2 = (**0x140037d30)();\n                    if (iVar2 != 0) {\n                        (**0x140037d38)();\n                        (**0x140037d28)();\n                    }\n                    fcn.14000c984(iVar3);\n                }\n                arg2 = fcn.140001760(arg1, arg2, arg3, arg4);\n            } while (arg2 < *(arg1 + 0x18));\n        }\n        return 0;\n    }\n    fcn.140001c70(\"Failed to get _MEIPASS as PyObject.\\n\", iVar3, arg3, arg4);\n    return 0xffffffff;\n}\n",
        "token_count": 544
    },
    "1400038b": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nulong fcn.1400038b0(int64_t arg1, ulong noname_1, int64_t arg3, char *arg4)\n\n{\n    int32_t iVar1;\n    ulong uVar2;\n    ulong arg2;\n    uint64_t arg2_00;\n    int64_t iVar3;\n    ulong arg2_01;\n    \n    arg2_00 = *(arg1 + 0x10);\n    if (arg2_00 < *(arg1 + 0x18)) {\n        do {\n            if (*(arg2_00 + 0x11) == 'z') {\n                arg3 = *(arg2_00 + 4) + *(arg1 + 8);\n                iVar3 = -1;\n                do {\n                    iVar3 = iVar3 + 1;\n                } while (*(arg1 + 0x78 + iVar3) != '\\0');\n                arg4 = \"strict\";\n                uVar2 = (**0x140037d80)(arg1 + 0x78, iVar3, \"utf-8\");\n                arg2_01 = uVar2;\n                arg2 = (**0x140037d70)(\"%U?%llu\");\n                (**0x140037c88)(uVar2);\n                iVar3 = (**0x140037d68)(\"path\");\n                if (iVar3 == 0) {\n                    fcn.140001c70(\"Installing PYZ: Could not get sys.path\\n\", arg2_01, arg3, arg4);\n                    (**0x140037c88)(arg2);\n                }\n                else {\n                    iVar1 = (**0x140037cf0)(iVar3);\n                    if (iVar1 != 0) {\n                        fcn.140001c70(\"Failed to append to sys.path\\n\", arg2, arg3, arg4);\n                    }\n                }\n            }\n            arg2_00 = fcn.140001760(arg1, arg2_00, arg3, arg4);\n        } while (arg2_00 < *(arg1 + 0x18));\n    }\n    return 0;\n}\n",
        "token_count": 448
    },
    "1400039b": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.1400039b0(int64_t param_1)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    int64_t iVar3;\n    uchar *arg3;\n    int64_t arg4;\n    uchar auStackX24 [16];\n    ulong uStack16;\n    \n    uStack16 = 0x1400039c0;\n    iVar2 = fcn.140009a10();\n    iVar2 = -iVar2;\n    *(&stack0x00002058 + iVar2) = *0x140037018 ^ &stack0xfffffffffffffff8 + iVar2;\n    arg4 = param_1 + 0x38;\n    *(&stack0xfffffffffffffff0 + iVar2) = 0x1400039f2;\n    iVar1 = fcn.1400027b0(&stack0x00000018 + iVar2, 0x40, 0x140025804, arg4);\n    if (iVar1 < 0x40) {\n        if (*(param_1 + 0x4078) != 0) {\n            *(&stack0xfffffffffffffff0 + iVar2) = 0x140003a3c;\n            iVar3 = fcn.140002e10(&stack0x00000058 + iVar2, param_1 + 0x2078, \"ucrtbase.dll\");\n            if (iVar3 == 0) {\n                *(&stack0xfffffffffffffff0 + iVar2) = 0x140003a5a;\n                fcn.140001c70(\"Path of ucrtbase.dll (%s) length exceeds buffer[%d] space\\n\", param_1 + 0x2078, 0x1000, \n                              arg4);\n            }\n            *(&stack0xfffffffffffffff0 + iVar2) = 0x140003a64;\n            iVar1 = fcn.140002d20(&stack0x00000058 + iVar2);\n            if (iVar1 != 0) {\n                *(&stack0xfffffffffffffff0 + iVar2) = 0x140003a72;\n                fcn.140005eb0(&stack0x00000058 + iVar2);\n            }\n        }\n        arg3 = &stack0x00000018 + iVar2;\n        *(&stack0xfffffffffffffff0 + iVar2) = 0x140003a8b;\n        iVar3 = fcn.140002e10(&stack0x00001058 + iVar2, param_1 + 0x3078, arg3);\n        if (iVar3 == 0) {\n            arg3 = 0x1000;\n            *(&stack0xfffffffffffffff0 + iVar2) = 0x140003aa9;\n            fcn.140001c70(\"Path of DLL (%s) length exceeds buffer[%d] space\\n\", param_1 + 0x3078, 0x1000, arg4);\n        }\n        *(&stack0xfffffffffffffff0 + iVar2) = 0x140003ab6;\n        iVar3 = fcn.140005eb0(&stack0x00001058 + iVar2);\n        if (iVar3 == 0) {\n            *(&stack0xfffffffffffffff0 + iVar2) = 0x140003ad6;\n            fcn.140001cd0(\"LoadLibrary\", \"Error loading Python DLL \\'%s\\'.\\n\", &stack0x00001058 + iVar2, arg4);\n        }\n        else {\n            *(&stack0xfffffffffffffff0 + iVar2) = 0x140003aeb;\n            fcn.140002ed0(iVar3, *0x140037c24, arg3, arg4);\n        }\n    }\n    else {\n        *(&stack0xfffffffffffffff0 + iVar2) = 0x140003a11;\n        fcn.140001c70(\"Reported length (%d) of DLL name (%s) length exceeds buffer[%d] space\\n\", iVar1, param_1 + 0x38, \n                      0x40);\n    }\n    *(&stack0xfffffffffffffff0 + iVar2) = 0x140003afb;\n    fcn.140009a80(*(&stack0x00002058 + iVar2) ^ &stack0xfffffffffffffff8 + iVar2);\n    return;\n}\n",
        "token_count": 932
    },
    "140003b1": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nvoid fcn.140003b10(int64_t param_1, ulong param_2, ulong param_3, ulong param_4)\n\n{\n    char cVar1;\n    bool bVar2;\n    int32_t iVar3;\n    uint32_t uVar4;\n    int64_t iVar5;\n    int64_t iVar6;\n    uint *puVar7;\n    uint64_t arg2;\n    ulong uVar8;\n    ulong uStack16;\n    \n    uStack16 = 0x140003b2a;\n    iVar5 = fcn.140009a10();\n    iVar5 = -iVar5;\n    *(&stack0x00002028 + iVar5) = *0x140037018 ^ &stack0xfffffffffffffff8 + iVar5;\n    bVar2 = false;\n    arg2 = *(param_1 + 0x10);\n    **0x140037c30 = 1;\n    **0x140037c28 = 1;\n    **0x140037c58 = 1;\n    **0x140037c60 = 1;\n    **0x140037c50 = 1;\n    **0x140037c48 = 0;\n    if (arg2 < *(param_1 + 0x18)) {\n        do {\n            if (*(arg2 + 0x11) == 'o') {\n                param_3 = 4;\n                *(&stack0xfffffffffffffff0 + iVar5) = 0x140003bbc;\n                iVar3 = fcn.14000c9b0(arg2 + 0x12, \"pyi-\", 4);\n                if (iVar3 != 0) {\n                    cVar1 = *(arg2 + 0x12);\n                    puVar7 = *0x140037c38;\n                    if (cVar1 == 'O') {\ncode_r0x000140003c1a:\n                        *puVar7 = 1;\n                    }\n                    else if (cVar1 == 'W') {\n                        param_3 = 0x1000;\n                        *(&stack0xfffffffffffffff0 + iVar5) = 0x140003bfc;\n                        iVar6 = fcn.140011234(&stack0x00000018 + iVar5, arg2 + 0x14, 0x1000);\n                        if (iVar6 == -1) {\n                            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003d1e;\n                            fcn.140001c70(\"Failed to convert Wflag %s using mbstowcs (invalid multibyte string)\\n\", \n                                          arg2 + 0x14, param_3, param_4);\n                            goto code_r0x000140003ce5;\n                        }\n                        *(&stack0xfffffffffffffff0 + iVar5) = 0x140003c11;\n                        (**0x140037d40)(&stack0x00000018 + iVar5);\n                    }\n                    else if (cVar1 == 'u') {\n                        bVar2 = true;\n                    }\n                    else {\n                        puVar7 = *0x140037c48;\n                        if (cVar1 == 'v') goto code_r0x000140003c1a;\n                    }\n                }\n            }\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003c2b;\n            arg2 = fcn.140001760(param_1, arg2, param_3, param_4);\n        } while (arg2 < *(param_1 + 0x18));\n        if (bVar2) {\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003c47;\n            uVar8 = fcn.14000cb50(0);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003c4f;\n            uVar4 = fcn.1400149ec(uVar8);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003c5b;\n            fcn.1400112c0(uVar4, 0x8000);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003c65;\n            uVar8 = fcn.14000cb50(1);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003c6d;\n            uVar4 = fcn.1400149ec(uVar8);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003c79;\n            fcn.1400112c0(uVar4, 0x8000);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003c83;\n            uVar8 = fcn.14000cb50(1);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003c8b;\n            fcn.140011790(uVar8);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003c95;\n            uVar8 = fcn.14000cb50(2);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003c9d;\n            fcn.140011790(uVar8);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003ca4;\n            uVar8 = fcn.14000cb50(0);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003cae;\n            fcn.140010a64(uVar8, 0, param_3, param_4);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003cb8;\n            uVar8 = fcn.14000cb50(1);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003cc2;\n            fcn.140010a64(uVar8, 0, param_3, param_4);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003ccc;\n            uVar8 = fcn.14000cb50(2);\n            *(&stack0xfffffffffffffff0 + iVar5) = 0x140003cd6;\n            fcn.140010a64(uVar8, 0, param_3, param_4);\n            **0x140037c68 = 1;\n        }\n    }\ncode_r0x000140003ce5:\n    *(&stack0xfffffffffffffff0 + iVar5) = 0x140003cf5;\n    fcn.140009a80(*(&stack0x00002028 + iVar5) ^ &stack0xfffffffffffffff8 + iVar5);\n    return;\n}\n",
        "token_count": 1460
    },
    "1400044a": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.1400044a0(int64_t param_1, int64_t param_2, int64_t param_3, ulong param_4)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    int32_t *arg1;\n    int32_t *arg2;\n    int64_t iVar3;\n    int64_t iVar4;\n    int64_t iVar5;\n    int64_t arg2_00;\n    uint64_t uVar7;\n    ulong unaff_R13;\n    ulong unaff_R14;\n    uint64_t uVar8;\n    ulong uStack56;\n    int64_t iVar6;\n    \n    uStack56 = 0x1400044b3;\n    iVar2 = fcn.140009a10();\n    iVar2 = -iVar2;\n    *(&stack0x00002000 + iVar2) = *0x140037018 ^ &stack0xffffffffffffffd0 + iVar2;\n    uVar7 = 0;\n    *(&stack0xfffffffffffffff8 + iVar2) = param_1;\n    *(&stack0xffffffffffffffc8 + iVar2) = 0x1400044e7;\n    arg1 = fcn.14000c97c(1, 0x1014);\n    if (*(param_2 + 0x4038) != 0) {\n        *(&stack0x00002060 + iVar2) = unaff_R13;\n        *(&stack0x00002010 + iVar2) = unaff_R14;\n        uVar8 = uVar7;\n        do {\n            arg2_00 = *(param_2 + 0x4030) + uVar8;\n            *(&stack0xffffffffffffffc8 + iVar2) = 0x140004525;\n            arg2 = fcn.140001640(param_1, arg2_00);\n            if (arg2 == NULL) {\n                if (uVar7 != 0) {\n                    *(&stack0xffffffffffffffc8 + iVar2) = 0x1400046fb;\n                    fcn.140001c70(\"SPLASH: Cannot find requirement %s in archive.\\n\", arg2_00, param_3, param_4);\n                    goto code_r0x0001400046ab;\n                }\n            }\n            else {\n                iVar1 = *arg2;\n                *(&stack0xfffffffffffffff0 + iVar2) = 1;\n                *(&stack0xffffffffffffffc8 + iVar2) = 0x140004547;\n                fcn.14000a790(arg1, arg2, iVar1);\n                param_3 = arg2 + 0x12;\n                *(&stack0xffffffffffffffc8 + iVar2) = 0x14000455f;\n                fcn.140002e10(arg1 + 0x12, param_2 + 0x3010, param_3);\n                iVar5 = -1;\n                do {\n                    iVar3 = iVar5 + 1;\n                    iVar6 = iVar5 + 0x13;\n                    iVar5 = iVar3;\n                } while (*(arg2 + iVar6) != '\\0');\n                iVar5 = -1;\n                do {\n                    iVar4 = iVar5 + 1;\n                    iVar6 = iVar5 + 0x13;\n                    iVar5 = iVar4;\n                } while (*(arg1 + iVar6) != '\\0');\n                *arg1 = (*arg2 - iVar3) + iVar4;\n                *(&stack0xffffffffffffffc8 + iVar2) = 0x1400045ae;\n                iVar1 = fcn.140001430(*(&stack0xfffffffffffffff8 + iVar2), arg1, param_3);\n                if (iVar1 != 0) {\n                    *(&stack0xffffffffffffffc8 + iVar2) = 0x1400046e5;\n                    fcn.140001c70(\"SPLASH: Cannot extract requirement %s.\\n\", arg2 + 0x12, param_3, param_4);\n                    goto code_r0x0001400046ab;\n                }\n                uVar7 = *(&stack0xfffffffffffffff0 + iVar2);\n                param_1 = *(&stack0xfffffffffffffff8 + iVar2);\n            }\n            iVar5 = -1;\n            do {\n                iVar6 = iVar5;\n                iVar5 = iVar6 + 1;\n            } while (*(arg2_00 + iVar5) != '\\0');\n            uVar8 = uVar8 + iVar6 + 2;\n        } while (uVar8 < *(param_2 + 0x4038));\n        if (uVar7 != 0) {\n            *(&stack0xffffffffffffffc8 + iVar2) = 0x140004615;\n            fcn.140002e10(&stack0x00001000 + iVar2, param_1 + 0x2078, param_2 + 0x3010);\n            *(&stack0xffffffffffffffc8 + iVar2) = 0x140004629;\n            fcn.140011810(&stack0x00000000 + iVar2, param_2 + 0x10, 0x1000);\n            *(&stack0xffffffffffffffc8 + iVar2) = 0x14000463f;\n            fcn.140002e10(param_2 + 0x10, &stack0x00001000 + iVar2, &stack0x00000000 + iVar2);\n            *(&stack0xffffffffffffffc8 + iVar2) = 0x140004656;\n            fcn.140011810(&stack0x00000000 + iVar2, param_2 + 0x1010, 0x1000);\n            *(&stack0xffffffffffffffc8 + iVar2) = 0x14000466f;\n            fcn.140002e10(param_2 + 0x1010, &stack0x00001000 + iVar2, &stack0x00000000 + iVar2);\n            *(&stack0xffffffffffffffc8 + iVar2) = 0x140004680;\n            fcn.140002ba0(&stack0x00000000 + iVar2, param_2 + 0x2010);\n            *(&stack0xffffffffffffffc8 + iVar2) = 0x140004699;\n            fcn.140002e10(param_2 + 0x2010, &stack0x00001000 + iVar2, &stack0x00000000 + iVar2);\n        }\n    }\ncode_r0x0001400046ab:\n    *(&stack0xffffffffffffffc8 + iVar2) = 0x1400046b3;\n    fcn.14000c984(arg1);\n    *(&stack0xffffffffffffffc8 + iVar2) = 0x1400046c5;\n    fcn.140009a80(*(&stack0x00002000 + iVar2) ^ &stack0xffffffffffffffd0 + iVar2);\n    return;\n}\n",
        "token_count": 1518
    },
    "1400048f": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nulong fcn.1400048f0(int64_t arg1, int64_t arg2, int64_t arg3)\n\n{\n    bool bVar1;\n    uint32_t uVar2;\n    uint64_t arg2_00;\n    int64_t arg2_01;\n    ulong uVar3;\n    int64_t iVar4;\n    int64_t arg2_02;\n    int64_t arg3_00;\n    ulong in_R9;\n    \n    bVar1 = false;\n    arg2_01 = arg3;\n    if (arg3 == 0) {\n        arg2_00 = *(arg2 + 0x10);\n        arg2_01 = 0;\n        if (arg2_00 < *(arg2 + 0x18)) {\n            while (*(arg2_00 + 0x11) != 'l') {\n                arg2_00 = fcn.140001760(arg2, arg2_00, arg3, in_R9);\n                if (*(arg2 + 0x18) <= arg2_00) {\n                    return 0xffffffff;\n                }\n            }\n            arg2_01 = fcn.1400012a0(arg2, arg2_00);\n        }\n        if (arg2_01 == 0) {\n            return 0xffffffff;\n        }\n        bVar1 = true;\n    }\n    fcn.140011810(arg1 + 0x10, arg2_01, 0x10);\n    fcn.140011810(arg1 + 0x1010, arg2_01 + 0x10, 0x10);\n    fcn.140011810(arg1 + 0x3010, arg2_01 + 0x30, 0x10);\n    arg3_00 = arg2_01 + 0x20;\n    fcn.140002e10(arg1 + 0x2010, arg2 + 0x1078, arg3_00);\n    uVar2 = *(arg2_01 + 0x40);\n    uVar2 = uVar2 >> 0x18 | (uVar2 & 0xff0000) >> 8 | (uVar2 & 0xff00) << 8 | uVar2 << 0x18;\n    *(arg1 + 0x4018) = uVar2;\n    arg2_02 = uVar2 + 1;\n    uVar3 = fcn.14000c97c(1, arg2_02);\n    *(arg1 + 0x4010) = uVar3;\n    uVar2 = *(arg2_01 + 0x48);\n    uVar2 = uVar2 >> 0x18 | (uVar2 & 0xff0000) >> 8 | (uVar2 & 0xff00) << 8 | uVar2 << 0x18;\n    *(arg1 + 0x4028) = uVar2;\n    uVar3 = fcn.14000c998(uVar2);\n    *(arg1 + 0x4020) = uVar3;\n    uVar2 = *(arg2_01 + 0x50);\n    uVar2 = uVar2 >> 0x18 | (uVar2 & 0xff0000) >> 8 | (uVar2 & 0xff00) << 8 | uVar2 << 0x18;\n    *(arg1 + 0x4038) = uVar2;\n    iVar4 = fcn.14000c998(uVar2);\n    *(arg1 + 0x4030) = iVar4;\n    if (((*(arg1 + 0x4010) != 0) && (*(arg1 + 0x4020) != 0)) && (iVar4 != 0)) {\n        uVar2 = *(arg2_01 + 0x44);\n        fcn.14000a790(*(arg1 + 0x4010), \n                      (uVar2 >> 0x18 | (uVar2 & 0xff0000) >> 8 | (uVar2 & 0xff00) << 8 | uVar2 << 0x18) + arg2_01, \n                      *(arg1 + 0x4018));\n        uVar2 = *(arg2_01 + 0x4c);\n        fcn.14000a790(*(arg1 + 0x4020), \n                      (uVar2 >> 0x18 | (uVar2 & 0xff0000) >> 8 | (uVar2 & 0xff00) << 8 | uVar2 << 0x18) + arg2_01, \n                      *(arg1 + 0x4028));\n        uVar2 = *(arg2_01 + 0x54);\n        fcn.14000a790(*(arg1 + 0x4030), \n                      (uVar2 >> 0x18 | (uVar2 & 0xff0000) >> 8 | (uVar2 & 0xff00) << 8 | uVar2 << 0x18) + arg2_01, \n                      *(arg1 + 0x4038));\n        if (bVar1) {\n            fcn.14000c984(arg2_01);\n        }\n        return 0;\n    }\n    fcn.140001c70(\"Cannot allocate memory for necessary files.\\n\", arg2_02, arg3_00, in_R9);\n    return 0xffffffff;\n}\n",
        "token_count": 1208
    },
    "140004aa": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nulong fcn.140004aa0(int64_t arg1, ulong arg2)\n\n{\n    int32_t iVar1;\n    ulong arg2_00;\n    int64_t arg3;\n    ulong arg4;\n    \n    (**0x140044ec8)(0x140044e48);\n    if ((*(arg1 + 0x4048) != 0) && (*(arg1 + 0x4050) != 0)) {\n        (**0x140044e90)(arg2);\n        arg4 = 0;\n        arg2_00 = 0x140003fd0;\n        arg3 = arg1;\n        iVar1 = (**0x140044eb8)(arg1 + 8);\n        if (iVar1 == 0) {\n            (**0x140044ec8)(0x140044e58);\n            (**0x140044ed0)(0x140044e48);\n            (**0x140044ee8)(0x140044e60, 0x140044e58, 0);\n            (**0x140044ed0)(0x140044e58);\n            (**0x140044ed8)(0x140044e60);\n            return 0;\n        }\n        fcn.140001c70(\"SPLASH: Tcl is not threaded. Only threaded tcl is supported.\\n\", arg2_00, arg3, arg4);\n        (**0x140044ed0)(0x140044e48);\n        fcn.140004710(arg1);\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 335
    },
    "14000548": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nulong fcn.140005480(int64_t arg1, ulong noname_1, ulong arg3, ulong arg4)\n\n{\n    int32_t iVar1;\n    ulong arg2;\n    \n    if (*(arg1 + 0x4078) != 1) {\n        arg2 = fcn.1400016c0(arg1, \"pyi-runtime-tmpdir\", arg3, arg4);\n        iVar1 = fcn.1400054e0(arg1 + 0x2078);\n        if (iVar1 == 0) {\n            fcn.140001c70(\"INTERNAL ERROR: cannot create temporary directory!\\n\", arg2, arg3, arg4);\n            return 0xffffffff;\n        }\n        *(arg1 + 0x4078) = 1;\n    }\n    return 0;\n}\n",
        "token_count": 178
    },
    "1400056f": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.1400056f0(ulong param_1)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    ulong uVar3;\n    char *arg1;\n    uchar auStackX32 [8];\n    ulong uStack8;\n    \n    uStack8 = 0x1400056fa;\n    iVar2 = fcn.140009a10();\n    iVar2 = -iVar2;\n    *(&stack0x00004020 + iVar2) = *0x140037018 ^ &stack0x00000000 + iVar2;\n    *(&stack0xfffffffffffffff8 + iVar2) = 0x14000571c;\n    uVar3 = fcn.1400068b0(0, param_1, 0);\n    *(&stack0xfffffffffffffff8 + iVar2) = 0x140005730;\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetEnvironmentVariableW)(uVar3, &stack0x00000020 + iVar2, 0x2000);\n    if (iVar1 != 0) {\n        *(&stack0xfffffffffffffff8 + iVar2) = 0x14000574d;\n        (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(&stack0x00000020 + iVar2, &stack0x00002020 + iVar2);\n        *(&stack0xfffffffffffffff8 + iVar2) = 0x14000575c;\n        arg1 = fcn.1400069c0(0, &stack0x00000020 + iVar2, 0);\n        if ((arg1 != NULL) && (*arg1 != '\\0')) {\n            *(&stack0xfffffffffffffff8 + iVar2) = 0x14000576e;\n            fcn.140014974(arg1);\n            *(&stack0xfffffffffffffff8 + iVar2) = 0x14000577e;\n            fcn.140009a80(*(&stack0x00004020 + iVar2) ^ &stack0x00000000 + iVar2);\n            return;\n        }\n    }\n    *(&stack0xfffffffffffffff8 + iVar2) = 0x140005798;\n    fcn.140009a80(*(&stack0x00004020 + iVar2) ^ &stack0x00000000 + iVar2);\n    return;\n}\n",
        "token_count": 508
    },
    "1400057a": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.1400057a0(ulong param_1, ulong param_2)\n\n{\n    char *pcVar1;\n    char cVar2;\n    int32_t iVar3;\n    int64_t iVar4;\n    int64_t iVar5;\n    uchar *puVar6;\n    int64_t iVar7;\n    ushort *puVar8;\n    uint64_t uVar9;\n    ulong arg3;\n    ulong uStack16;\n    \n    uStack16 = 0x1400057b0;\n    iVar4 = fcn.140009a10();\n    iVar4 = -iVar4;\n    *(&stack0x00004048 + iVar4) = *0x140037018 ^ &stack0xfffffffffffffff8 + iVar4;\n    *(&stack0xfffffffffffffff0 + iVar4) = 0x1400057e1;\n    iVar3 = fcn.1400027b0(&stack0x00000048 + iVar4, 0x1000, 0x140025804, param_1);\n    if (iVar3 < 0x1000) {\n        *(&stack0xfffffffffffffff0 + iVar4) = 0x140005808;\n        iVar3 = fcn.1400027b0(&stack0x00001048 + iVar4, 0x1000, 0x140025804, param_2);\n        if (iVar3 < 0x1000) {\n            uVar9 = 0xffffffffffffffff;\n            do {\n                uVar9 = uVar9 + 1;\n            } while ((&stack0x00000049)[uVar9 + iVar4 + -1] != '\\0');\n            *(&stack0xfffffffffffffff0 + iVar4) = 0x14000583d;\n            iVar5 = fcn.140010c38(&stack0x00001048 + iVar4, 0x140025854);\n            if (iVar5 != 0) {\n                while( true ) {\n                    iVar7 = -1;\n                    do {\n                        iVar7 = iVar7 + 1;\n                    } while (*(iVar5 + iVar7) != '\\0');\n                    uVar9 = uVar9 + 1 + iVar7;\n                    if (0xffe < uVar9) goto code_r0x00014000596d;\n                    puVar8 = &stack0x00000047 + iVar4;\n                    do {\n                        pcVar1 = puVar8 + 1;\n                        puVar8 = puVar8 + 1;\n                    } while (*pcVar1 != '\\0');\n                    *puVar8 = *0x140025854;\n                    puVar6 = &stack0x00000047 + iVar4;\n                    do {\n                        pcVar1 = puVar6 + 1;\n                        puVar6 = puVar6 + 1;\n                    } while (*pcVar1 != '\\0');\n                    iVar7 = 0;\n                    do {\n                        cVar2 = *(iVar5 + iVar7);\n                        puVar6[iVar7] = cVar2;\n                        iVar7 = iVar7 + 1;\n                    } while (cVar2 != '\\0');\n                    *(&stack0xfffffffffffffff0 + iVar4) = 0x1400058cd;\n                    iVar5 = fcn.140010c38(0, 0x140025854);\n                    if (iVar5 == 0) break;\n                    *(&stack0xfffffffffffffff0 + iVar4) = 0x1400058ed;\n                    fcn.1400068b0(&stack0x00002048 + iVar4, &stack0x00000048 + iVar4, 0x1000);\n                    *(&stack0xfffffffffffffff0 + iVar4) = 0x1400058ff;\n                    iVar3 = fcn.140010a5c(&stack0x00002048 + iVar4, &stack0x00000018 + iVar4);\n                    if (iVar3 < 0) {\n                        *(&stack0xfffffffffffffff0 + iVar4) = 0x140005914;\n                        fcn.140006560(&stack0x00002048 + iVar4);\n                    }\n                }\n            }\n            arg3 = 0x1000;\n            *(&stack0xfffffffffffffff0 + iVar4) = 0x140005931;\n            fcn.1400068b0(&stack0x00002048 + iVar4, &stack0x00000048 + iVar4, 0x1000);\n            *(&stack0xfffffffffffffff0 + iVar4) = 0x140005943;\n            iVar3 = fcn.140010a5c(&stack0x00002048 + iVar4, &stack0x00000018 + iVar4);\n            if (iVar3 == 0) {\n                *(&stack0xfffffffffffffff0 + iVar4) = 0x140005958;\n                fcn.140001c70(\"WARNING: file already exists but should not: %s\\n\", &stack0x00000048 + iVar4, arg3, \n                              param_2);\n            }\n            *(&stack0xfffffffffffffff0 + iVar4) = 0x140005969;\n            fcn.140002d90(&stack0x00000048 + iVar4, 0x1400279a4);\n        }\n    }\ncode_r0x00014000596d:\n    *(&stack0xfffffffffffffff0 + iVar4) = 0x14000597d;\n    fcn.140009a80(*(&stack0x00004048 + iVar4) ^ &stack0xfffffffffffffff8 + iVar4);\n    return;\n}\n",
        "token_count": 1207
    },
    "14000599": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.140005990(ulong param_1)\n\n{\n    int16_t *piVar1;\n    uint uVar2;\n    uint uVar3;\n    uint uVar4;\n    uint uVar5;\n    uint uVar6;\n    uint uVar7;\n    uint uVar8;\n    uint uVar9;\n    uint *puVar10;\n    int32_t iVar11;\n    int64_t iVar12;\n    int64_t iVar13;\n    uint *puVar14;\n    uint *puVar15;\n    uint *puVar16;\n    int64_t iVar17;\n    int64_t iVar18;\n    uint auStackX24 [4];\n    ulong uStack16;\n    \n    uStack16 = 0x1400059a0;\n    iVar12 = fcn.140009a10();\n    iVar12 = -iVar12;\n    *(&stack0x00004498 + iVar12) = *0x140037018 ^ &stack0xfffffffffffffff8 + iVar12;\n    *(&stack0xfffffffffffffff0 + iVar12) = 0x1400059cb;\n    fcn.1400068b0(&stack0x00002488 + iVar12, param_1, 0x1000);\n    iVar17 = 0;\n    do {\n        iVar13 = iVar17 + iVar12;\n        *(&stack0x00000478 + iVar17 + iVar12) = *(&stack0x00002488 + iVar13);\n        iVar17 = iVar17 + 2;\n    } while (*(&stack0x00002488 + iVar13) != 0);\n    iVar17 = -1;\n    do {\n        iVar13 = iVar17;\n        iVar17 = iVar13 + 1;\n    } while (*(&stack0x00000478 + iVar17 * 2 + iVar12) != 0);\n    if ((*(&stack0x00000476 + iVar17 * 2 + iVar12) != 0x2f) && (*(&stack0x00000476 + iVar17 * 2 + iVar12) != 0x5c)) {\n        puVar15 = &stack0x00000476 + iVar12;\n        do {\n            piVar1 = puVar15 + 2;\n            puVar15 = puVar15 + 2;\n        } while (*piVar1 != 0);\n        iVar17 = iVar13 + 2;\n        *puVar15 = *0x140027964;\n    }\n    puVar15 = &stack0x00000476 + iVar12;\n    do {\n        piVar1 = puVar15 + 2;\n        puVar15 = puVar15 + 2;\n    } while (*piVar1 != 0);\n    *puVar15 = *0x140027968;\n    *(&stack0xfffffffffffffff0 + iVar12) = 0x140005a7a;\n    iVar13 = fcn.1400123f0(&stack0x00000478 + iVar12, &stack0x00000248 + iVar12);\n    if (iVar13 != -1) {\n        iVar18 = 4;\n        puVar15 = &stack0x00000018 + iVar12;\n        puVar10 = &stack0x00000248 + iVar12;\n        do {\n            puVar16 = puVar10;\n            puVar14 = puVar15;\n            uVar2 = puVar16[1];\n            uVar3 = puVar16[2];\n            uVar4 = puVar16[3];\n            uVar5 = puVar16[4];\n            uVar6 = puVar16[5];\n            uVar7 = puVar16[6];\n            uVar8 = puVar16[7];\n            *puVar14 = *puVar16;\n            puVar14[1] = uVar2;\n            puVar14[2] = uVar3;\n            puVar14[3] = uVar4;\n            uVar2 = puVar16[8];\n            uVar3 = puVar16[9];\n            uVar4 = puVar16[10];\n            uVar9 = puVar16[0xb];\n            puVar14[4] = uVar5;\n            puVar14[5] = uVar6;\n            puVar14[6] = uVar7;\n            puVar14[7] = uVar8;\n            uVar5 = puVar16[0xc];\n            uVar6 = puVar16[0xd];\n            uVar7 = puVar16[0xe];\n            uVar8 = puVar16[0xf];\n            puVar14[8] = uVar2;\n            puVar14[9] = uVar3;\n            puVar14[10] = uVar4;\n            puVar14[0xb] = uVar9;\n            uVar2 = puVar16[0x10];\n            uVar3 = puVar16[0x11];\n            uVar4 = puVar16[0x12];\n            uVar9 = puVar16[0x13];\n            puVar14[0xc] = uVar5;\n            puVar14[0xd] = uVar6;\n            puVar14[0xe] = uVar7;\n            puVar14[0xf] = uVar8;\n            uVar5 = puVar16[0x14];\n            uVar6 = puVar16[0x15];\n            uVar7 = puVar16[0x16];\n            uVar8 = puVar16[0x17];\n            puVar14[0x10] = uVar2;\n            puVar14[0x11] = uVar3;\n            puVar14[0x12] = uVar4;\n            puVar14[0x13] = uVar9;\n            uVar2 = puVar16[0x18];\n            uVar3 = puVar16[0x19];\n            uVar4 = puVar16[0x1a];\n            uVar9 = puVar16[0x1b];\n            puVar14[0x14] = uVar5;\n            puVar14[0x15] = uVar6;\n            puVar14[0x16] = uVar7;\n            puVar14[0x17] = uVar8;\n            uVar5 = puVar16[0x1c];\n            uVar6 = puVar16[0x1d];\n            uVar7 = puVar16[0x1e];\n            uVar8 = puVar16[0x1f];\n            puVar14[0x18] = uVar2;\n            puVar14[0x19] = uVar3;\n            puVar14[0x1a] = uVar4;\n            puVar14[0x1b] = uVar9;\n            puVar14[0x1c] = uVar5;\n            puVar14[0x1d] = uVar6;\n            puVar14[0x1e] = uVar7;\n            puVar14[0x1f] = uVar8;\n            iVar18 = iVar18 + -1;\n            puVar15 = puVar14 + 0x20;\n            puVar10 = puVar16 + 0x20;\n        } while (iVar18 != 0);\n        uVar6 = puVar16[0x21];\n        uVar7 = puVar16[0x22];\n        uVar8 = puVar16[0x23];\n        uVar2 = puVar16[0x24];\n        uVar3 = puVar16[0x25];\n        uVar4 = puVar16[0x26];\n        uVar5 = puVar16[0x27];\n        puVar14[0x20] = puVar16[0x20];\n        puVar14[0x21] = uVar6;\n        puVar14[0x22] = uVar7;\n        puVar14[0x23] = uVar8;\n        uVar6 = puVar16[0x28];\n        uVar7 = puVar16[0x29];\n        uVar8 = puVar16[0x2a];\n        uVar9 = puVar16[0x2b];\n        puVar14[0x24] = uVar2;\n        puVar14[0x25] = uVar3;\n        puVar14[0x26] = uVar4;\n        puVar14[0x27] = uVar5;\n        puVar14[0x28] = uVar6;\n        puVar14[0x29] = uVar7;\n        puVar14[0x2a] = uVar8;\n        puVar14[0x2b] = uVar9;\n        *(&stack0xfffffffffffffff0 + iVar12) = 0x140005b1e;\n        fcn.140005f00(&stack0x00000478 + iVar12, iVar17, &stack0x00000018 + iVar12);\n        *(&stack0xfffffffffffffff0 + iVar12) = 0x140005b2e;\n        iVar11 = fcn.1400123f8(iVar13, &stack0x00000248 + iVar12);\n        while (iVar11 == 0) {\n            iVar18 = 4;\n            puVar15 = &stack0x00000248 + iVar12;\n            puVar10 = &stack0x00000018 + iVar12;\n            do {\n                puVar16 = puVar10;\n                puVar14 = puVar15;\n                uVar2 = puVar14[1];\n                uVar3 = puVar14[2];\n                uVar4 = puVar14[3];\n                uVar5 = puVar14[4];\n                uVar6 = puVar14[5];\n                uVar7 = puVar14[6];\n                uVar8 = puVar14[7];\n                *puVar16 = *puVar14;\n                puVar16[1] = uVar2;\n                puVar16[2] = uVar3;\n                puVar16[3] = uVar4;\n                uVar2 = puVar14[8];\n                uVar3 = puVar14[9];\n                uVar4 = puVar14[10];\n                uVar9 = puVar14[0xb];\n                puVar16[4] = uVar5;\n                puVar16[5] = uVar6;\n                puVar16[6] = uVar7;\n                puVar16[7] = uVar8;\n                uVar5 = puVar14[0xc];\n                uVar6 = puVar14[0xd];\n                uVar7 = puVar14[0xe];\n                uVar8 = puVar14[0xf];\n                puVar16[8] = uVar2;\n                puVar16[9] = uVar3;\n                puVar16[10] = uVar4;\n                puVar16[0xb] = uVar9;\n                uVar2 = puVar14[0x10];\n                uVar3 = puVar14[0x11];\n                uVar4 = puVar14[0x12];\n                uVar9 = puVar14[0x13];\n                puVar16[0xc] = uVar5;\n                puVar16[0xd] = uVar6;\n                puVar16[0xe] = uVar7;\n                puVar16[0xf] = uVar8;\n                uVar5 = puVar14[0x14];\n                uVar6 = puVar14[0x15];\n                uVar7 = puVar14[0x16];\n                uVar8 = puVar14[0x17];\n                puVar16[0x10] = uVar2;\n                puVar16[0x11] = uVar3;\n                puVar16[0x12] = uVar4;\n                puVar16[0x13] = uVar9;\n                uVar2 = puVar14[0x18];\n                uVar3 = puVar14[0x19];\n                uVar4 = puVar14[0x1a];\n                uVar9 = puVar14[0x1b];\n                puVar16[0x14] = uVar5;\n                puVar16[0x15] = uVar6;\n                puVar16[0x16] = uVar7;\n                puVar16[0x17] = uVar8;\n                uVar5 = puVar14[0x1c];\n                uVar6 = puVar14[0x1d];\n                uVar7 = puVar14[0x1e];\n                uVar8 = puVar14[0x1f];\n                puVar16[0x18] = uVar2;\n                puVar16[0x19] = uVar3;\n                puVar16[0x1a] = uVar4;\n                puVar16[0x1b] = uVar9;\n                puVar16[0x1c] = uVar5;\n                puVar16[0x1d] = uVar6;\n                puVar16[0x1e] = uVar7;\n                puVar16[0x1f] = uVar8;\n                iVar18 = iVar18 + -1;\n                puVar15 = puVar14 + 0x20;\n                puVar10 = puVar16 + 0x20;\n            } while (iVar18 != 0);\n            uVar6 = puVar14[0x21];\n            uVar7 = puVar14[0x22];\n            uVar8 = puVar14[0x23];\n            uVar2 = puVar14[0x24];\n            uVar3 = puVar14[0x25];\n            uVar4 = puVar14[0x26];\n            uVar5 = puVar14[0x27];\n            puVar16[0x20] = puVar14[0x20];\n            puVar16[0x21] = uVar6;\n            puVar16[0x22] = uVar7;\n            puVar16[0x23] = uVar8;\n            uVar6 = puVar14[0x28];\n            uVar7 = puVar14[0x29];\n            uVar8 = puVar14[0x2a];\n            uVar9 = puVar14[0x2b];\n            puVar16[0x24] = uVar2;\n            puVar16[0x25] = uVar3;\n            puVar16[0x26] = uVar4;\n            puVar16[0x27] = uVar5;\n            puVar16[0x28] = uVar6;\n            puVar16[0x29] = uVar7;\n            puVar16[0x2a] = uVar8;\n            puVar16[0x2b] = uVar9;\n            *(&stack0xfffffffffffffff0 + iVar12) = 0x140005bce;\n            fcn.140005f00(&stack0x00000478 + iVar12, iVar17, &stack0x00000018 + iVar12);\n            *(&stack0xfffffffffffffff0 + iVar12) = 0x140005bde;\n            iVar11 = fcn.1400123f8(iVar13, &stack0x00000248 + iVar12);\n        }\n        *(&stack0xfffffffffffffff0 + iVar12) = 0x140005bee;\n        fcn.1400123c8(iVar13);\n    }\n    *(&stack0xfffffffffffffff0 + iVar12) = 0x140005bfb;\n    fcn.1400120a0(&stack0x00002488 + iVar12);\n    *(&stack0xfffffffffffffff0 + iVar12) = 0x140005c0b;\n    fcn.140009a80(*(&stack0x00004498 + iVar12) ^ &stack0xfffffffffffffff8 + iVar12);\n    return;\n}\n",
        "token_count": 3488
    },
    "140005f0": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.140005f00(int64_t param_1, int64_t param_2, uint *param_3)\n\n{\n    int16_t *piVar1;\n    int16_t iVar2;\n    uint uVar3;\n    uint uVar4;\n    uint uVar5;\n    uint uVar6;\n    uint uVar7;\n    uint uVar8;\n    uint uVar9;\n    uint uVar10;\n    uint *puVar11;\n    int32_t iVar12;\n    int64_t iVar13;\n    uint *puVar14;\n    int64_t iVar15;\n    uint *puVar16;\n    int64_t iVar17;\n    uint auStackX24 [4];\n    ulong uStack16;\n    \n    uStack16 = 0x140005f0c;\n    iVar13 = fcn.140009a10();\n    iVar13 = -iVar13;\n    *(&stack0x00001028 + iVar13) = *0x140037018 ^ &stack0xfffffffffffffff8 + iVar13;\n    iVar15 = 4;\n    puVar11 = &stack0x00000018 + iVar13;\n    do {\n        puVar16 = param_3;\n        puVar14 = puVar11;\n        uVar3 = puVar16[1];\n        uVar4 = puVar16[2];\n        uVar5 = puVar16[3];\n        uVar6 = puVar16[4];\n        uVar7 = puVar16[5];\n        uVar8 = puVar16[6];\n        uVar9 = puVar16[7];\n        *puVar14 = *puVar16;\n        puVar14[1] = uVar3;\n        puVar14[2] = uVar4;\n        puVar14[3] = uVar5;\n        uVar3 = puVar16[8];\n        uVar4 = puVar16[9];\n        uVar5 = puVar16[10];\n        uVar10 = puVar16[0xb];\n        puVar14[4] = uVar6;\n        puVar14[5] = uVar7;\n        puVar14[6] = uVar8;\n        puVar14[7] = uVar9;\n        uVar6 = puVar16[0xc];\n        uVar7 = puVar16[0xd];\n        uVar8 = puVar16[0xe];\n        uVar9 = puVar16[0xf];\n        puVar14[8] = uVar3;\n        puVar14[9] = uVar4;\n        puVar14[10] = uVar5;\n        puVar14[0xb] = uVar10;\n        uVar3 = puVar16[0x10];\n        uVar4 = puVar16[0x11];\n        uVar5 = puVar16[0x12];\n        uVar10 = puVar16[0x13];\n        puVar14[0xc] = uVar6;\n        puVar14[0xd] = uVar7;\n        puVar14[0xe] = uVar8;\n        puVar14[0xf] = uVar9;\n        uVar6 = puVar16[0x14];\n        uVar7 = puVar16[0x15];\n        uVar8 = puVar16[0x16];\n        uVar9 = puVar16[0x17];\n        puVar14[0x10] = uVar3;\n        puVar14[0x11] = uVar4;\n        puVar14[0x12] = uVar5;\n        puVar14[0x13] = uVar10;\n        uVar3 = puVar16[0x18];\n        uVar4 = puVar16[0x19];\n        uVar5 = puVar16[0x1a];\n        uVar10 = puVar16[0x1b];\n        puVar14[0x14] = uVar6;\n        puVar14[0x15] = uVar7;\n        puVar14[0x16] = uVar8;\n        puVar14[0x17] = uVar9;\n        uVar6 = puVar16[0x1c];\n        uVar7 = puVar16[0x1d];\n        uVar8 = puVar16[0x1e];\n        uVar9 = puVar16[0x1f];\n        puVar14[0x18] = uVar3;\n        puVar14[0x19] = uVar4;\n        puVar14[0x1a] = uVar5;\n        puVar14[0x1b] = uVar10;\n        puVar14[0x1c] = uVar6;\n        puVar14[0x1d] = uVar7;\n        puVar14[0x1e] = uVar8;\n        puVar14[0x1f] = uVar9;\n        iVar15 = iVar15 + -1;\n        puVar11 = puVar14 + 0x20;\n        param_3 = puVar16 + 0x20;\n    } while (iVar15 != 0);\n    uVar3 = puVar16[0x21];\n    uVar4 = puVar16[0x22];\n    uVar5 = puVar16[0x23];\n    uVar6 = puVar16[0x24];\n    uVar7 = puVar16[0x25];\n    uVar8 = puVar16[0x26];\n    uVar9 = puVar16[0x27];\n    puVar14[0x20] = puVar16[0x20];\n    puVar14[0x21] = uVar3;\n    puVar14[0x22] = uVar4;\n    puVar14[0x23] = uVar5;\n    uVar3 = puVar16[0x28];\n    uVar4 = puVar16[0x29];\n    uVar5 = puVar16[0x2a];\n    uVar10 = puVar16[0x2b];\n    puVar14[0x24] = uVar6;\n    puVar14[0x25] = uVar7;\n    puVar14[0x26] = uVar8;\n    puVar14[0x27] = uVar9;\n    puVar14[0x28] = uVar3;\n    puVar14[0x29] = uVar4;\n    puVar14[0x2a] = uVar5;\n    puVar14[0x2b] = uVar10;\n    if ((*(&stack0x0000003c + iVar13) != 0x2e) ||\n       ((*(&stack0x0000003e + iVar13) != 0 &&\n        ((*(&stack0x0000003e + iVar13) != 0x2e || (*(&stack0x00000040 + iVar13) != 0)))))) {\n        *(param_1 + param_2 * 2) = 0;\n        iVar15 = param_1 + -2;\n        do {\n            piVar1 = iVar15 + 2;\n            iVar15 = iVar15 + 2;\n        } while (*piVar1 != 0);\n        iVar17 = 0;\n        do {\n            iVar2 = *(&stack0x0000003c + iVar17 * 2 + iVar13);\n            *(iVar15 + iVar17 * 2) = iVar2;\n            iVar17 = iVar17 + 1;\n        } while (iVar2 != 0);\n        if (((&stack0x00000018)[iVar13] & 0x10) == 0) {\n            *(&stack0xfffffffffffffff0 + iVar13) = 0x140006041;\n            iVar12 = fcn.140012ed4(param_1);\n            if (iVar12 != 0) {\n                *(&stack0xfffffffffffffff0 + iVar13) = 0x140006050;\n                (*_sym.imp.KERNEL32.dll_Sleep)(100);\n                *(&stack0xfffffffffffffff0 + iVar13) = 0x140006058;\n                fcn.140012ed4(param_1);\n            }\n        }\n        else {\n            *(&stack0xfffffffffffffff0 + iVar13) = 0x14000602d;\n            fcn.1400069c0(&stack0x00000018 + iVar13, param_1, 0x1000);\n            *(&stack0xfffffffffffffff0 + iVar13) = 0x140006037;\n            fcn.140005990(&stack0x00000018 + iVar13);\n        }\n    }\n    *(&stack0xfffffffffffffff0 + iVar13) = 0x140006068;\n    fcn.140009a80(*(&stack0x00001028 + iVar13) ^ &stack0xfffffffffffffff8 + iVar13);\n    return;\n}\n",
        "token_count": 1947
    },
    "140006c3": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint32_t fcn.140006c30(uint8_t **arg1, ulong arg2)\n\n{\n    uint8_t uVar1;\n    ulong *puVar2;\n    char cVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint uVar6;\n    uint32_t uVar7;\n    uint32_t uVar8;\n    int32_t iVar9;\n    int64_t iVar10;\n    uint32_t uVar11;\n    uint32_t uVar12;\n    uint32_t uVar13;\n    uint8_t *arg2_00;\n    uint32_t uVar14;\n    uint16_t uVar15;\n    ushort uVar16;\n    int32_t iVar17;\n    uint8_t *puVar18;\n    uint64_t uVar19;\n    uint64_t uVar20;\n    uint32_t uStackX8;\n    int32_t iStackX24;\n    uint32_t uStackX32;\n    ushort uStack104;\n    uchar uStack102;\n    uchar uStack101;\n    uint uStack100;\n    uint32_t uStack96;\n    uint8_t *puStack88;\n    \n    if ((((((arg1 != NULL) && (arg1[6] != NULL)) && (arg1[7] != NULL)) &&\n         ((puVar2 = arg1[5],  puVar2 != NULL && (*puVar2 == arg1)))) && (iVar4 = *(puVar2 + 1),  iVar4 - 0x3f34U < 0x20)\n        ) && ((puVar18 = arg1[2],  puVar18 != NULL && ((arg2_00 = *arg1,  arg2_00 != NULL || (*(arg1 + 1) == 0)))))) {\n        if (iVar4 == 0x3f3f) {\n            *(puVar2 + 1) = 0x3f40;\n            iVar4 = 0x3f40;\n            puVar18 = arg1[2];\n            arg2_00 = *arg1;\n        }\n        uVar7 = *(arg1 + 3);\n        uVar14 = *(arg1 + 1);\n        uVar13 = *(puVar2 + 9);\n        uVar11 = *(puVar2 + 0x4c);\n        iStackX24 = 0;\n        uStackX8 = uVar7;\n        uStackX32 = uVar7;\n        uStack96 = uVar14;\n        puStack88 = puVar18;\n        while (iVar4 - 0x3f34U < 0x20) {\n            uVar20 = 0;\n            uVar5 = 0;\n    // switch table (32 cases) at 0x1400083dc\n            switch(*((iVar4 - 0x3f34U) * 4 + 0x1400083dc) + 0x140000000) {\n            case 0x140006d2d:\n                uVar5 = *(puVar2 + 2);\n                if (uVar5 == 0) {\n                    *(puVar2 + 1) = 0x3f40;\n                }\n                else {\n                    for (; uVar11 < 0x10; uVar11 = uVar11 + 8) {\n                        if (uVar14 == 0) goto code_r0x000140007576;\n                        uVar14 = uVar14 - 1;\n                        uVar13 = uVar13 + (*arg2_00 << (uVar11 & 0x1f));\n                        arg2_00 = arg2_00 + 1;\n                    }\n                    if (((uVar5 & 2) == 0) || (uVar13 != 0x8b1f)) {\n                        *(puVar2 + 3) = 0;\n                        if (puVar2[5] != 0) {\n                            *(puVar2[5] + 0x40) = 0xffffffff;\n                            uVar5 = *(puVar2 + 2);\n                        }\n                        if (((uVar5 & 1) == 0) ||\n                           (uVar5 = (uVar13 & 0xff) * 0x100 + (uVar13 >> 8), \n                           uVar5 != ((uVar5 - uVar5 / 0x1f >> 1) + uVar5 / 0x1f >> 4) * 0x1f)) {\n                            arg1[4] = \"incorrect header check\";\n                            *(puVar2 + 1) = 0x3f51;\n                        }\n                        else if ((uVar13 & 0xf) == 8) {\n                            uVar11 = uVar11 - 4;\n                            uVar8 = (uVar13 >> 4 & 0xf) + 8;\n                            uVar5 = *(puVar2 + 6);\n                            if (*(puVar2 + 6) == 0) {\n                                *(puVar2 + 6) = uVar8;\n                                uVar5 = uVar8;\n                            }\n                            if ((uVar8 < 0x10) && (uVar8 <= uVar5)) {\n                                *(puVar2 + 0x1c) = 1 << uVar8;\n                                uVar6 = fcn.140008890(0, 0, 0);\n                                uVar11 = 0;\n                                *(puVar2 + 4) = uVar6;\n                                *(arg1 + 0x4c) = uVar6;\n                                *(puVar2 + 1) = ~(uVar13 >> 0xc) & 2 | 0x3f3d;\n                                uVar13 = 0;\n                                puVar18 = puStack88;\n                                uVar7 = uStackX32;\n                            }\n                            else {\n                                arg1[4] = \"invalid window size\";\n                                *(puVar2 + 1) = 0x3f51;\n                                uVar13 = uVar13 >> 4;\n                            }\n                        }\n                        else {\n                            arg1[4] = \"unknown compression method\";\n                            *(puVar2 + 1) = 0x3f51;\n                        }\n                    }\n                    else {\n                        if (*(puVar2 + 6) == 0) {\n                            *(puVar2 + 6) = 0xf;\n                        }\n                        uVar6 = fcn.140008b80(0, 0, 0);\n                        *(puVar2 + 4) = uVar6;\n                        uStack104 = 0x8b1f;\n                        uVar6 = fcn.140008b80(*(puVar2 + 4), &uStack104, 2);\n                        *(puVar2 + 4) = uVar6;\n                        uVar13 = 0;\n                        uVar11 = 0;\n                        *(puVar2 + 1) = 0x3f35;\n                        puVar18 = puStack88;\n                        uVar7 = uStackX32;\n                    }\n                }\n                break;\n            case 0x140006ec4:\n                for (; uVar11 < 0x10; uVar11 = uVar11 + 8) {\n                    if (uVar14 == 0) goto code_r0x000140007576;\n                    uVar14 = uVar14 - 1;\n                    uVar13 = uVar13 + (*arg2_00 << (uVar11 & 0x1f));\n                    arg2_00 = arg2_00 + 1;\n                }\n                *(puVar2 + 3) = uVar13;\n                if (uVar13 == '\\b') {\n                    if ((uVar13 & 0xe000) == 0) {\n                        uVar7 = uVar13;\n                        if (puVar2[5] != NULL) {\n                            *puVar2[5] = uVar13 >> 8 & 1;\n                            uVar7 = *(puVar2 + 3);\n                        }\n                        if (((uVar7 >> 9 & 1) != 0) && ((*(puVar2 + 2) & 4) != 0)) {\n                            uStack104 = uVar13;\n                            uVar6 = fcn.140008b80(*(puVar2 + 4), &uStack104, 2);\n                            *(puVar2 + 4) = uVar6;\n                        }\n                        *(puVar2 + 1) = 0x3f36;\n                        uVar13 = uVar5;\n                        uVar11 = uVar5;\n                        do {\n                            if (uVar14 == 0) goto code_r0x000140007576;\n                            uVar14 = uVar14 - 1;\n                            uVar13 = uVar13 + (*arg2_00 << (uVar11 & 0x1f));\n                            arg2_00 = arg2_00 + 1;\n                            uVar11 = uVar11 + 8;\njoined_r0x000140006f8e:\n                        } while (uVar11 < 0x20);\n                        if (puVar2[5] != 0) {\n                            *(puVar2[5] + 4) = uVar13;\n                        }\n                        if (((*(puVar2 + 3) & 0x200) != 0) && ((*(puVar2 + 2) & 4) != 0)) {\n                            uStack104 = uVar13;\n                            uStack102 = uVar13 >> 0x10;\n                            uStack101 = uVar13 >> 0x18;\n                            uVar6 = fcn.140008b80(*(puVar2 + 4), &uStack104, 4);\n                            *(puVar2 + 4) = uVar6;\n                        }\n                        *(puVar2 + 1) = 0x3f37;\n                        uVar13 = uVar5;\n                        uVar11 = uVar5;\n                        do {\n                            if (uVar14 == 0) goto code_r0x000140007576;\n                            uVar14 = uVar14 - 1;\n                            uVar13 = uVar13 + (*arg2_00 << (uVar11 & 0x1f));\n                            arg2_00 = arg2_00 + 1;\n                            uVar11 = uVar11 + 8;\njoined_r0x000140007015:\n                        } while (uVar11 < 0x10);\n                        if (puVar2[5] != 0) {\n                            *(puVar2[5] + 8) = uVar13 & 0xff;\n                            *(puVar2[5] + 0xc) = uVar13 >> 8;\n                        }\n                        if (((*(puVar2 + 3) & 0x200) != 0) && ((*(puVar2 + 2) & 4) != 0)) {\n                            uStack104 = uVar13;\n                            uVar6 = fcn.140008b80(*(puVar2 + 4), &uStack104, 2);\n                            *(puVar2 + 4) = uVar6;\n                        }\n                        *(puVar2 + 1) = 0x3f38;\n                        uVar13 = uVar5;\n                        uVar11 = uVar5;\n                        goto code_r0x000140007098;\n                    }\n                    arg1[4] = \"unknown header flags set\";\n                    *(puVar2 + 1) = 0x3f51;\n                }\n                else {\n                    arg1[4] = \"unknown compression method\";\n                    *(puVar2 + 1) = 0x3f51;\n                }\n                break;\n            case 0x140006f8b:\n                goto joined_r0x000140006f8e;\n            case 0x140007012:\n                goto joined_r0x000140007015;\n            case 0x140007098:\ncode_r0x000140007098:\n                if ((*(puVar2 + 3) & 0x400) == 0) {\n                    uVar5 = uVar13;\n                    if (puVar2[5] != 0) {\n                        *(puVar2[5] + 0x10) = 0;\n                    }\n                }\n                else {\n                    for (; uVar11 < 0x10; uVar11 = uVar11 + 8) {\n                        if (uVar14 == 0) goto code_r0x000140007576;\n                        uVar14 = uVar14 - 1;\n                        uVar13 = uVar13 + (*arg2_00 << (uVar11 & 0x1f));\n                        arg2_00 = arg2_00 + 1;\n                    }\n                    *(puVar2 + 10) = uVar13;\n                    if (puVar2[5] != 0) {\n                        *(puVar2[5] + 0x18) = uVar13;\n                    }\n                    uVar11 = uVar5;\n                    if (((*(puVar2 + 3) & 0x200) != 0) && ((*(puVar2 + 2) & 4) != 0)) {\n                        uStack104 = uVar13;\n                        uVar6 = fcn.140008b80(*(puVar2 + 4), &uStack104, 2);\n                        *(puVar2 + 4) = uVar6;\n                    }\n                }\n                uVar13 = uVar5;\n                *(puVar2 + 1) = 0x3f39;\n            case 0x140007128:\n                uVar7 = *(puVar2 + 3);\n                if ((uVar7 >> 10 & 1) != 0) {\n                    uVar5 = *(puVar2 + 10);\n                    uVar8 = uVar14;\n                    if (uVar5 <= uVar14) {\n                        uVar8 = uVar5;\n                    }\n                    if (uVar8 != 0) {\n                        iVar10 = puVar2[5];\n                        if ((iVar10 != 0) && (*(iVar10 + 0x10) != 0)) {\n                            uVar5 = *(iVar10 + 0x18) - uVar5;\n                            uVar7 = uVar8;\n                            if (*(iVar10 + 0x1c) < uVar8 + uVar5) {\n                                uVar7 = *(iVar10 + 0x1c) - uVar5;\n                            }\n                            fcn.14000a790(uVar5 + *(iVar10 + 0x10), arg2_00, uVar7);\n                            uVar7 = *(puVar2 + 3);\n                        }\n                        if (((uVar7 >> 9 & 1) != 0) && ((*(puVar2 + 2) & 4) != 0)) {\n                            uVar6 = fcn.140008b80(*(puVar2 + 4), arg2_00, uVar8);\n                            *(puVar2 + 4) = uVar6;\n                        }\n                        uVar14 = uVar14 - uVar8;\n                        arg2_00 = arg2_00 + uVar8;\n                        *(puVar2 + 10) = *(puVar2 + 10) - uVar8;\n                        uVar5 = *(puVar2 + 10);\n                    }\n                    if (uVar5 != 0) goto code_r0x000140007576;\n                }\n                *(puVar2 + 10) = 0;\n                *(puVar2 + 1) = 0x3f3a;\ncode_r0x0001400071d2:\n                if ((*(puVar2 + 3) & 0x800) == 0) {\n                    if (puVar2[5] != 0) {\n                        *(puVar2[5] + 0x20) = 0;\n                    }\ncode_r0x000140007270:\n                    *(puVar2 + 10) = 0;\n                    *(puVar2 + 1) = 0x3f3b;\ncode_r0x00014000727c:\n                    uVar20 = 0;\n                    if ((*(puVar2 + 3) & 0x1000) == 0) {\n                        if (puVar2[5] != 0) {\n                            *(puVar2[5] + 0x30) = 0;\n                        }\ncode_r0x000140007311:\n                        *(puVar2 + 1) = 0x3f3c;\n                        uVar7 = uStackX32;\ncode_r0x000140007321:\n                        if ((*(puVar2 + 3) >> 9 & 1) != 0) {\n                            for (; uVar11 < 0x10; uVar11 = uVar11 + 8) {\n                                if (uVar14 == 0) goto code_r0x000140007576;\n                                uVar14 = uVar14 - 1;\n                                uVar13 = uVar13 + (*arg2_00 << (uVar11 & 0x1f));\n                                arg2_00 = arg2_00 + 1;\n                            }\n                            if (((*(puVar2 + 2) & 4) != 0) && (uVar13 != *(puVar2 + 4))) {\n                                arg1[4] = \"header crc mismatch\";\n                                *(puVar2 + 1) = 0x3f51;\n                                puVar18 = puStack88;\n                                break;\n                            }\n                            uVar13 = 0;\n                            uVar11 = uVar13;\n                        }\n                        if (puVar2[5] != 0) {\n                            *(puVar2[5] + 0x3c) = *(puVar2 + 3) >> 9 & 1;\n                            *(puVar2[5] + 0x40) = 1;\n                        }\n                        uVar6 = fcn.140008b80(0, 0, 0);\n                        *(puVar2 + 4) = uVar6;\n                        *(arg1 + 0x4c) = uVar6;\ncode_r0x0001400073ac:\n                        *(puVar2 + 1) = 0x3f3f;\n                        puVar18 = puStack88;\n                        uVar7 = uStackX32;\n                        break;\n                    }\n                    if (uVar14 != 0) {\n                        do {\n                            uVar7 = uVar20 + 1;\n                            uVar19 = uVar7;\n                            uVar1 = arg2_00[uVar20];\n                            iVar10 = puVar2[5];\n                            if (((iVar10 != 0) && (*(iVar10 + 0x30) != 0)) && (*(puVar2 + 10) < *(iVar10 + 0x38))) {\n                                *(*(puVar2 + 10) + *(iVar10 + 0x30)) = uVar1;\n                                *(puVar2 + 10) = *(puVar2 + 10) + 1;\n                            }\n                        } while ((uVar1 != 0) && (uVar20 = uVar19,  uVar7 < uVar14));\n                        if (((*(puVar2 + 3) & 0x200) != 0) && ((*(puVar2 + 2) & 4) != 0)) {\n                            uVar6 = fcn.140008b80(*(puVar2 + 4), arg2_00, uVar19);\n                            *(puVar2 + 4) = uVar6;\n                        }\n                        uVar14 = uVar14 - uVar7;\n                        arg2_00 = arg2_00 + uVar19;\n                        if (uVar1 == 0) goto code_r0x000140007311;\n                    }\n                }\n                else if (uVar14 != 0) {\n                    do {\n                        uVar7 = uVar20 + 1;\n                        uVar19 = uVar7;\n                        uVar1 = arg2_00[uVar20];\n                        iVar10 = puVar2[5];\n                        if (((iVar10 != 0) && (*(iVar10 + 0x20) != 0)) && (*(puVar2 + 10) < *(iVar10 + 0x28))) {\n                            *(*(puVar2 + 10) + *(iVar10 + 0x20)) = uVar1;\n                            *(puVar2 + 10) = *(puVar2 + 10) + 1;\n                        }\n                    } while ((uVar1 != 0) && (uVar20 = uVar19,  uVar7 < uVar14));\n                    if (((*(puVar2 + 3) & 0x200) != 0) && ((*(puVar2 + 2) & 4) != 0)) {\n                        uVar6 = fcn.140008b80(*(puVar2 + 4), arg2_00, uVar19);\n                        *(puVar2 + 4) = uVar6;\n                    }\n                    uVar14 = uVar14 - uVar7;\n                    arg2_00 = arg2_00 + uVar19;\n                    if (uVar1 == 0) goto code_r0x000140007270;\n                }\n                goto code_r0x000140007576;\n            case 0x1400071d2:\n                goto code_r0x0001400071d2;\n            case 0x14000727c:\n                goto code_r0x00014000727c;\n            case 0x140007321:\n                goto code_r0x000140007321;\n            case 0x1400073ec:\n                for (; uVar11 < 0x20; uVar11 = uVar11 + 8) {\n                    if (uVar14 == 0) goto code_r0x000140007576;\n                    uVar14 = uVar14 - 1;\n                    uVar13 = uVar13 + (*arg2_00 << (uVar11 & 0x1f));\n                    arg2_00 = arg2_00 + 1;\n                }\n                iVar4 = (uVar13 >> 8 & 0xff00) + ((uVar13 & 0xff00) + uVar13 * 0x10000) * 0x100 + (uVar13 >> 0x18);\n                *(puVar2 + 4) = iVar4;\n                *(arg1 + 0x4c) = iVar4;\n                *(puVar2 + 1) = 0x3f3e;\n                uVar13 = uVar5;\n                uVar11 = uVar5;\n            case 0x140007449:\n                if (*(puVar2 + 0x14) == 0) {\n                    arg1[2] = puVar18;\n                    *(arg1 + 3) = uVar7;\n                    *arg1 = arg2_00;\n                    *(arg1 + 1) = uVar14;\n                    *(puVar2 + 9) = uVar13;\n                    *(puVar2 + 0x4c) = uVar11;\n                    return 2;\n                }\n                uVar6 = fcn.140008890(0, 0, 0);\n                *(puVar2 + 4) = uVar6;\n                *(arg1 + 0x4c) = uVar6;\n                *(puVar2 + 1) = 0x3f3f;\n                uVar7 = uStackX32;\ncode_r0x000140007479:\n                if (arg2 - 5U < 2) goto code_r0x000140007576;\ncode_r0x000140007486:\n                puVar18 = puStack88;\n                if (*(puVar2 + 0xc) == 0) {\n                    for (; uVar11 < 3; uVar11 = uVar11 + 8) {\n                        if (uVar14 == 0) goto code_r0x000140007576;\n                        uVar14 = uVar14 - 1;\n                        uVar13 = uVar13 + (*arg2_00 << (uVar11 & 0x1f));\n                        arg2_00 = arg2_00 + 1;\n                    }\n                    *(puVar2 + 0xc) = uVar13 & 1;\n                    uVar5 = uVar13 >> 1 & 3;\n                    if (uVar5 == 0) {\n                        *(puVar2 + 1) = 0x3f41;\n                    }\n                    else {\n                        if (uVar5 != 1) {\n                            if (uVar5 == 2) {\n                                uVar13 = uVar13 >> 3;\n                                uVar11 = uVar11 - 3;\n                                *(puVar2 + 1) = 0x3f44;\n                            }\n                            else {\n                                if (uVar5 != 3) goto code_r0x000140007605;\n                                uVar13 = uVar13 >> 3;\n                                arg1[4] = \"invalid block type\";\n                                uVar11 = uVar11 - 3;\n                                *(puVar2 + 1) = 0x3f51;\n                            }\n                            break;\n                        }\n                        *(puVar2 + 0xe) = 9;\n                        puVar2[0xc] = 0x140027c40;\n                        puVar2[0xd] = 0x140028440;\n                        *(puVar2 + 0x74) = 5;\n                        *(puVar2 + 1) = 0x3f47;\n                        if (arg2 == 6) {\n                            uVar13 = uVar13 >> 3;\n                            uVar11 = uVar11 - 3;\n                            goto code_r0x000140007576;\n                        }\n                    }\ncode_r0x000140007605:\n                    uVar13 = uVar13 >> 3;\n                    uVar11 = uVar11 - 3;\n                }\n                else {\n                    *(puVar2 + 1) = 0x3f4e;\n                    uVar13 = uVar13 >> (uVar11 & 7);\n                    uVar11 = uVar11 - (uVar11 & 7);\n                }\n                break;\n            case 0x140007479:\n                goto code_r0x000140007479;\n            case 0x140007486:\n                goto code_r0x000140007486;\n            case 0x1400075f3:\n                goto code_r0x0001400083ca;\n            case 0x140007610:\n                uVar13 = uVar13 >> (uVar11 & 7);\n                for (uVar11 = uVar11 - (uVar11 & 7); uVar11 < 0x20; uVar11 = uVar11 + 8) {\n                    if (uVar14 == 0) goto code_r0x000140007576;\n                    uVar14 = uVar14 - 1;\n                    uVar13 = uVar13 + (*arg2_00 << (uVar11 & 0x1f));\n                    arg2_00 = arg2_00 + 1;\n                }\n                if ((uVar13 & 0xffff) == ~uVar13 >> 0x10) {\n                    *(puVar2 + 10) = uVar13 & 0xffff;\n                    *(puVar2 + 1) = 0x3f42;\n                    uVar13 = uVar5;\n                    uVar11 = uVar5;\n                    if (arg2 != 6) goto code_r0x000140007681;\n                    goto code_r0x000140007576;\n                }\n                arg1[4] = \"invalid stored block lengths\";\n                *(puVar2 + 1) = 0x3f51;\n                break;\n            case 0x140007681:\ncode_r0x000140007681:\n                *(puVar2 + 1) = 0x3f43;\n            case 0x140007689:\n                uVar5 = *(puVar2 + 10);\n                if (uVar5 == 0) {\n                    *(puVar2 + 1) = 0x3f3f;\n                }\n                else {\n                    uVar8 = uVar14;\n                    if (uVar5 <= uVar14) {\n                        uVar8 = uVar5;\n                    }\n                    if (uVar8 <= uVar7) {\n                        uVar7 = uVar8;\n                    }\n                    if (uVar7 == 0) goto code_r0x000140007576;\n                    fcn.14000a790(puVar18, arg2_00, uVar7);\n                    uVar14 = uVar14 - uVar7;\n                    uStackX32 = uStackX32 - uVar7;\n                    puStack88 = puStack88 + uVar7;\n                    arg2_00 = arg2_00 + uVar7;\n                    *(puVar2 + 10) = *(puVar2 + 10) - uVar7;\n                    puVar18 = puStack88;\n                    uVar7 = uStackX32;\n                }\n                break;\n            case 0x1400076f8:\n                for (; uVar11 < 0xe; uVar11 = uVar11 + 8) {\n                    if (uVar14 == 0) goto code_r0x000140007576;\n                    uVar14 = uVar14 - 1;\n                    uVar13 = uVar13 + (*arg2_00 << (uVar11 & 0x1f));\n                    arg2_00 = arg2_00 + 1;\n                }\n                uVar11 = uVar11 - 0xe;\n                uVar8 = uVar13 >> 5;\n                uVar5 = (uVar13 & 0x1f) + 0x101;\n                uVar12 = uVar13 >> 10;\n                *(puVar2 + 0x7c) = uVar5;\n                uVar13 = uVar13 >> 0xe;\n                uVar8 = (uVar8 & 0x1f) + 1;\n                *(puVar2 + 0x10) = uVar8;\n                *(puVar2 + 0xf) = (uVar12 & 0xf) + 4;\n                if ((uVar5 < 0x11f) && (uVar8 < 0x1f)) {\n                    *(puVar2 + 0x84) = 0;\n                    *(puVar2 + 1) = 0x3f45;\n                    goto code_r0x000140007777;\n                }\n                arg1[4] = \"too many length or distance symbols\";\n                *(puVar2 + 1) = 0x3f51;\n                break;\n            case 0x140007777:\ncode_r0x000140007777:\n                uVar7 = *(puVar2 + 0x84);\n                if (uVar7 < *(puVar2 + 0xf)) {\n                    do {\n                        for (; uVar11 < 3; uVar11 = uVar11 + 8) {\n                            if (uVar14 == 0) goto code_r0x000140007576;\n                            uVar14 = uVar14 - 1;\n                            uVar13 = uVar13 + (*arg2_00 << (uVar11 & 0x1f));\n                            arg2_00 = arg2_00 + 1;\n                        }\n                        uVar15 = uVar13;\n                        uVar13 = uVar13 >> 3;\n                        uVar11 = uVar11 - 3;\n                        *(puVar2 + *(*(puVar2 + 0x84) * 2 + 0x1400284c0) * 2 + 0x90) = uVar15 & 7;\n                        *(puVar2 + 0x84) = *(puVar2 + 0x84) + 1;\n                        uVar7 = *(puVar2 + 0x84);\n                    } while (uVar7 < *(puVar2 + 0xf));\n                }\n                while (uVar7 < 0x13) {\n                    *(puVar2 + *(*(puVar2 + 0x84) * 2 + 0x1400284c0) * 2 + 0x90) = 0;\n                    *(puVar2 + 0x84) = *(puVar2 + 0x84) + 1;\n                    uVar7 = *(puVar2 + 0x84);\n                }\n                *(puVar2 + 0xe) = 7;\n                puVar2[0xc] = puVar2 + 0xaa;\n                puVar2[0x11] = puVar2 + 0xaa;\n                iStackX24 = fcn.140008ec0(0, puVar2 + 0x12, 0x13, puVar2 + 0x11);\n                if (iStackX24 == 0) {\n                    *(puVar2 + 0x84) = 0;\n                    iVar4 = 0x3f46;\n                    *(puVar2 + 1) = 0x3f46;\n                    goto code_r0x0001400078ad;\n                }\n                arg1[4] = \"invalid code lengths set\";\n                *(puVar2 + 1) = 0x3f51;\n                puVar18 = puStack88;\n                uVar7 = uStackX32;\n                break;\n            case 0x1400078ad:\ncode_r0x0001400078ad:\n                uVar5 = *(puVar2 + 0x7c);\n                puVar18 = puStack88;\n                if (*(puVar2 + 0x84) < *(puVar2 + 0x10) + uVar5) {\n                    do {\n                        uVar5 = (1 << (*(puVar2 + 0xe) & 0x1f)) - 1;\n                        uStack100 = *(puVar2[0xc] + (uVar5 & uVar13) * 4);\n                        uVar7 = uStack100 >> 8;\n                        uVar15 = uStack100 >> 0x10;\n                        if (uVar11 < (uVar7 & 0xff)) {\n                            do {\n                                if (uVar14 == 0) goto code_r0x000140007576;\n                                uVar14 = uVar14 - 1;\n                                uVar13 = uVar13 + (*arg2_00 << (uVar11 & 0x1f));\n                                arg2_00 = arg2_00 + 1;\n                                uVar11 = uVar11 + 8;\n                                uStack100 = *(puVar2[0xc] + (uVar5 & uVar13) * 4);\n                                uVar7 = uStack100 >> 8;\n                                uVar15 = uStack100 >> 0x10;\n                            } while (uVar11 < (uVar7 & 0xff));\n                        }\n                        if (0xf < uVar15) {\n                            uVar7 = uVar7 & 0xff;\n                            uStack100._1_1_ = uStack100 >> 8;\n                            if (uVar15 == 0x10) {\n                                for (; uVar11 < uVar7 + 2; uVar11 = uVar11 + 8) {\n                                    if (uVar14 == 0) goto code_r0x000140007576;\n                                    uVar14 = uVar14 - 1;\n                                    uVar13 = uVar13 + (*arg2_00 << (uVar11 & 0x1f));\n                                    arg2_00 = arg2_00 + 1;\n                                }\n                                uVar11 = uVar11 - uStack100._1_1_;\n                                uVar13 = uVar13 >> (uStack100._1_1_ & 0x1f);\n                                if (*(puVar2 + 0x84) != 0) {\n                                    uVar11 = uVar11 - 2;\n                                    uVar7 = uVar13 & 3;\n                                    uVar13 = uVar13 >> 2;\n                                    iVar9 = uVar7 + 3;\n                                    uVar16 = *(puVar2 + (*(puVar2 + 0x84) - 1) * 2 + 0x90);\n                                    goto code_r0x000140007a63;\n                                }\n                            }\n                            else {\n                                if (uVar15 == 0x11) {\n                                    for (; uVar11 < uVar7 + 3; uVar11 = uVar11 + 8) {\n                                        if (uVar14 == 0) goto code_r0x000140007576;\n                                        uVar14 = uVar14 - 1;\n                                        uVar13 = uVar13 + (*arg2_00 << (uVar11 & 0x1f));\n                                        arg2_00 = arg2_00 + 1;\n                                    }\n                                    iVar4 = -3;\n                                    uVar13 = uVar13 >> (uStack100._1_1_ & 0x1f);\n                                    iVar9 = (uVar13 & 7) + 3;\n                                    uVar13 = uVar13 >> 3;\n                                }\n                                else {\n                                    for (; uVar11 < uVar7 + 7; uVar11 = uVar11 + 8) {\n                                        if (uVar14 == 0) goto code_r0x000140007576;\n                                        uVar14 = uVar14 - 1;\n                                        uVar13 = uVar13 + (*arg2_00 << (uVar11 & 0x1f));\n                                        arg2_00 = arg2_00 + 1;\n                                    }\n                                    iVar4 = -7;\n                                    uVar13 = uVar13 >> (uStack100._1_1_ & 0x1f);\n                                    iVar9 = (uVar13 & 0x7f) + 0xb;\n                                    uVar13 = uVar13 >> 7;\n                                }\n                                uVar16 = 0;\n                                uVar11 = uVar11 + (iVar4 - uStack100._1_1_);\ncode_r0x000140007a63:\n                                if (*(puVar2 + 0x84) + iVar9 <= *(puVar2 + 0x10) + *(puVar2 + 0x7c)) {\n                                    do {\n                                        *(puVar2 + *(puVar2 + 0x84) * 2 + 0x90) = uVar16;\n                                        uVar7 = *(puVar2 + 0x84) + 1;\n                                        *(puVar2 + 0x84) = uVar7;\n                                        iVar9 = iVar9 + -1;\n                                    } while (iVar9 != 0);\n                                    goto code_r0x000140007aa7;\n                                }\n                            }\n                            arg1[4] = \"invalid bit length repeat\";\n                            *(puVar2 + 1) = 0x3f51;\n                            uVar7 = uStackX32;\n                            goto code_r0x0001400073c1;\n                        }\n                        uVar13 = uVar13 >> (uVar7 & 0x1f);\n                        uVar11 = uVar11 - (uVar7 & 0xff);\n                        *(puVar2 + *(puVar2 + 0x84) * 2 + 0x90) = uStack100 >> 0x10;\n                        *(puVar2 + 0x84) = *(puVar2 + 0x84) + 1;\n                        uVar7 = *(puVar2 + 0x84);\ncode_r0x000140007aa7:\n                        uVar5 = *(puVar2 + 0x7c);\n                    } while (uVar7 < *(puVar2 + 0x10) + uVar5);\n                    iVar4 = *(puVar2 + 1);\n                }\n                uVar7 = uStackX32;\n                if (iVar4 != 0x3f51) {\n                    if (*(puVar2 + 0x52) == 0) {\n                        arg1[4] = \"invalid code -- missing end-of-block\";\n                        *(puVar2 + 1) = 0x3f51;\n                    }\n                    else {\n                        *(puVar2 + 0xe) = 9;\n                        puVar2[0x11] = puVar2 + 0xaa;\n                        puVar2[0xc] = puVar2 + 0xaa;\n                        iStackX24 = fcn.140008ec0(1, puVar2 + 0x12, uVar5, puVar2 + 0x11);\n                        if (iStackX24 == 0) {\n                            puVar2[0xd] = puVar2[0x11];\n                            *(puVar2 + 0x74) = 6;\n                            iStackX24 = fcn.140008ec0(2, *(puVar2 + 0x7c) * 2 + 0x90 + puVar2, *(puVar2 + 0x10), \n                                                      puVar2 + 0x11);\n                            if (iStackX24 == 0) {\n                                *(puVar2 + 1) = 0x3f47;\n                                if (arg2 != 6) goto code_r0x000140007c11;\n                                goto code_r0x000140007576;\n                            }\n                            arg1[4] = \"invalid distances set\";\n                            *(puVar2 + 1) = 0x3f51;\n                            puVar18 = puStack88;\n                        }\n                        else {\n                            arg1[4] = \"invalid literal/lengths set\";\n                            *(puVar2 + 1) = 0x3f51;\n                            puVar18 = puStack88;\n                        }\n                    }\n                }\n                break;\n            case 0x140007c11:\ncode_r0x000140007c11:\n                *(puVar2 + 1) = 0x3f48;\n            case 0x140007c19:\n                if ((5 < uVar14) && (0x101 < uVar7)) {\n                    arg1[2] = puStack88;\n                    *(arg1 + 3) = uVar7;\n                    *arg1 = arg2_00;\n                    *(arg1 + 1) = uVar14;\n                    *(puVar2 + 9) = uVar13;\n                    *(puVar2 + 0x4c) = uVar11;\n                    fcn.140009480(arg1, uStackX8);\n                    puStack88 = arg1[2];\n                    uStackX32 = *(arg1 + 3);\n                    arg2_00 = *arg1;\n                    uVar14 = *(arg1 + 1);\n                    uVar11 = *(puVar2 + 0x4c);\n                    puVar18 = puStack88;\n                    uVar7 = uStackX32;\n                    uVar13 = *(puVar2 + 9);\n                    if (*(puVar2 + 1) == 0x3f3f) {\n                        *(puVar2 + 0x1be4) = 0xffffffff;\n                    }\n                    break;\n                }\n                iVar10 = puVar2[0xc];\n                uVar5 = (1 << (*(puVar2 + 0xe) & 0x1f)) - 1;\n                *(puVar2 + 0x1be4) = 0;\n                uVar7 = *(iVar10 + (uVar5 & uVar13) * 4);\n                if (uVar11 < (uVar7 >> 8 & 0xff)) {\n                    do {\n                        if (uVar14 == 0) goto code_r0x000140007576;\n                        uVar14 = uVar14 - 1;\n                        uVar13 = uVar13 + (*arg2_00 << (uVar11 & 0x1f));\n                        arg2_00 = arg2_00 + 1;\n                        uVar11 = uVar11 + 8;\n                        uVar7 = *(iVar10 + (uVar5 & uVar13) * 4);\n                    } while (uVar11 < (uVar7 >> 8 & 0xff));\n                }\n                cVar3 = uVar7;\n                uVar5 = uVar7;\n                if ((cVar3 != '\\0') && ((uVar7 & 0xf0) == 0)) {\n                    uStack100._1_1_ = uVar7 >> 8;\n                    uVar12 = uStack100._1_1_;\n                    uVar8 = uVar7 >> 8 & 0xff;\n                    uVar1 = uVar8;\n                    uVar5 = *(iVar10 + ((((1 << (cVar3 + uVar1 & 0x1f)) - 1U & uVar13) >> (uVar1 & 0x1f)) +\n                                       (uVar7 >> 0x10)) * 4);\n                    uStack100 = uVar7;\n                    if (uVar11 < (uVar5 >> 8 & 0xff) + uVar8) {\n                        do {\n                            if (uVar14 == 0) goto code_r0x000140007576;\n                            uVar13 = uVar13 + (*arg2_00 << (uVar11 & 0x1f));\n                            uVar14 = uVar14 - 1;\n                            arg2_00 = arg2_00 + 1;\n                            uVar11 = uVar11 + 8;\n                            uVar5 = *(iVar10 + ((((1 << (cVar3 + uStack100._1_1_ & 0x1f)) - 1U & uVar13) >>\n                                                (uStack100._1_1_ & 0x1f)) + (uVar7 >> 0x10)) * 4);\n                        } while (uVar11 < (uVar5 >> 8 & 0xff) + uVar12);\n                    }\n                    uVar13 = uVar13 >> (uStack100._1_1_ & 0x1f);\n                    uVar11 = uVar11 - uVar12;\n                    *(puVar2 + 0x1be4) = uVar12;\n                }\n                uVar7 = uVar5 >> 8 & 0xff;\n                *(puVar2 + 0x1be4) = *(puVar2 + 0x1be4) + uVar7;\n                uVar11 = uVar11 - uVar7;\n                uVar13 = uVar13 >> (uVar7 & 0x1f);\n                *(puVar2 + 10) = uVar5 >> 0x10;\n                puVar18 = puStack88;\n                if (uVar5 == '\\0') {\n                    *(puVar2 + 1) = 0x3f4d;\n                    uVar7 = uStackX32;\n                    break;\n                }\n                if ((uVar5 & 0x20) == 0) {\n                    if ((uVar5 & 0x40) == 0) {\n                        *(puVar2 + 1) = 0x3f49;\n                        *(puVar2 + 0xb) = uVar5 & 0xf;\ncode_r0x000140007e23:\n                        uVar7 = *(puVar2 + 0xb);\n                        if (uVar7 != 0) {\n                            for (; uVar11 < uVar7; uVar11 = uVar11 + 8) {\n                                if (uVar14 == 0) goto code_r0x000140007576;\n                                uVar14 = uVar14 - 1;\n                                uVar13 = uVar13 + (*arg2_00 << (uVar11 & 0x1f));\n                                arg2_00 = arg2_00 + 1;\n                            }\n                            uVar11 = uVar11 - uVar7;\n                            uVar5 = (1 << (uVar7 & 0x1f)) - 1U & uVar13;\n                            uVar13 = uVar13 >> (uVar7 & 0x1f);\n                            *(puVar2 + 10) = *(puVar2 + 10) + uVar5;\n                            *(puVar2 + 0x1be4) = *(puVar2 + 0x1be4) + uVar7;\n                        }\n                        *(puVar2 + 0x37d) = *(puVar2 + 10);\n                        *(puVar2 + 1) = 0x3f4a;\ncode_r0x000140007e7c:\n                        iVar10 = puVar2[0xd];\n                        uVar5 = (1 << (*(puVar2 + 0x74) & 0x1f)) - 1;\n                        uVar7 = *(iVar10 + (uVar5 & uVar13) * 4);\n                        if (uVar11 < (uVar7 >> 8 & 0xff)) {\n                            do {\n                                if (uVar14 == 0) goto code_r0x000140007576;\n                                uVar14 = uVar14 - 1;\n                                uVar13 = uVar13 + (*arg2_00 << (uVar11 & 0x1f));\n                                arg2_00 = arg2_00 + 1;\n                                uVar11 = uVar11 + 8;\n                                uVar7 = *(iVar10 + (uVar5 & uVar13) * 4);\n                            } while (uVar11 < (uVar7 >> 8 & 0xff));\n                        }\n                        uVar5 = uVar7;\n                        if ((uVar7 & 0xf0) == 0) {\n                            uStack100._1_1_ = uVar7 >> 8;\n                            uVar12 = uStack100._1_1_;\n                            uVar8 = uVar7 >> 8 & 0xff;\n                            uVar1 = uVar8;\n                            uVar5 = *(iVar10 + ((((1 << (uVar7 + uVar1 & 0x1f)) - 1U & uVar13) >> (uVar1 & 0x1f)) +\n                                               (uVar7 >> 0x10)) * 4);\n                            uStack100 = uVar7;\n                            if (uVar11 < (uVar5 >> 8 & 0xff) + uVar8) {\n                                do {\n                                    if (uVar14 == 0) goto code_r0x000140007576;\n                                    uVar13 = uVar13 + (*arg2_00 << (uVar11 & 0x1f));\n                                    uVar14 = uVar14 - 1;\n                                    arg2_00 = arg2_00 + 1;\n                                    uVar11 = uVar11 + 8;\n                                    uVar5 = *(iVar10 + ((((1 << (uVar7 + uStack100._1_1_ & 0x1f)) - 1U & uVar13) >>\n                                                        (uStack100._1_1_ & 0x1f)) + (uVar7 >> 0x10)) * 4);\n                                } while (uVar11 < (uVar5 >> 8 & 0xff) + uVar12);\n                            }\n                            uVar11 = uVar11 - uVar12;\n                            uVar13 = uVar13 >> (uStack100._1_1_ & 0x1f);\n                            *(puVar2 + 0x1be4) = *(puVar2 + 0x1be4) + uVar12;\n                        }\n                        uVar7 = uVar5 >> 8 & 0xff;\n                        *(puVar2 + 0x1be4) = *(puVar2 + 0x1be4) + uVar7;\n                        uVar11 = uVar11 - uVar7;\n                        uVar13 = uVar13 >> (uVar7 & 0x1f);\n                        if ((uVar5 & 0x40) == 0) {\n                            *(puVar2 + 0x54) = uVar5 >> 0x10;\n                            *(puVar2 + 1) = 0x3f4b;\n                            *(puVar2 + 0xb) = uVar5 & 0xf;\n                            uVar7 = uStackX32;\ncode_r0x000140007fe6:\n                            uVar5 = *(puVar2 + 0xb);\n                            if (uVar5 != 0) {\n                                for (; uVar11 < uVar5; uVar11 = uVar11 + 8) {\n                                    if (uVar14 == 0) goto code_r0x000140007576;\n                                    uVar14 = uVar14 - 1;\n                                    uVar13 = uVar13 + (*arg2_00 << (uVar11 & 0x1f));\n                                    arg2_00 = arg2_00 + 1;\n                                }\n                                uVar11 = uVar11 - uVar5;\n                                uVar8 = (1 << (uVar5 & 0x1f)) - 1U & uVar13;\n                                uVar13 = uVar13 >> (uVar5 & 0x1f);\n                                *(puVar2 + 0x54) = *(puVar2 + 0x54) + uVar8;\n                                *(puVar2 + 0x1be4) = *(puVar2 + 0x1be4) + uVar5;\n                            }\n                            *(puVar2 + 1) = 0x3f4c;\ncode_r0x000140008033:\n                            if (uVar7 == 0) goto code_r0x000140007576;\n                            uVar5 = *(puVar2 + 0x54);\n                            if (uStackX8 - uVar7 < uVar5) {\n                                uVar5 = uVar5 - (uStackX8 - uVar7);\n                                if ((*(puVar2 + 7) <= uVar5 && uVar5 != *(puVar2 + 7)) && (*(puVar2 + 0x37c) != 0)) {\n                                    arg1[4] = \"invalid distance too far back\";\n                                    *(puVar2 + 1) = 0x3f51;\n                                    puVar18 = puStack88;\n                                    break;\n                                }\n                                uVar12 = *(puVar2 + 0x3c);\n                                if (uVar12 < uVar5) {\n                                    uVar5 = uVar5 - uVar12;\n                                    uVar12 = *(puVar2 + 0x34);\n                                }\n                                uVar8 = *(puVar2 + 10);\n                                iVar10 = (uVar12 - uVar5) + puVar2[8];\n                                uVar12 = uVar8;\n                                if (uVar5 <= uVar8) {\n                                    uVar12 = uVar5;\n                                }\n                            }\n                            else {\n                                uVar8 = *(puVar2 + 10);\n                                iVar10 = puStack88 - uVar5;\n                                uVar12 = uVar8;\n                            }\n                            uVar5 = uVar7;\n                            if (uVar12 <= uVar7) {\n                                uVar5 = uVar12;\n                            }\n                            uStackX32 = uVar7 - uVar5;\n                            iVar10 = iVar10 - puStack88;\n                            *(puVar2 + 10) = uVar8 - uVar5;\n                            do {\n                                *puStack88 = puStack88[iVar10];\n                                puStack88 = puStack88 + 1;\n                                uVar5 = uVar5 - 1;\n                            } while (uVar5 != 0);\n                            puVar18 = puStack88;\n                            uVar7 = uStackX32;\n                            if (*(puVar2 + 10) == 0) {\n                                *(puVar2 + 1) = 0x3f48;\n                            }\n                        }\n                        else {\n                            arg1[4] = \"invalid distance code\";\n                            *(puVar2 + 1) = 0x3f51;\n                            puVar18 = puStack88;\n                            uVar7 = uStackX32;\n                        }\n                    }\n                    else {\n                        arg1[4] = \"invalid literal/length code\";\n                        *(puVar2 + 1) = 0x3f51;\n                        uVar7 = uStackX32;\n                    }\n                    break;\n                }\n                *(puVar2 + 0x1be4) = 0xffffffff;\n                goto code_r0x0001400073ac;\n            case 0x140007e23:\n                goto code_r0x000140007e23;\n            case 0x140007e7c:\n                goto code_r0x000140007e7c;\n            case 0x140007fe6:\n                goto code_r0x000140007fe6;\n            case 0x140008033:\n                goto code_r0x000140008033;\n            case 0x1400080fc:\n                if (uVar7 == 0) goto code_r0x000140007576;\n                *puVar18 = *(puVar2 + 10);\n                puStack88 = puVar18 + 1;\n                uStackX32 = uVar7 - 1;\n                *(puVar2 + 1) = 0x3f48;\n                puVar18 = puStack88;\n                uVar7 = uStackX32;\n                break;\n            case 0x14000812d:\n                if (*(puVar2 + 2) == 0) {\n                    *(puVar2 + 1) = 0x3f4f;\n                }\n                else {\n                    for (; uVar11 < 0x20; uVar11 = uVar11 + 8) {\n                        if (uVar14 == 0) goto code_r0x000140007576;\n                        uVar14 = uVar14 - 1;\n                        uVar13 = uVar13 + (*arg2_00 << (uVar11 & 0x1f));\n                        arg2_00 = arg2_00 + 1;\n                    }\n                    uStackX8 = uStackX8 - uVar7;\n                    *(arg1 + 0x1c) = *(arg1 + 0x1c) + uStackX8;\n                    *(puVar2 + 0x24) = *(puVar2 + 0x24) + uStackX8;\n                    uVar8 = *(puVar2 + 2);\n                    if (((uVar8 & 4) != 0) && (uStackX8 != 0)) {\n                        if (*(puVar2 + 3) == 0) {\n                            uVar6 = fcn.140008890(*(puVar2 + 4), puVar18 - uStackX8, uStackX8);\n                        }\n                        else {\n                            uVar6 = fcn.140008b80(*(puVar2 + 4), puVar18 - uStackX8, uStackX8);\n                        }\n                        *(puVar2 + 4) = uVar6;\n                        *(arg1 + 0x4c) = uVar6;\n                        uVar8 = *(puVar2 + 2);\n                        uVar7 = uStackX32;\n                    }\n                    uStackX8 = uVar7;\n                    if ((uVar8 & 4) != 0) {\n                        uVar8 = uVar13;\n                        if (*(puVar2 + 3) == 0) {\n                            uVar8 = ((uVar13 & 0xff00) + uVar13 * 0x10000) * 0x100 + (uVar13 >> 8 & 0xff00) +\n                                    (uVar13 >> 0x18);\n                        }\n                        if (uVar8 != *(puVar2 + 4)) {\n                            arg1[4] = \"incorrect data check\";\n                            *(puVar2 + 1) = 0x3f51;\n                            puVar18 = puStack88;\n                            break;\n                        }\n                    }\n                    *(puVar2 + 1) = 0x3f4f;\n                    uVar13 = uVar5;\n                    uVar11 = uVar5;\n                }\n                goto code_r0x000140008230;\n            case 0x140008228:\ncode_r0x000140008230:\n                uVar8 = uVar13;\n                uVar12 = uVar11;\n                if ((*(puVar2 + 2) != 0) && (*(puVar2 + 3) != 0)) {\n                    for (; uVar11 < 0x20; uVar11 = uVar11 + 8) {\n                        if (uVar14 == 0) goto code_r0x000140007576;\n                        uVar14 = uVar14 - 1;\n                        uVar13 = uVar13 + (*arg2_00 << (uVar11 & 0x1f));\n                        arg2_00 = arg2_00 + 1;\n                    }\n                    uVar8 = uVar5;\n                    uVar12 = uVar5;\n                    if (uVar13 != *(puVar2 + 0x24)) {\n                        arg1[4] = \"incorrect length check\";\n                        *(puVar2 + 1) = 0x3f51;\n                        puVar18 = puStack88;\n                        break;\n                    }\n                }\n                *(puVar2 + 1) = 0x3f50;\n                iStackX24 = 1;\n                uVar13 = uVar8;\n                uVar11 = uVar12;\n                goto code_r0x000140007576;\n            case 0x1400082be:\n                iStackX24 = 1;\n                goto code_r0x000140007576;\n            case 0x1400082d1:\n                iStackX24 = -3;\ncode_r0x000140007576:\n                arg1[2] = puStack88;\n                *(arg1 + 3) = uStackX32;\n                *arg1 = arg2_00;\n                *(arg1 + 1) = uVar14;\n                *(puVar2 + 9) = uVar13;\n                *(puVar2 + 0x4c) = uVar11;\n                if (((*(puVar2 + 0x34) == 0) &&\n                    (((uStackX8 == *(arg1 + 3) || (0x3f50 < *(puVar2 + 1))) || ((0x3f4d < *(puVar2 + 1) && (arg2 == 4)))\n                     ))) || (iVar4 = fcn.140008780(arg1, arg1[2], uStackX8 - *(arg1 + 3)),  iVar4 == 0)) {\n                    uStackX8 = uStackX8 - *(arg1 + 3);\n                    uStack96 = uStack96 - *(arg1 + 1);\n                    *(arg1 + 0xc) = *(arg1 + 0xc) + uStack96;\n                    *(arg1 + 0x1c) = *(arg1 + 0x1c) + uStackX8;\n                    *(puVar2 + 0x24) = *(puVar2 + 0x24) + uStackX8;\n                    if (((*(puVar2 + 2) & 4) != 0) && (uStackX8 != 0)) {\n                        if (*(puVar2 + 3) == 0) {\n                            uVar6 = fcn.140008890(*(puVar2 + 4), arg1[2] - uStackX8, uStackX8);\n                        }\n                        else {\n                            uVar6 = fcn.140008b80(*(puVar2 + 4), arg1[2] - uStackX8, uStackX8);\n                        }\n                        *(puVar2 + 4) = uVar6;\n                        *(arg1 + 0x4c) = uVar6;\n                    }\n                    iVar4 = *(puVar2 + 1);\n                    if ((iVar4 == 0x3f47) || (iVar4 == 0x3f42)) {\n                        iVar9 = 0x100;\n                    }\n                    else {\n                        iVar9 = 0;\n                    }\n                    iVar17 = 0;\n                    if (iVar4 == 0x3f3f) {\n                        iVar17 = 0x80;\n                    }\n                    *(arg1 + 9) = (-(*(puVar2 + 0xc) != 0) & 0x40) + iVar17 + *(puVar2 + 0x4c) + iVar9;\n                    if (((uStack96 != 0) || (uStackX8 != 0)) && (arg2 != 4)) {\n                        return iStackX24;\n                    }\n                    if (iStackX24 != 0) {\n                        return iStackX24;\n                    }\n                    return -5;\n                }\n                *(puVar2 + 1) = 0x3f52;\ncode_r0x0001400083ca:\n                return -4;\n            case 0x1400083c5:\n                goto code_r0x0001400083ca;\n            }\ncode_r0x0001400073c1:\n            iVar4 = *(puVar2 + 1);\n        }\n    }\ncode_r0x0001400083ca:\n    return -2;\n}\n",
        "token_count": 14346
    },
    "14000846": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nulong fcn.140008460(int64_t arg1)\n\n{\n    int64_t *piVar1;\n    code *pcVar2;\n    \n    if ((((arg1 != 0) && (*(arg1 + 0x30) != 0)) && (pcVar2 = *(arg1 + 0x38),  pcVar2 != NULL)) &&\n       (((piVar1 = *(arg1 + 0x28),  piVar1 != NULL && (*piVar1 == arg1)) && (*(piVar1 + 1) - 0x3f34U < 0x20)))) {\n        if (piVar1[8] != 0) {\n            (*pcVar2)(*(arg1 + 0x40), piVar1[8]);\n            piVar1 = *(arg1 + 0x28);\n            pcVar2 = *(arg1 + 0x38);\n        }\n        (*pcVar2)(*(arg1 + 0x40), piVar1);\n        *(arg1 + 0x28) = 0;\n        return 0;\n    }\n    return 0xfffffffe;\n}\n",
        "token_count": 245
    },
    "14000889": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nuint32_t fcn.140008890(ulong arg1, uint8_t *arg2, ulong arg3)\n\n{\n    uint8_t *puVar1;\n    uint8_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    int32_t iVar5;\n    int32_t iVar6;\n    int32_t iVar7;\n    int32_t iVar8;\n    int32_t iVar9;\n    int32_t iVar10;\n    int32_t iVar11;\n    int32_t iVar12;\n    int32_t iVar13;\n    int32_t iVar14;\n    int32_t iVar15;\n    int32_t iVar16;\n    int32_t iVar17;\n    int32_t iVar18;\n    int32_t iVar19;\n    int64_t iVar20;\n    uint32_t uVar21;\n    uint64_t uVar22;\n    uint32_t uVar23;\n    uint64_t uVar24;\n    \n    uVar22 = arg3;\n    uVar23 = arg1 >> 0x10;\n    arg1._0_4_ = arg1 & 0xffff;\n    if (uVar22 == 1) {\n        arg1._0_4_ = *arg2 + arg1;\n        uVar21 = arg1 - 0xfff1;\n        if (arg1 < 0xfff1) {\n            uVar21 = arg1;\n        }\n        uVar23 = uVar21 + uVar23;\n        uVar3 = uVar23 - 0xfff1;\n        if (uVar23 < 0xfff1) {\n            uVar3 = uVar23;\n        }\n        return uVar3 << 0x10 | uVar21;\n    }\n    if (arg2 == NULL) {\n        return 1;\n    }\n    if (uVar22 < 0x10) {\n        for (; uVar22 != 0; uVar22 = uVar22 - 1) {\n            uVar2 = *arg2;\n            arg2 = arg2 + 1;\n            arg1._0_4_ = arg1 + uVar2;\n            uVar23 = uVar23 + arg1;\n        }\n        uVar21 = arg1 - 0xfff1;\n        if (arg1 < 0xfff1) {\n            uVar21 = arg1;\n        }\n        return ((uVar23 / 0xfff1) * 0xf + uVar23) * 0x10000 | uVar21;\n    }\n    if (0x15af < uVar22) {\n        iVar20 = SUB168(ZEXT816(0x79baa6bb6398b6f7) * ZEXT816(uVar22) >> 0x40, 0);\n        uVar24 = (uVar22 - iVar20 >> 1) + iVar20 >> 0xc;\n        uVar22 = uVar22 + uVar24 * -0x15b0;\n        do {\n            iVar19 = 0x15b;\n            do {\n                iVar4 = arg1 + *arg2;\n                iVar5 = iVar4 + arg2[1];\n                iVar6 = iVar5 + arg2[2];\n                iVar7 = iVar6 + arg2[3];\n                iVar8 = iVar7 + arg2[4];\n                iVar9 = iVar8 + arg2[5];\n                iVar10 = iVar9 + arg2[6];\n                iVar11 = iVar10 + arg2[7];\n                iVar12 = iVar11 + arg2[8];\n                iVar13 = iVar12 + arg2[9];\n                iVar14 = iVar13 + arg2[10];\n                iVar15 = iVar14 + arg2[0xb];\n                iVar16 = iVar15 + arg2[0xc];\n                iVar17 = iVar16 + arg2[0xd];\n                iVar18 = iVar17 + arg2[0xe];\n                puVar1 = arg2 + 0xf;\n                arg2 = arg2 + 0x10;\n                arg1._0_4_ = iVar18 + *puVar1;\n                uVar23 = uVar23 + iVar4 + iVar5 + iVar6 + iVar7 + iVar8 + iVar9 + iVar10 + iVar11 + iVar12 + iVar13 +\n                         iVar14 + iVar15 + iVar16 + iVar17 + iVar18 + arg1;\n                iVar19 = iVar19 + -1;\n            } while (iVar19 != 0);\n            arg1._0_4_ = arg1 % 0xfff1;\n            uVar23 = uVar23 % 0xfff1;\n            uVar24 = uVar24 - 1;\n        } while (uVar24 != 0);\n        if (uVar22 == 0) goto code_r0x000140008b6b;\n        if (uVar22 < 0x10) goto code_r0x000140008b32;\n    }\n    uVar24 = uVar22 >> 4;\n    uVar22 = uVar22 + uVar24 * -0x10;\n    do {\n        iVar19 = arg1 + *arg2;\n        iVar4 = iVar19 + arg2[1];\n        iVar5 = iVar4 + arg2[2];\n        iVar6 = iVar5 + arg2[3];\n        iVar7 = iVar6 + arg2[4];\n        iVar8 = iVar7 + arg2[5];\n        iVar9 = iVar8 + arg2[6];\n        iVar10 = iVar9 + arg2[7];\n        iVar11 = iVar10 + arg2[8];\n        iVar12 = iVar11 + arg2[9];\n        iVar13 = iVar12 + arg2[10];\n        iVar14 = iVar13 + arg2[0xb];\n        iVar15 = iVar14 + arg2[0xc];\n        iVar16 = iVar15 + arg2[0xd];\n        iVar17 = iVar16 + arg2[0xe];\n        puVar1 = arg2 + 0xf;\n        arg2 = arg2 + 0x10;\n        arg1._0_4_ = iVar17 + *puVar1;\n        uVar23 = uVar23 + iVar19 + iVar4 + iVar5 + iVar6 + iVar7 + iVar8 + iVar9 + iVar10 + iVar11 + iVar12 + iVar13 +\n                 iVar14 + iVar15 + iVar16 + iVar17 + arg1;\n        uVar24 = uVar24 - 1;\n    } while (uVar24 != 0);\n    for (; uVar22 != 0; uVar22 = uVar22 - 1) {\ncode_r0x000140008b32:\n        uVar2 = *arg2;\n        arg2 = arg2 + 1;\n        arg1._0_4_ = arg1 + uVar2;\n        uVar23 = uVar23 + arg1;\n    }\n    arg1._0_4_ = arg1 % 0xfff1;\n    uVar23 = uVar23 % 0xfff1;\ncode_r0x000140008b6b:\n    return uVar23 << 0x10 | arg1;\n}\n",
        "token_count": 1533
    },
    "140008ec": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.140008ec0(ulong arg1, uint16_t *arg2, ulong arg3, int64_t *arg4)\n\n{\n    int64_t iVar1;\n    uint16_t uVar2;\n    code *pcVar3;\n    char cVar4;\n    uint8_t uVar5;\n    uint16_t *puVar6;\n    uint64_t uVar7;\n    uint64_t uVar8;\n    int64_t iVar9;\n    uint64_t uVar10;\n    uint32_t uVar11;\n    int32_t iVar12;\n    uint32_t uVar13;\n    uint32_t uVar14;\n    uint32_t uVar15;\n    uint64_t uVar16;\n    uint32_t uVar17;\n    int32_t iVar18;\n    uint32_t uVar19;\n    uint8_t uVar20;\n    uint64_t uVar21;\n    bool bVar22;\n    bool bVar23;\n    uint32_t *in_stack_00000028;\n    int64_t in_stack_00000030;\n    uchar auStack232 [32];\n    uint uStack200;\n    uint32_t uStack196;\n    uint32_t uStack192;\n    uint32_t uStack188;\n    uint32_t uStack184;\n    int32_t iStack180;\n    int64_t iStack176;\n    int64_t iStack168;\n    int64_t *piStack160;\n    uint16_t *puStack144;\n    uint16_t auStack128 [16];\n    uint16_t auStack96 [16];\n    uint64_t uStack64;\n    \n    uStack64 = *0x140037018 ^ auStack232;\n    uVar10 = 0;\n    uVar8 = arg3;\n    uVar16 = uVar10;\n    do {\n        iStack180 = arg1;\n        piStack160 = arg4;\n        puStack144 = arg2;\n        if (0x1f < uVar16 * 2) {\n            fcn.140009e20();\n            pcVar3 = swi(3);\n            (*pcVar3)();\n            return;\n        }\n        uVar17 = uVar16 + 1;\n        auStack128[uVar16] = 0;\n        uVar16 = uVar17;\n    } while (uVar17 < 0x10);\n    puVar6 = arg2;\n    if (arg3 != 0) {\n        do {\n            auStack128[*puVar6] = auStack128[*puVar6] + 1;\n            uVar8 = uVar8 - 1;\n            puVar6 = puVar6 + 1;\n        } while (uVar8 != 0);\n    }\n    uVar17 = 0xd;\n    uVar16 = 0xf;\n    do {\n        uVar15 = uVar16;\n        uVar14 = 0xffffffff;\n        if (auStack128[uVar16] != 0) break;\n        if (auStack128[uVar17 + 1] != 0) {\n            uVar15 = uVar15 - 1;\n            break;\n        }\n        if (auStack128[uVar17] != 0) {\n            uVar15 = uVar15 - 2;\n            break;\n        }\n        if (auStack128[uVar17 - 1] != 0) {\n            uVar15 = uVar15 - 3;\n            break;\n        }\n        if (auStack128[uVar17 - 2] != 0) {\n            uVar15 = uVar15 - 4;\n            break;\n        }\n        uVar15 = uVar15 - 5;\n        uVar16 = uVar15;\n        uVar17 = uVar17 - 5;\n    } while (uVar15 != 0);\n    uVar17 = uVar15;\n    if (*in_stack_00000028 <= uVar15) {\n        uVar17 = *in_stack_00000028;\n    }\n    if (uVar15 == 0) {\n        uStack200 = 0x140;\n        **arg4 = 0x140;\n        *arg4 = *arg4 + 4;\n        **arg4 = 0x140;\n        *arg4 = *arg4 + 4;\n        *in_stack_00000028 = 1;\n        goto code_r0x0001400091b0;\n    }\n    uVar19 = 1;\n    if (1 < uVar15) {\n        puVar6 = auStack128;\n        do {\n            puVar6 = puVar6 + 1;\n            if (*puVar6 != 0) break;\n            uVar19 = uVar19 + 1;\n        } while (uVar19 < uVar15);\n    }\n    uVar16 = 1;\n    uStack184 = uVar19;\n    if (uVar19 <= uVar17) {\n        uStack184 = uVar17;\n    }\n    iVar12 = 1;\n    do {\n        iVar12 = iVar12 * 2 - auStack128[uVar16];\n        if (iVar12 < 0) goto code_r0x0001400091b0;\n        uVar17 = uVar16 + 1;\n        uVar16 = uVar17;\n    } while (uVar17 < 0x10);\n    if ((0 < iVar12) && ((arg1 == 0 || (uVar15 != 1)))) goto code_r0x0001400091b0;\n    auStack96[1] = 0;\n    iVar9 = 0xe;\n    uVar16 = uVar10;\n    do {\n        *(auStack96 + uVar16 + 4) = *(auStack128 + uVar16 + 2) + *(auStack96 + uVar16 + 2);\n        uVar16 = uVar16 + 2;\n        iVar9 = iVar9 + -1;\n    } while (iVar9 != 0);\n    puVar6 = arg2;\n    if (arg3 != 0) {\n        do {\n            if (*puVar6 != 0) {\n                *(in_stack_00000030 + auStack96[*puVar6] * 2) = uVar10;\n                auStack96[*puVar6] = auStack96[*puVar6] + 1;\n            }\n            uVar17 = uVar10 + 1;\n            uVar10 = uVar17;\n            puVar6 = puVar6 + 1;\n        } while (uVar17 < arg3);\n    }\n    iVar9 = *arg4;\n    uVar17 = 1 << (uStack184 & 0x1f);\n    uVar16 = uVar17;\n    if (arg1 == 0) {\n        iStack176 = in_stack_00000030;\n        uStack196 = 0x14;\n        iStack168 = in_stack_00000030;\n        goto code_r0x000140009233;\n    }\n    if (arg1 == 1) {\n        iStack168 = 0x14002a810;\n        iStack176 = 0x14002a850;\n        uStack196 = 0x101;\ncode_r0x000140009203:\n        if (uVar17 < 0x355) {\ncode_r0x000140009233:\n            uStack192 = uVar17 - 1;\n            uVar7 = 0;\n            uStack188 = 0;\n            uVar8 = uVar7;\n            uVar10 = uVar16;\n            uVar21 = uVar7;\n            do {\n                cVar4 = uVar19;\n                uVar20 = uVar21;\n                uVar5 = cVar4 - uVar20;\n                uVar2 = *(in_stack_00000030 + uVar7 * 2);\n                if (uVar2 + 1 < uStack196) {\n                    uStack200 = uVar5 << 8;\n                    uStack200 = uStack200 | uVar2 << 0x10;\n                }\n                else {\n                    uStack200._1_3_ = uVar5;\n                    if (uVar2 < uStack196) {\n                        uStack200 = CONCAT31(uStack200._1_3_, 0x60);\n                    }\n                    else {\n                        iVar1 = (uVar2 - uStack196) * 2;\n                        uStack200 = CONCAT22(*(iVar1 + iStack168), CONCAT11(uVar5, *(iVar1 + iStack176)));\n                    }\n                }\n                uVar11 = uVar8;\n                iVar12 = 1 << (cVar4 - uVar20 & 0x1f);\n                uVar7 = (uVar11 >> (uVar20 & 0x1f)) + uVar10;\n                uVar8 = uVar10;\n                do {\n                    uVar7 = uVar7 - iVar12;\n                    *(iVar9 + uVar7 * 4) = uStack200;\n                    uVar13 = uVar8 - iVar12;\n                    uVar8 = uVar13;\n                } while (uVar13 != 0);\n                for (uVar13 = 1 << (cVar4 - 1U & 0x1f); (uVar11 & uVar13) != 0; uVar13 = uVar13 >> 1) {\n                }\n                if (uVar13 == 0) {\n                    uVar8 = 0;\n                }\n                else {\n                    uVar8 = (uVar11 & uVar13 - 1) + uVar13;\n                }\n                uStack188 = uStack188 + 1;\n                puVar6 = auStack128 + uVar19;\n                *puVar6 = *puVar6 - 1;\n                if (*puVar6 == 0) {\n                    if (uVar19 == uVar15) {\n                        if (uVar8 != 0) {\n                            uStack200 = CONCAT31(uStack200._1_3_, 0x40);\n                            uStack200 = uStack200 & 0xffff;\n                            *(iVar9 + uVar8 * 4) = uStack200;\n                        }\n                        *arg4 = *arg4 + uVar16 * 4;\n                        *in_stack_00000028 = uStack184;\n                        break;\n                    }\n                    uVar19 = arg2[*(in_stack_00000030 + uStack188 * 2)];\n                }\n                if (uStack184 < uVar19) {\n                    uVar11 = uStack192 & uVar8;\n                    if (uVar11 != uVar14) {\n                        iVar9 = iVar9 + uVar10 * 4;\n                        if (uVar21 == 0) {\n                            uVar21 = uStack184;\n                        }\n                        iVar18 = uVar19 - uVar21;\n                        uVar5 = iVar18;\n                        iVar12 = 1 << (uVar5 & 0x1f);\n                        for (uVar14 = uVar19; uVar14 < uVar15; uVar14 = uVar14 + 1) {\n                            uVar5 = iVar18;\n                            if (iVar12 - auStack128[uVar14] < 1) break;\n                            iVar18 = iVar18 + 1;\n                            uVar5 = iVar18;\n                            iVar12 = (iVar12 - auStack128[uVar14]) * 2;\n                        }\n                        uVar14 = 1 << (uVar5 & 0x1f);\n                        uVar10 = uVar14;\n                        uVar14 = uVar16 + uVar14;\n                        uVar16 = uVar14;\n                        if (arg1 == 1) {\n                            bVar22 = uVar14 < 0x354;\n                            bVar23 = uVar14 == 0x354;\ncode_r0x0001400093e8:\n                            if (!bVar22 && !bVar23) break;\n                        }\n                        else if (arg1 == 2) {\n                            bVar22 = uVar14 < 0x250;\n                            bVar23 = uVar14 == 0x250;\n                            goto code_r0x0001400093e8;\n                        }\n                        iVar1 = uVar11 * 4;\n                        *(iVar1 + *arg4) = uVar5;\n                        *(iVar1 + 1 + *arg4) = uStack184;\n                        *(*arg4 + 2 + iVar1) = iVar9 - *arg4 >> 2;\n                        uVar14 = uVar11;\n                    }\n                }\n                uVar7 = uStack188;\n            } while( true );\n        }\n    }\n    else {\n        uStack196 = 0;\n        iStack168 = 0x14002a890;\n        iStack176 = 0x14002a8d0;\n        if (arg1 == 1) goto code_r0x000140009203;\n        if (arg1 != 2) {\ncode_r0x000140009230:\n            iStack168 = 0x14002a890;\n            iStack176 = 0x14002a8d0;\n            uStack196 = 0;\n            goto code_r0x000140009233;\n        }\n        iStack168 = 0x14002a890;\n        iStack176 = 0x14002a8d0;\n        uStack196 = 0;\n        if (uVar17 < 0x251) goto code_r0x000140009230;\n    }\n    uStack192 = uVar17 - 1;\ncode_r0x0001400091b0:\n    fcn.140009a80(uStack64 ^ auStack232);\n    return;\n}\n",
        "token_count": 2978
    },
    "14000948": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.140009480(uint8_t **arg1, ulong arg2)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint uVar3;\n    int32_t iVar4;\n    uint32_t uVar5;\n    uint uVar6;\n    uint8_t *puVar7;\n    uint8_t *puVar8;\n    int64_t iVar9;\n    uint8_t *puVar10;\n    int64_t iVar11;\n    char cVar12;\n    uint32_t uVar13;\n    uint32_t uVar14;\n    uint8_t *puVar15;\n    uint32_t uVar16;\n    uint64_t uVar17;\n    uint8_t *puVar18;\n    uint32_t uVar19;\n    uint32_t uVar20;\n    uint8_t *puVar21;\n    uint8_t *puVar22;\n    uint8_t *puVar23;\n    uint8_t *puVar24;\n    uint8_t *puVar25;\n    int64_t iVar26;\n    uint32_t uVar27;\n    uint32_t uVar28;\n    int32_t iVar29;\n    int32_t iStack88;\n    \n    puVar7 = arg1[5];\n    puVar8 = arg1[2];\n    puVar21 = *arg1;\n    iVar29 = *(arg1 + 3);\n    puVar15 = puVar21 + (*(arg1 + 1) - 5);\n    iVar9 = *(puVar7 + 0x68);\n    uVar2 = *(puVar7 + 0x3c);\n    puVar10 = *(puVar7 + 0x40);\n    uVar20 = *(puVar7 + 0x48);\n    uVar3 = *(puVar7 + 0x70);\n    uVar27 = *(puVar7 + 0x4c);\n    iVar11 = *(puVar7 + 0x60);\n    iStack88 = puVar8 - (arg2 - iVar29);\n    iVar4 = *(puVar7 + 0x34);\n    uVar5 = *(puVar7 + 0x38);\n    uVar6 = *(puVar7 + 0x74);\n    puVar23 = puVar8;\ncode_r0x000140009524:\n    if (uVar27 < 0xf) {\n        uVar20 = uVar20 + (*puVar21 << (uVar27 & 0x1f)) + (puVar21[1] << (uVar27 + 8 & 0x1f));\n        puVar21 = puVar21 + 2;\n        uVar27 = uVar27 + 0x10;\n    }\n    uVar19 = *(iVar11 + ((1 << (uVar3 & 0x1f)) - 1U & uVar20) * 4);\n    uVar16 = uVar19 >> 8 & 0xff;\n    uVar20 = uVar20 >> (uVar16 & 0x1f);\n    uVar27 = uVar27 - uVar16;\n    cVar12 = uVar19;\n    while (cVar12 != '\\0') {\n        uVar16 = uVar19 >> 0x10;\n        puVar25 = puVar23;\n        if ((uVar19 & 0x10) != 0) {\n            uVar19 = uVar19 & 0xf;\n            puVar22 = puVar21;\n            if (uVar19 != 0) {\n                if (uVar27 < uVar19) {\n                    uVar1 = *puVar21;\n                    puVar21 = puVar21 + 1;\n                    uVar20 = uVar20 + (uVar1 << (uVar27 & 0x1f));\n                    uVar27 = uVar27 + 8;\n                }\n                uVar13 = (1 << uVar19) - 1U & uVar20;\n                uVar20 = uVar20 >> uVar19;\n                uVar16 = uVar16 + uVar13;\n                uVar27 = uVar27 - uVar19;\n                puVar22 = puVar21;\n            }\n            if (uVar27 < 0xf) {\n                uVar20 = uVar20 + (*puVar22 << (uVar27 & 0x1f)) + (puVar22[1] << (uVar27 + 8 & 0x1f));\n                puVar22 = puVar22 + 2;\n                uVar27 = uVar27 + 0x10;\n            }\n            uVar19 = *(iVar9 + ((1 << (uVar6 & 0x1f)) - 1U & uVar20) * 4);\n            uVar13 = uVar19 >> 8 & 0xff;\n            uVar20 = uVar20 >> (uVar13 & 0x1f);\n            uVar27 = uVar27 - uVar13;\n            uVar13 = uVar19 & 0xff;\n            puVar21 = puVar22;\n            if ((uVar19 & 0x10) == 0) goto code_r0x000140009637;\n            goto code_r0x000140009673;\n        }\n        if ((uVar19 & 0x40) != 0) {\n            if ((uVar19 & 0x20) == 0) {\n                arg1[4] = \"invalid literal/length code\";\n                *(puVar7 + 8) = 0x3f51;\n            }\n            else {\n                *(puVar7 + 8) = 0x3f3f;\n            }\n            goto code_r0x000140009912;\n        }\n        uVar19 = *(iVar11 + (((1 << (uVar19 & 0x1f)) - 1U & uVar20) + (uVar19 >> 0x10)) * 4);\n        uVar16 = uVar19 >> 8 & 0xff;\n        uVar20 = uVar20 >> (uVar16 & 0x1f);\n        uVar27 = uVar27 - uVar16;\n        cVar12 = uVar19;\n    }\n    *puVar23 = uVar19 >> 0x10;\n    puVar25 = puVar23 + 1;\n    goto code_r0x00014000988b;\n    while( true ) {\n        uVar19 = *(iVar9 + (((1 << (uVar13 & 0x1f)) - 1U & uVar20) + (uVar19 >> 0x10)) * 4);\n        uVar13 = uVar19 >> 8 & 0xff;\n        uVar20 = uVar20 >> (uVar13 & 0x1f);\n        uVar27 = uVar27 - uVar13;\n        uVar13 = uVar19 & 0xff;\n        if ((uVar19 & 0x10) != 0) break;\ncode_r0x000140009637:\n        if ((uVar13 & 0x40) != 0) {\n            arg1[4] = \"invalid distance code\";\n            *(puVar7 + 8) = 0x3f51;\n            goto code_r0x000140009912;\n        }\n    }\ncode_r0x000140009673:\n    uVar13 = uVar13 & 0xf;\n    uVar28 = uVar27;\n    if (uVar27 < uVar13) {\n        uVar28 = uVar27 + 8;\n        uVar20 = uVar20 + (*puVar22 << (uVar27 & 0x1f));\n        puVar21 = puVar22 + 1;\n        if (uVar28 < uVar13) {\n            uVar20 = uVar20 + (*puVar21 << (uVar28 & 0x1f));\n            puVar21 = puVar22 + 2;\n            uVar28 = uVar27 + 0x10;\n        }\n    }\n    uVar14 = puVar23 - iStack88;\n    uVar27 = uVar28 - uVar13;\n    uVar19 = ((1 << uVar13) - 1U & uVar20) + (uVar19 >> 0x10);\n    uVar20 = uVar20 >> uVar13;\n    if (uVar19 <= uVar14) {\n        puVar22 = puVar23 + -uVar19;\n        do {\n            puVar24 = puVar23;\n            puVar18 = puVar22;\n            *puVar24 = *puVar18;\n            uVar16 = uVar16 - 3;\n            puVar24[1] = puVar18[1];\n            puVar24[2] = puVar18[2];\n            puVar25 = puVar24 + 3;\n            puVar22 = puVar18 + 3;\n            puVar23 = puVar25;\n        } while (2 < uVar16);\n        if (uVar16 != 0) {\n            *puVar25 = puVar18[3];\n            puVar25 = puVar24 + 4;\n            if (1 < uVar16) {\n                puVar24[4] = puVar18[4];\n                puVar25 = puVar24 + 5;\n            }\n        }\n        goto code_r0x00014000988b;\n    }\n    uVar14 = uVar19 - uVar14;\n    if ((uVar5 < uVar14) && (*(puVar7 + 0x1be0) != 0)) {\n        arg1[4] = \"invalid distance too far back\";\n        *(puVar7 + 8) = 0x3f51;\ncode_r0x000140009912:\n        arg1[2] = puVar25;\n        *(arg1 + 3) = ((puVar8 + (iVar29 - 0x101)) - puVar25) + 0x101;\n        *arg1 = puVar21 + -(uVar27 >> 3);\n        iVar29 = uVar27 - (uVar27 & 0xfffffff8);\n        *(arg1 + 1) = (puVar15 - (puVar21 + -(uVar27 >> 3))) + 5;\n        *(puVar7 + 0x4c) = iVar29;\n        *(puVar7 + 0x48) = (1 << (iVar29 & 0x1f)) - 1U & uVar20;\n        return;\n    }\n    if (uVar2 == 0) {\n        puVar22 = puVar10 + (iVar4 - uVar14);\n        if (uVar14 < uVar16) {\n            uVar16 = uVar16 - uVar14;\n            do {\n                uVar1 = *puVar22;\n                puVar22 = puVar22 + 1;\n                *puVar23 = uVar1;\n                puVar23 = puVar23 + 1;\n                uVar14 = uVar14 - 1;\n            } while (uVar14 != 0);\ncode_r0x0001400097a3:\n            puVar22 = puVar23 + -uVar19;\n        }\n    }\n    else if (uVar2 < uVar14) {\n        uVar13 = uVar14 - uVar2;\n        puVar22 = puVar10 + (iVar4 + (uVar2 - uVar14));\n        if (uVar13 < uVar16) {\n            uVar16 = uVar16 - uVar13;\n            iVar26 = (puVar10 + (iVar4 + (uVar2 - uVar14))) - puVar23;\n            do {\n                *puVar23 = puVar23[iVar26];\n                puVar23 = puVar23 + 1;\n                uVar13 = uVar13 - 1;\n            } while (uVar13 != 0);\n            puVar22 = puVar10;\n            if (uVar2 < uVar16) {\n                uVar16 = uVar16 - uVar2;\n                puVar25 = puVar10;\n                uVar13 = uVar2;\n                do {\n                    uVar1 = *puVar25;\n                    puVar25 = puVar25 + 1;\n                    *puVar23 = uVar1;\n                    puVar23 = puVar23 + 1;\n                    uVar13 = uVar13 - 1;\n                } while (uVar13 != 0);\n                goto code_r0x0001400097a3;\n            }\n        }\n    }\n    else {\n        puVar22 = puVar10 + (uVar2 - uVar14);\n        if (uVar14 < uVar16) {\n            uVar16 = uVar16 - uVar14;\n            do {\n                uVar1 = *puVar22;\n                puVar22 = puVar22 + 1;\n                *puVar23 = uVar1;\n                puVar23 = puVar23 + 1;\n                uVar14 = uVar14 - 1;\n            } while (uVar14 != 0);\n            goto code_r0x0001400097a3;\n        }\n    }\n    if (2 < uVar16) {\n        uVar17 = (uVar16 - 3) / 3 + 1;\n        do {\n            uVar16 = uVar16 - 3;\n            *puVar23 = *puVar22;\n            puVar23[1] = puVar22[1];\n            puVar25 = puVar22 + 2;\n            puVar22 = puVar22 + 3;\n            puVar23[2] = *puVar25;\n            puVar23 = puVar23 + 3;\n            uVar17 = uVar17 - 1;\n        } while (uVar17 != 0);\n    }\n    puVar25 = puVar23;\n    if (uVar16 != 0) {\n        *puVar23 = *puVar22;\n        puVar25 = puVar23 + 1;\n        if (1 < uVar16) {\n            puVar23[1] = puVar22[1];\n            puVar25 = puVar23 + 2;\n        }\n    }\ncode_r0x00014000988b:\n    if ((puVar15 <= puVar21) || (puVar23 = puVar25,  puVar8 + (iVar29 - 0x101) <= puVar25)) goto code_r0x000140009912;\n    goto code_r0x000140009524;\n}\n",
        "token_count": 3183
    },
    "14000c21": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint64_t fcn.14000c21c(int64_t *arg1)\n\n{\n    char cVar1;\n    uint32_t uVar2;\n    uint *puVar3;\n    int64_t arg2;\n    uint64_t uVar4;\n    int64_t iVar5;\n    uint64_t arg3;\n    \n    if (arg1 == NULL) {\n        puVar3 = fcn.140015850(0);\n        *puVar3 = 0x16;\n        fcn.140015730();\n    }\n    else {\n        uVar2 = fcn.1400149ec(arg1);\n        if (*(arg1 + 2) < 0) {\n            *(arg1 + 2) = 0;\n        }\n        arg2 = fcn.1400169fc(uVar2 & 0xffffffff, 0, 1);\n        if (-1 < arg2) {\n            if ((*(arg1 + 0x14) & 0xc0) == 0) {\n                return arg2 - *(arg1 + 2);\n            }\n            uVar4 = uVar2 & 0x3f;\n            iVar5 = uVar2 >> 6;\n            arg3 = *arg1 - arg1[1];\n            cVar1 = *(*(iVar5 * 8 + 0x140046a00) + 0x39 + uVar4 * 0x48);\n            if ((*(arg1 + 0x14) & 3) == 0) {\n                if ((*(arg1 + 0x14) >> 2 & 1) == 0) {\n                    puVar3 = fcn.140015850(iVar5);\n                    *puVar3 = 0x16;\n                    return 0xffffffffffffffff;\n                }\n            }\n            else {\n                if ((cVar1 == '\\x01') && ((*(*(iVar5 * 8 + 0x140046a00) + 0x3d + uVar4 * 0x48) & 2) != 0)) {\n                    uVar4 = fcn.14000c498(arg1, arg2);\n                    return uVar4;\n                }\n                if (*(*(iVar5 * 8 + 0x140046a00) + 0x38 + uVar4 * 0x48) < '\\0') {\n                    iVar5 = fcn.14000c614(arg1[1], *arg1);\n                    arg3 = arg3 + iVar5;\n                }\n            }\n            if (arg2 == 0) {\n                return arg3;\n            }\n            if ((*(arg1 + 0x14) & 1) == 0) {\n                if (cVar1 == '\\x01') {\n                    arg3 = arg3 >> 1;\n                }\n                return arg3 + arg2;\n            }\n            uVar4 = fcn.14000c34c(arg1, arg2, arg3);\n            return uVar4;\n        }\n    }\n    return 0xffffffffffffffff;\n}\n",
        "token_count": 655
    },
    "14000e15": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint64_t fcn.14000e158(int64_t arg1)\n\n{\n    uchar uVar1;\n    int64_t iVar2;\n    char cVar3;\n    uint *puVar4;\n    uint64_t uVar5;\n    int64_t iVar6;\n    \n    iVar6 = arg1;\n    cVar3 = fcn.14000e270(arg1);\n    if (cVar3 == '\\0') {\n        puVar4 = fcn.140015850(iVar6);\n        *puVar4 = 0x16;\n        uVar5 = fcn.140015730();\n        uVar5 = uVar5 & 0xffffffffffffff00;\n    }\n    else {\n        iVar6 = *(arg1 + 0x468);\n        uVar1 = *(arg1 + 0x41);\n        iVar2 = *(iVar6 + 8);\n        if (*(iVar6 + 0x10) == iVar2) {\n            if (*(iVar6 + 0x18) == '\\0') {\n                *(arg1 + 0x28) = 0xffffffff;\n            }\n            else {\n                *(arg1 + 0x28) = *(arg1 + 0x28) + 1;\n            }\n        }\n        else {\n            *(arg1 + 0x28) = *(arg1 + 0x28) + 1;\n            *(iVar6 + 0x10) = *(iVar6 + 0x10) + 1;\n            ***(arg1 + 0x468) = uVar1;\n            **(arg1 + 0x468) = **(arg1 + 0x468) + 1;\n        }\n        uVar5 = CONCAT71(iVar2 >> 8, 1);\n    }\n    return uVar5;\n}\n",
        "token_count": 390
    },
    "14000e31": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint64_t fcn.14000e318(uint8_t *arg1)\n\n{\n    int32_t *arg4;\n    int64_t *arg1_00;\n    uint8_t uVar1;\n    char cVar2;\n    uint32_t uVar3;\n    char *pcVar4;\n    bool bVar5;\n    uint64_t in_RAX;\n    uint *puVar6;\n    uint64_t uVar7;\n    char *pcVar8;\n    ulong uVar9;\n    ushort *noname_1;\n    uint32_t uVar10;\n    uchar uVar11;\n    int64_t arg3;\n    ushort uStackX8;\n    uchar uStackX10;\n    \n    uVar1 = arg1[0x41];\n    pcVar8 = in_RAX & 0xffffffffffffff00;\n    if (uVar1 != 0x46) {\n        if (uVar1 == 0x4e) {\n            if ((*arg1 & 8) != 0) goto code_r0x00014000e47e;\n            *(arg1 + 0x2c) = 8;\n        }\n        else if (*(arg1 + 0x3c) == 0) {\n            if (uVar1 == 0x49) {\n                pcVar4 = *(arg1 + 0x18);\n                cVar2 = *pcVar4;\n                if ((cVar2 == '3') && (pcVar4[1] == '2')) {\n                    pcVar8 = pcVar4 + 2;\n                    *(arg1 + 0x3c) = 10;\n                    *(arg1 + 0x18) = pcVar8;\n                }\n                else if ((cVar2 == '6') && (pcVar4[1] == '4')) {\n                    pcVar8 = pcVar4 + 2;\n                    *(arg1 + 0x3c) = 0xb;\n                    *(arg1 + 0x18) = pcVar8;\n                }\n                else if ((cVar2 + 0xa8U < 0x21) && ((0x120821001U >> (cVar2 + 0xa8U & 0x3f) & 1) != 0)) {\n                    *(arg1 + 0x3c) = 9;\n                }\n            }\n            else if (uVar1 == 0x4c) {\n                *(arg1 + 0x3c) = 8;\n            }\n            else if (uVar1 == 0x54) {\n                *(arg1 + 0x3c) = 0xd;\n            }\n            else {\n                if (uVar1 == 0x68) {\n                    if (**(arg1 + 0x18) == 'h') {\n                        *(arg1 + 0x18) = *(arg1 + 0x18) + 1;\n                        pcVar8 = 0x1;\n                    }\n                    else {\n                        pcVar8 = 0x2;\n                    }\n                }\n                else {\n                    if (uVar1 == 0x6a) {\n                        *(arg1 + 0x3c) = 5;\n                        goto code_r0x00014000e47e;\n                    }\n                    if (uVar1 != 0x6c) {\n                        if (uVar1 == 0x74) {\n                            *(arg1 + 0x3c) = 7;\n                        }\n                        else if (uVar1 == 0x77) {\n                            *(arg1 + 0x3c) = 0xc;\n                        }\n                        else if (uVar1 == 0x7a) {\n                            *(arg1 + 0x3c) = 6;\n                        }\n                        goto code_r0x00014000e47e;\n                    }\n                    if (**(arg1 + 0x18) == 'l') {\n                        *(arg1 + 0x18) = *(arg1 + 0x18) + 1;\n                        pcVar8 = 0x4;\n                    }\n                    else {\n                        pcVar8 = 0x3;\n                    }\n                }\n                *(arg1 + 0x3c) = pcVar8;\n            }\ncode_r0x00014000e47e:\n            return CONCAT71(pcVar8 >> 8, 1);\n        }\n        puVar6 = fcn.140015850(arg1);\n        *puVar6 = 0x16;\n        uVar7 = fcn.140015730();\n        return uVar7 & 0xffffffffffffff00;\n    }\n    if ((*arg1 & 8) != 0) goto code_r0x00014000e47e;\n    *(arg1 + 0x2c) = 7;\n    uVar1 = arg1[0x41];\n    uVar11 = 0x78;\n    if (uVar1 < 'e') {\n        if (uVar1 == 100) {\ncode_r0x00014000e87f:\n            *(arg1 + 0x30) = *(arg1 + 0x30) | 0x10;\ncode_r0x00014000e883:\n            uVar9 = 10;\ncode_r0x00014000e88b:\n            pcVar8 = fcn.14000f5b4(arg1, uVar9);\n        }\n        else {\n            if (uVar1 == 0x41) goto code_r0x00014000e892;\n            if (uVar1 == 0x43) {\ncode_r0x00014000e7fd:\n                pcVar8 = fcn.14000f444(arg1);\n            }\n            else {\n                if (uVar1 < 'E') goto code_r0x00014000e89b;\n                if (uVar1 < 'H') goto code_r0x00014000e892;\n                if (uVar1 == 0x53) {\ncode_r0x00014000e83b:\n                    pcVar8 = fcn.14000f944(arg1);\n                }\n                else {\n                    if (uVar1 == 0x58) goto code_r0x00014000e850;\n                    if (uVar1 != 0x5a) {\n                        if (uVar1 != 0x61) {\n                            if (uVar1 != 99) goto code_r0x00014000e89b;\n                            goto code_r0x00014000e7fd;\n                        }\n                        goto code_r0x00014000e892;\n                    }\n                    pcVar8 = fcn.14000efb8(arg1);\n                }\n            }\n        }\n    }\n    else {\n        if ('g' < uVar1) {\n            if (uVar1 == 0x69) goto code_r0x00014000e87f;\n            if (uVar1 == 0x6e) {\n                pcVar8 = fcn.14000f8bc(arg1);\n                goto code_r0x00014000e897;\n            }\n            if (uVar1 == 0x6f) {\n                if ((*(arg1 + 0x30) >> 5 & 1) != 0) {\n                    *(arg1 + 0x30) = *(arg1 + 0x30) | 0x80;\n                }\n                uVar9 = 8;\n            }\n            else if (uVar1 == 0x70) {\n                *(arg1 + 0x38) = 0x10;\n                *(arg1 + 0x3c) = 0xb;\ncode_r0x00014000e850:\n                uVar9 = 0x10;\n            }\n            else {\n                if (uVar1 == 0x73) goto code_r0x00014000e83b;\n                if (uVar1 == 0x75) goto code_r0x00014000e883;\n                if (uVar1 != 0x78) goto code_r0x00014000e89b;\n                uVar9 = 0x10;\n            }\n            goto code_r0x00014000e88b;\n        }\ncode_r0x00014000e892:\n        pcVar8 = fcn.14000f0a8(arg1);\n    }\ncode_r0x00014000e897:\n    if (pcVar8 == '\\0') {\ncode_r0x00014000e89b:\n        return pcVar8 & 0xffffffffffffff00;\n    }\n    if (arg1[0x40] != 0) goto code_r0x00014000e9f4;\n    uVar3 = *(arg1 + 0x30);\n    noname_1 = uVar3;\n    uStackX8 = 0;\n    arg3 = 0;\n    uStackX10 = 0;\n    if ((uVar3 >> 4 & 1) != 0) {\n        if ((uVar3 >> 6 & 1) == 0) {\n            if ((uVar3 & 1) == 0) {\n                if ((uVar3 >> 1 & 1) == 0) goto code_r0x00014000e8f4;\n                uStackX8 = 0x20;\n            }\n            else {\n                uStackX8 = 0x2b;\n            }\n        }\n        else {\n            uStackX8 = 0x2d;\n        }\n        arg3 = 1;\n    }\ncode_r0x00014000e8f4:\n    uVar1 = arg1[0x41];\n    if (((uVar1 + 0xa8 & 0xdf) == 0) && ((uVar3 >> 5 & 1) != 0)) {\n        bVar5 = true;\n    }\n    else {\n        bVar5 = false;\n    }\n    if ((bVar5) || ((uVar1 + 0xbf & 0xdf) == 0)) {\n        *(&uStackX8 + arg3) = 0x30;\n        if ((uVar1 == 0x58) || (uVar1 == 0x41)) {\n            uVar11 = 0x58;\n        }\n        *(&uStackX8 + arg3 + 1) = uVar11;\n        arg3 = arg3 + 2;\n    }\n    uVar10 = (*(arg1 + 0x34) - *(arg1 + 0x50)) - arg3;\n    if ((uVar3 & 0xc) == 0) {\n        noname_1 = CONCAT71(uVar3 >> 8, 0x20);\n        fcn.14000d4b4(arg1 + 0x468, noname_1, uVar10, arg1 + 0x28);\n    }\n    arg1_00 = arg1 + 0x468;\n    arg4 = arg1 + 0x28;\n    if (((*(*arg1_00 + 0x14) >> 0xc & 1) == 0) || (*(*arg1_00 + 8) != 0)) {\n        noname_1 = &uStackX8;\n        fcn.14000ff74(arg1_00, noname_1, arg3, arg4);\n    }\n    else {\n        *arg4 = *arg4 + arg3;\n    }\n    if (((*(arg1 + 0x30) >> 3 & 1) != 0) && ((*(arg1 + 0x30) >> 2 & 1) == 0)) {\n        fcn.14000d4b4(arg1_00, CONCAT71(noname_1 >> 8, 0x30), uVar10, arg4);\n    }\n    uVar9 = 0;\n    pcVar8 = fcn.14000fb40(arg1);\n    if ((-1 < *arg4) && ((*(arg1 + 0x30) >> 2 & 1) != 0)) {\n        pcVar8 = fcn.14000d4b4(arg1_00, CONCAT71(uVar9 >> 8, 0x20), uVar10, arg4);\n    }\ncode_r0x00014000e9f4:\n    return pcVar8 & 0xffffffffffffff00 | 1;\n}\n",
        "token_count": 2698
    },
    "14000e78": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint64_t fcn.14000e78c(int64_t arg1)\n\n{\n    int32_t *arg4;\n    int64_t *arg1_00;\n    char cVar1;\n    uint32_t uVar2;\n    bool bVar3;\n    uint64_t in_RAX;\n    uint64_t uVar4;\n    ulong uVar5;\n    ushort *noname_1;\n    uint32_t uVar6;\n    uchar uVar7;\n    int64_t arg3;\n    ushort uStackX8;\n    uchar uStackX10;\n    \n    cVar1 = *(arg1 + 0x41);\n    uVar4 = in_RAX & 0xffffffffffffff00;\n    uVar7 = 0x78;\n    if (cVar1 < 'e') {\n        if (cVar1 == 'd') {\ncode_r0x00014000e87f:\n            *(arg1 + 0x30) = *(arg1 + 0x30) | 0x10;\ncode_r0x00014000e883:\n            uVar5 = 10;\ncode_r0x00014000e88b:\n            uVar4 = fcn.14000f5b4(arg1, uVar5);\n        }\n        else {\n            if (cVar1 == 'A') goto code_r0x00014000e892;\n            if (cVar1 == 'C') {\ncode_r0x00014000e7fd:\n                uVar4 = fcn.14000f444(arg1);\n            }\n            else {\n                if (cVar1 < 'E') goto code_r0x00014000e89b;\n                if (cVar1 < 'H') goto code_r0x00014000e892;\n                if (cVar1 == 'S') {\ncode_r0x00014000e83b:\n                    uVar4 = fcn.14000f944(arg1);\n                }\n                else {\n                    if (cVar1 == 'X') goto code_r0x00014000e850;\n                    if (cVar1 != 'Z') {\n                        if (cVar1 != 'a') {\n                            if (cVar1 != 'c') goto code_r0x00014000e89b;\n                            goto code_r0x00014000e7fd;\n                        }\n                        goto code_r0x00014000e892;\n                    }\n                    uVar4 = fcn.14000efb8(arg1);\n                }\n            }\n        }\n    }\n    else {\n        if ('g' < cVar1) {\n            if (cVar1 == 'i') goto code_r0x00014000e87f;\n            if (cVar1 == 'n') {\n                uVar4 = fcn.14000f8bc(arg1);\n                goto code_r0x00014000e897;\n            }\n            if (cVar1 == 'o') {\n                if ((*(arg1 + 0x30) >> 5 & 1) != 0) {\n                    *(arg1 + 0x30) = *(arg1 + 0x30) | 0x80;\n                }\n                uVar5 = 8;\n            }\n            else if (cVar1 == 'p') {\n                *(arg1 + 0x38) = 0x10;\n                *(arg1 + 0x3c) = 0xb;\ncode_r0x00014000e850:\n                uVar5 = 0x10;\n            }\n            else {\n                if (cVar1 == 's') goto code_r0x00014000e83b;\n                if (cVar1 == 'u') goto code_r0x00014000e883;\n                if (cVar1 != 'x') goto code_r0x00014000e89b;\n                uVar5 = 0x10;\n            }\n            goto code_r0x00014000e88b;\n        }\ncode_r0x00014000e892:\n        uVar4 = fcn.14000f0a8(arg1);\n    }\ncode_r0x00014000e897:\n    if (uVar4 == '\\0') {\ncode_r0x00014000e89b:\n        return uVar4 & 0xffffffffffffff00;\n    }\n    if (*(arg1 + 0x40) != '\\0') goto code_r0x00014000e9f4;\n    uVar2 = *(arg1 + 0x30);\n    noname_1 = uVar2;\n    uStackX8 = 0;\n    arg3 = 0;\n    uStackX10 = 0;\n    if ((uVar2 >> 4 & 1) != 0) {\n        if ((uVar2 >> 6 & 1) == 0) {\n            if ((uVar2 & 1) == 0) {\n                if ((uVar2 >> 1 & 1) == 0) goto code_r0x00014000e8f4;\n                uStackX8 = 0x20;\n            }\n            else {\n                uStackX8 = 0x2b;\n            }\n        }\n        else {\n            uStackX8 = 0x2d;\n        }\n        arg3 = 1;\n    }\ncode_r0x00014000e8f4:\n    cVar1 = *(arg1 + 0x41);\n    if (((cVar1 + 0xa8U & 0xdf) == 0) && ((uVar2 >> 5 & 1) != 0)) {\n        bVar3 = true;\n    }\n    else {\n        bVar3 = false;\n    }\n    if ((bVar3) || ((cVar1 + 0xbfU & 0xdf) == 0)) {\n        *(&uStackX8 + arg3) = 0x30;\n        if ((cVar1 == 'X') || (cVar1 == 'A')) {\n            uVar7 = 0x58;\n        }\n        *(&uStackX8 + arg3 + 1) = uVar7;\n        arg3 = arg3 + 2;\n    }\n    uVar6 = (*(arg1 + 0x34) - *(arg1 + 0x50)) - arg3;\n    if ((uVar2 & 0xc) == 0) {\n        noname_1 = CONCAT71(uVar2 >> 8, 0x20);\n        fcn.14000d4b4(arg1 + 0x468, noname_1, uVar6, arg1 + 0x28);\n    }\n    arg1_00 = arg1 + 0x468;\n    arg4 = arg1 + 0x28;\n    if (((*(*arg1_00 + 0x14) >> 0xc & 1) == 0) || (*(*arg1_00 + 8) != 0)) {\n        noname_1 = &uStackX8;\n        fcn.14000ff74(arg1_00, noname_1, arg3, arg4);\n    }\n    else {\n        *arg4 = *arg4 + arg3;\n    }\n    if (((*(arg1 + 0x30) >> 3 & 1) != 0) && ((*(arg1 + 0x30) >> 2 & 1) == 0)) {\n        fcn.14000d4b4(arg1_00, CONCAT71(noname_1 >> 8, 0x30), uVar6, arg4);\n    }\n    uVar5 = 0;\n    uVar4 = fcn.14000fb40(arg1);\n    if ((-1 < *arg4) && ((*(arg1 + 0x30) >> 2 & 1) != 0)) {\n        uVar4 = fcn.14000d4b4(arg1_00, CONCAT71(uVar5 >> 8, 0x20), uVar6, arg4);\n    }\ncode_r0x00014000e9f4:\n    return uVar4 & 0xffffffffffffff00 | 1;\n}\n",
        "token_count": 1772
    },
    "14000e48": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint64_t fcn.14000e488(uint8_t *arg1)\n\n{\n    int32_t *arg4;\n    uint8_t *arg1_00;\n    uint8_t uVar1;\n    char cVar2;\n    uint32_t uVar3;\n    char *pcVar4;\n    bool bVar5;\n    uint64_t in_RAX;\n    uint *puVar6;\n    uint64_t uVar7;\n    char *pcVar8;\n    ulong uVar9;\n    ushort *arg2;\n    uchar uVar10;\n    uint32_t uVar11;\n    int64_t arg3;\n    ushort uStackX8;\n    uchar uStackX10;\n    \n    uVar1 = arg1[0x41];\n    pcVar8 = in_RAX & 0xffffffffffffff00;\n    if (uVar1 != 0x46) {\n        if (uVar1 == 0x4e) {\n            if ((*arg1 & 8) != 0) goto code_r0x00014000e5ee;\n            *(arg1 + 0x2c) = 8;\n        }\n        else if (*(arg1 + 0x3c) == 0) {\n            if (uVar1 == 0x49) {\n                pcVar4 = *(arg1 + 0x18);\n                cVar2 = *pcVar4;\n                if ((cVar2 == '3') && (pcVar4[1] == '2')) {\n                    pcVar8 = pcVar4 + 2;\n                    *(arg1 + 0x3c) = 10;\n                    *(arg1 + 0x18) = pcVar8;\n                }\n                else if ((cVar2 == '6') && (pcVar4[1] == '4')) {\n                    pcVar8 = pcVar4 + 2;\n                    *(arg1 + 0x3c) = 0xb;\n                    *(arg1 + 0x18) = pcVar8;\n                }\n                else if ((cVar2 + 0xa8U < 0x21) && ((0x120821001U >> (cVar2 + 0xa8U & 0x3f) & 1) != 0)) {\n                    *(arg1 + 0x3c) = 9;\n                }\n            }\n            else if (uVar1 == 0x4c) {\n                *(arg1 + 0x3c) = 8;\n            }\n            else if (uVar1 == 0x54) {\n                *(arg1 + 0x3c) = 0xd;\n            }\n            else {\n                if (uVar1 == 0x68) {\n                    if (**(arg1 + 0x18) == 'h') {\n                        *(arg1 + 0x18) = *(arg1 + 0x18) + 1;\n                        pcVar8 = 0x1;\n                    }\n                    else {\n                        pcVar8 = 0x2;\n                    }\n                }\n                else {\n                    if (uVar1 == 0x6a) {\n                        *(arg1 + 0x3c) = 5;\n                        goto code_r0x00014000e5ee;\n                    }\n                    if (uVar1 != 0x6c) {\n                        if (uVar1 == 0x74) {\n                            *(arg1 + 0x3c) = 7;\n                        }\n                        else if (uVar1 == 0x77) {\n                            *(arg1 + 0x3c) = 0xc;\n                        }\n                        else if (uVar1 == 0x7a) {\n                            *(arg1 + 0x3c) = 6;\n                        }\n                        goto code_r0x00014000e5ee;\n                    }\n                    if (**(arg1 + 0x18) == 'l') {\n                        *(arg1 + 0x18) = *(arg1 + 0x18) + 1;\n                        pcVar8 = 0x4;\n                    }\n                    else {\n                        pcVar8 = 0x3;\n                    }\n                }\n                *(arg1 + 0x3c) = pcVar8;\n            }\ncode_r0x00014000e5ee:\n            return CONCAT71(pcVar8 >> 8, 1);\n        }\n        puVar6 = fcn.140015850(arg1);\n        *puVar6 = 0x16;\n        uVar7 = fcn.140015730();\n        return uVar7 & 0xffffffffffffff00;\n    }\n    if ((*arg1 & 8) != 0) goto code_r0x00014000e5ee;\n    *(arg1 + 0x2c) = 7;\n    uVar1 = arg1[0x41];\n    uVar10 = 0x78;\n    if (uVar1 < 'e') {\n        if (uVar1 == 100) {\ncode_r0x00014000eb03:\n            *(arg1 + 0x30) = *(arg1 + 0x30) | 0x10;\ncode_r0x00014000eb07:\n            uVar9 = 10;\ncode_r0x00014000eb0f:\n            pcVar8 = fcn.14000f5b4(arg1, uVar9);\n        }\n        else {\n            if (uVar1 == 0x41) goto code_r0x00014000eb16;\n            if (uVar1 == 0x43) {\ncode_r0x00014000ea81:\n                pcVar8 = fcn.14000f444(arg1);\n            }\n            else {\n                if (uVar1 < 'E') goto code_r0x00014000eb1f;\n                if (uVar1 < 'H') goto code_r0x00014000eb16;\n                if (uVar1 == 0x53) {\ncode_r0x00014000eabf:\n                    pcVar8 = fcn.14000f944(arg1);\n                }\n                else {\n                    if (uVar1 == 0x58) goto code_r0x00014000ead4;\n                    if (uVar1 != 0x5a) {\n                        if (uVar1 != 0x61) {\n                            if (uVar1 != 99) goto code_r0x00014000eb1f;\n                            goto code_r0x00014000ea81;\n                        }\n                        goto code_r0x00014000eb16;\n                    }\n                    pcVar8 = fcn.14000efb8(arg1);\n                }\n            }\n        }\n    }\n    else {\n        if ('g' < uVar1) {\n            if (uVar1 == 0x69) goto code_r0x00014000eb03;\n            if (uVar1 == 0x6e) {\n                pcVar8 = fcn.14000f8bc(arg1);\n                goto code_r0x00014000eb1b;\n            }\n            if (uVar1 == 0x6f) {\n                if ((*(arg1 + 0x30) >> 5 & 1) != 0) {\n                    *(arg1 + 0x30) = *(arg1 + 0x30) | 0x80;\n                }\n                uVar9 = 8;\n            }\n            else if (uVar1 == 0x70) {\n                *(arg1 + 0x38) = 0x10;\n                *(arg1 + 0x3c) = 0xb;\ncode_r0x00014000ead4:\n                uVar9 = 0x10;\n            }\n            else {\n                if (uVar1 == 0x73) goto code_r0x00014000eabf;\n                if (uVar1 == 0x75) goto code_r0x00014000eb07;\n                if (uVar1 != 0x78) goto code_r0x00014000eb1f;\n                uVar9 = 0x10;\n            }\n            goto code_r0x00014000eb0f;\n        }\ncode_r0x00014000eb16:\n        pcVar8 = fcn.14000f0a8(arg1);\n    }\ncode_r0x00014000eb1b:\n    if (pcVar8 == '\\0') {\ncode_r0x00014000eb1f:\n        return pcVar8 & 0xffffffffffffff00;\n    }\n    if (arg1[0x40] != 0) goto code_r0x00014000ec5a;\n    uVar3 = *(arg1 + 0x30);\n    uStackX8 = 0;\n    arg3 = 0;\n    uStackX10 = 0;\n    if ((uVar3 >> 4 & 1) != 0) {\n        if ((uVar3 >> 6 & 1) == 0) {\n            if ((uVar3 & 1) == 0) {\n                if ((uVar3 >> 1 & 1) == 0) goto code_r0x00014000eb78;\n                uStackX8 = 0x20;\n            }\n            else {\n                uStackX8 = 0x2b;\n            }\n        }\n        else {\n            uStackX8 = 0x2d;\n        }\n        arg3 = 1;\n    }\ncode_r0x00014000eb78:\n    uVar1 = arg1[0x41];\n    if (((uVar1 + 0xa8 & 0xdf) == 0) && ((uVar3 >> 5 & 1) != 0)) {\n        bVar5 = true;\n    }\n    else {\n        bVar5 = false;\n    }\n    if ((bVar5) || ((uVar1 + 0xbf & 0xdf) == 0)) {\n        *(&uStackX8 + arg3) = 0x30;\n        if ((uVar1 == 0x58) || (uVar1 == 0x41)) {\n            uVar10 = 0x58;\n        }\n        *(&uStackX8 + arg3 + 1) = uVar10;\n        arg3 = arg3 + 2;\n    }\n    arg4 = arg1 + 0x28;\n    arg1_00 = arg1 + 0x468;\n    uVar11 = (*(arg1 + 0x34) - *(arg1 + 0x50)) - arg3;\n    if ((uVar3 & 0xc) == 0) {\n        fcn.14000d540(arg1_00, CONCAT71(uVar3 >> 8, 0x20), uVar11, arg4);\n    }\n    arg2 = &uStackX8;\n    fcn.14000fe28(arg1_00, arg2, arg3, arg4);\n    if (((*(arg1 + 0x30) >> 3 & 1) != 0) && ((*(arg1 + 0x30) >> 2 & 1) == 0)) {\n        fcn.14000d540(arg1_00, CONCAT71(arg2 >> 8, 0x30), uVar11, arg4);\n    }\n    uVar9 = 0;\n    pcVar8 = fcn.14000fc64(arg1);\n    if ((-1 < *arg4) && ((*(arg1 + 0x30) >> 2 & 1) != 0)) {\n        pcVar8 = fcn.14000d540(arg1_00, CONCAT71(uVar9 >> 8, 0x20), uVar11, arg4);\n    }\ncode_r0x00014000ec5a:\n    return pcVar8 & 0xffffffffffffff00 | 1;\n}\n",
        "token_count": 2585
    },
    "14000ea1": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint64_t fcn.14000ea10(int64_t arg1)\n\n{\n    int32_t *arg4;\n    int64_t arg1_00;\n    char cVar1;\n    uint32_t uVar2;\n    bool bVar3;\n    uint64_t in_RAX;\n    uint64_t uVar4;\n    ulong uVar5;\n    ushort *arg2;\n    uchar uVar6;\n    uint32_t uVar7;\n    int64_t arg3;\n    ushort uStackX8;\n    uchar uStackX10;\n    \n    cVar1 = *(arg1 + 0x41);\n    uVar4 = in_RAX & 0xffffffffffffff00;\n    uVar6 = 0x78;\n    if (cVar1 < 'e') {\n        if (cVar1 == 'd') {\ncode_r0x00014000eb03:\n            *(arg1 + 0x30) = *(arg1 + 0x30) | 0x10;\ncode_r0x00014000eb07:\n            uVar5 = 10;\ncode_r0x00014000eb0f:\n            uVar4 = fcn.14000f5b4(arg1, uVar5);\n        }\n        else {\n            if (cVar1 == 'A') goto code_r0x00014000eb16;\n            if (cVar1 == 'C') {\ncode_r0x00014000ea81:\n                uVar4 = fcn.14000f444(arg1);\n            }\n            else {\n                if (cVar1 < 'E') goto code_r0x00014000eb1f;\n                if (cVar1 < 'H') goto code_r0x00014000eb16;\n                if (cVar1 == 'S') {\ncode_r0x00014000eabf:\n                    uVar4 = fcn.14000f944(arg1);\n                }\n                else {\n                    if (cVar1 == 'X') goto code_r0x00014000ead4;\n                    if (cVar1 != 'Z') {\n                        if (cVar1 != 'a') {\n                            if (cVar1 != 'c') goto code_r0x00014000eb1f;\n                            goto code_r0x00014000ea81;\n                        }\n                        goto code_r0x00014000eb16;\n                    }\n                    uVar4 = fcn.14000efb8(arg1);\n                }\n            }\n        }\n    }\n    else {\n        if ('g' < cVar1) {\n            if (cVar1 == 'i') goto code_r0x00014000eb03;\n            if (cVar1 == 'n') {\n                uVar4 = fcn.14000f8bc(arg1);\n                goto code_r0x00014000eb1b;\n            }\n            if (cVar1 == 'o') {\n                if ((*(arg1 + 0x30) >> 5 & 1) != 0) {\n                    *(arg1 + 0x30) = *(arg1 + 0x30) | 0x80;\n                }\n                uVar5 = 8;\n            }\n            else if (cVar1 == 'p') {\n                *(arg1 + 0x38) = 0x10;\n                *(arg1 + 0x3c) = 0xb;\ncode_r0x00014000ead4:\n                uVar5 = 0x10;\n            }\n            else {\n                if (cVar1 == 's') goto code_r0x00014000eabf;\n                if (cVar1 == 'u') goto code_r0x00014000eb07;\n                if (cVar1 != 'x') goto code_r0x00014000eb1f;\n                uVar5 = 0x10;\n            }\n            goto code_r0x00014000eb0f;\n        }\ncode_r0x00014000eb16:\n        uVar4 = fcn.14000f0a8(arg1);\n    }\ncode_r0x00014000eb1b:\n    if (uVar4 == '\\0') {\ncode_r0x00014000eb1f:\n        return uVar4 & 0xffffffffffffff00;\n    }\n    if (*(arg1 + 0x40) != '\\0') goto code_r0x00014000ec5a;\n    uVar2 = *(arg1 + 0x30);\n    uStackX8 = 0;\n    arg3 = 0;\n    uStackX10 = 0;\n    if ((uVar2 >> 4 & 1) != 0) {\n        if ((uVar2 >> 6 & 1) == 0) {\n            if ((uVar2 & 1) == 0) {\n                if ((uVar2 >> 1 & 1) == 0) goto code_r0x00014000eb78;\n                uStackX8 = 0x20;\n            }\n            else {\n                uStackX8 = 0x2b;\n            }\n        }\n        else {\n            uStackX8 = 0x2d;\n        }\n        arg3 = 1;\n    }\ncode_r0x00014000eb78:\n    cVar1 = *(arg1 + 0x41);\n    if (((cVar1 + 0xa8U & 0xdf) == 0) && ((uVar2 >> 5 & 1) != 0)) {\n        bVar3 = true;\n    }\n    else {\n        bVar3 = false;\n    }\n    if ((bVar3) || ((cVar1 + 0xbfU & 0xdf) == 0)) {\n        *(&uStackX8 + arg3) = 0x30;\n        if ((cVar1 == 'X') || (cVar1 == 'A')) {\n            uVar6 = 0x58;\n        }\n        *(&uStackX8 + arg3 + 1) = uVar6;\n        arg3 = arg3 + 2;\n    }\n    arg4 = arg1 + 0x28;\n    arg1_00 = arg1 + 0x468;\n    uVar7 = (*(arg1 + 0x34) - *(arg1 + 0x50)) - arg3;\n    if ((uVar2 & 0xc) == 0) {\n        fcn.14000d540(arg1_00, CONCAT71(uVar2 >> 8, 0x20), uVar7, arg4);\n    }\n    arg2 = &uStackX8;\n    fcn.14000fe28(arg1_00, arg2, arg3, arg4);\n    if (((*(arg1 + 0x30) >> 3 & 1) != 0) && ((*(arg1 + 0x30) >> 2 & 1) == 0)) {\n        fcn.14000d540(arg1_00, CONCAT71(arg2 >> 8, 0x30), uVar7, arg4);\n    }\n    uVar5 = 0;\n    uVar4 = fcn.14000fc64(arg1);\n    if ((-1 < *arg4) && ((*(arg1 + 0x30) >> 2 & 1) != 0)) {\n        uVar4 = fcn.14000d540(arg1_00, CONCAT71(uVar5 >> 8, 0x20), uVar7, arg4);\n    }\ncode_r0x00014000ec5a:\n    return uVar4 & 0xffffffffffffff00 | 1;\n}\n",
        "token_count": 1657
    },
    "14000e5f": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint64_t fcn.14000e5f8(uint8_t *arg1)\n\n{\n    uint8_t *arg4;\n    uint8_t *arg1_00;\n    int16_t iVar1;\n    uint32_t uVar2;\n    bool bVar3;\n    char cVar4;\n    uint16_t uVar5;\n    uint *puVar6;\n    int16_t *piVar7;\n    uint64_t uVar8;\n    ulong arg2;\n    uchar *arg2_00;\n    uint32_t uVar9;\n    ushort uVar10;\n    int64_t arg3;\n    uchar auStack104 [32];\n    uint8_t *puStack72;\n    uint uStack56;\n    ushort uStack52;\n    uint64_t uStack48;\n    \n    uVar5 = *(arg1 + 0x42);\n    piVar7 = uVar5;\n    if (uVar5 != 0x46) {\n        if (uVar5 == 0x4e) {\n            if ((*arg1 & 8) != 0) goto code_r0x00014000e784;\n            *(arg1 + 0x2c) = 8;\n        }\n        else if (*(arg1 + 0x3c) == 0) {\n            if (uVar5 == 0x49) {\n                piVar7 = *(arg1 + 0x18);\n                iVar1 = *piVar7;\n                if ((iVar1 == 0x33) && (piVar7[1] == 0x32)) {\n                    piVar7 = piVar7 + 2;\n                    *(arg1 + 0x3c) = 10;\n                    *(arg1 + 0x18) = piVar7;\n                }\n                else if ((iVar1 == 0x36) && (piVar7[1] == 0x34)) {\n                    piVar7 = piVar7 + 2;\n                    *(arg1 + 0x3c) = 0xb;\n                    *(arg1 + 0x18) = piVar7;\n                }\n                else {\n                    piVar7 = iVar1 - 0x58U;\n                    if ((iVar1 - 0x58U < 0x21) && ((0x120821001U >> (piVar7 & 0x3f) & 1) != 0)) {\n                        *(arg1 + 0x3c) = 9;\n                    }\n                }\n            }\n            else if (uVar5 == 0x4c) {\n                *(arg1 + 0x3c) = 8;\n            }\n            else if (uVar5 == 0x54) {\n                *(arg1 + 0x3c) = 0xd;\n            }\n            else {\n                if (uVar5 == 0x68) {\n                    if (**(arg1 + 0x18) == 0x68) {\n                        *(arg1 + 0x18) = *(arg1 + 0x18) + 1;\n                        piVar7 = 0x1;\n                    }\n                    else {\n                        piVar7 = 0x2;\n                    }\n                }\n                else {\n                    if (uVar5 == 0x6a) {\n                        *(arg1 + 0x3c) = 5;\n                        goto code_r0x00014000e784;\n                    }\n                    if (uVar5 != 0x6c) {\n                        if (uVar5 == 0x74) {\n                            *(arg1 + 0x3c) = 7;\n                        }\n                        else if (uVar5 == 0x77) {\n                            *(arg1 + 0x3c) = 0xc;\n                        }\n                        else if (uVar5 == 0x7a) {\n                            *(arg1 + 0x3c) = 6;\n                        }\n                        goto code_r0x00014000e784;\n                    }\n                    if (**(arg1 + 0x18) == 0x6c) {\n                        *(arg1 + 0x18) = *(arg1 + 0x18) + 1;\n                        piVar7 = 0x4;\n                    }\n                    else {\n                        piVar7 = 0x3;\n                    }\n                }\n                *(arg1 + 0x3c) = piVar7;\n            }\ncode_r0x00014000e784:\n            return CONCAT71(piVar7 >> 8, 1);\n        }\n        uStack48 = 0x14000e63a;\n        puVar6 = fcn.140015850(arg1);\n        *puVar6 = 0x16;\n        uStack48 = 0x14000e645;\n        uVar8 = fcn.140015730();\n        return uVar8 & 0xffffffffffffff00;\n    }\n    if ((*arg1 & 8) != 0) goto code_r0x00014000e784;\n    *(arg1 + 0x2c) = 7;\n    uStack48 = *0x140037018 ^ &stack0xffffffffffffff98;\n    uVar5 = *(arg1 + 0x42);\n    uVar10 = 0x78;\n    if (uVar5 < 0x65) {\n        if (uVar5 == 100) {\ncode_r0x00014000ed9f:\n            *(arg1 + 0x30) = *(arg1 + 0x30) | 0x10;\ncode_r0x00014000eda3:\n            arg2 = 10;\ncode_r0x00014000edab:\n            cVar4 = fcn.14000f734(arg1, arg2);\n        }\n        else {\n            if (uVar5 == 0x41) goto code_r0x00014000edb2;\n            if (uVar5 == 0x43) {\ncode_r0x00014000ed0b:\n                cVar4 = fcn.14000f50c(arg1);\n            }\n            else {\n                if (uVar5 < 0x45) goto code_r0x00014000ef17;\n                if (uVar5 < 0x48) goto code_r0x00014000edb2;\n                if (uVar5 == 0x53) {\ncode_r0x00014000ed5b:\n                    cVar4 = fcn.14000f9dc(arg1);\n                }\n                else {\n                    if (uVar5 == 0x58) goto code_r0x00014000ed70;\n                    if (uVar5 != 0x5a) {\n                        if (uVar5 != 0x61) {\n                            if (uVar5 != 99) goto code_r0x00014000ef17;\n                            goto code_r0x00014000ed0b;\n                        }\n                        goto code_r0x00014000edb2;\n                    }\n                    cVar4 = fcn.14000f02c(arg1);\n                }\n            }\n        }\n    }\n    else {\n        if (0x67 < uVar5) {\n            if (uVar5 == 0x69) goto code_r0x00014000ed9f;\n            if (uVar5 == 0x6e) {\n                cVar4 = fcn.14000f8bc(arg1);\n                goto code_r0x00014000edb7;\n            }\n            if (uVar5 == 0x6f) {\n                if ((*(arg1 + 0x30) >> 5 & 1) != 0) {\n                    *(arg1 + 0x30) = *(arg1 + 0x30) | 0x80;\n                }\n                arg2 = 8;\n            }\n            else if (uVar5 == 0x70) {\n                *(arg1 + 0x38) = 0x10;\n                *(arg1 + 0x3c) = 0xb;\ncode_r0x00014000ed70:\n                arg2 = 0x10;\n            }\n            else {\n                if (uVar5 == 0x73) goto code_r0x00014000ed5b;\n                if (uVar5 == 0x75) goto code_r0x00014000eda3;\n                if (uVar5 != 0x78) goto code_r0x00014000ef17;\n                arg2 = 0x10;\n            }\n            goto code_r0x00014000edab;\n        }\ncode_r0x00014000edb2:\n        cVar4 = fcn.14000f264(arg1);\n    }\ncode_r0x00014000edb7:\n    if ((cVar4 == '\\0') || (arg1[0x40] != 0)) goto code_r0x00014000ef17;\n    uVar2 = *(arg1 + 0x30);\n    uStack56 = 0;\n    uStack52 = 0;\n    arg3 = 0;\n    if ((uVar2 >> 4 & 1) != 0) {\n        if ((uVar2 >> 6 & 1) == 0) {\n            if ((uVar2 & 1) == 0) {\n                if ((uVar2 >> 1 & 1) != 0) {\n                    uStack56 = 0x20;\n                    arg3 = 1;\n                }\n                goto code_r0x00014000ee1c;\n            }\n            uVar5 = 0x2b;\n        }\n        else {\n            uVar5 = 0x2d;\n        }\n        uStack56 = uVar5;\n        arg3 = 1;\n    }\ncode_r0x00014000ee1c:\n    iVar1 = *(arg1 + 0x42);\n    if (((iVar1 - 0x58U & 0xffdf) == 0) && ((uVar2 >> 5 & 1) != 0)) {\n        bVar3 = true;\n    }\n    else {\n        bVar3 = false;\n    }\n    if ((bVar3) || ((iVar1 - 0x41U & 0xffdf) == 0)) {\n        *(&stack0xffffffffffffffc8 + arg3 * 2) = 0x30;\n        if ((iVar1 == 0x58) || (iVar1 == 0x41)) {\n            uVar10 = 0x58;\n        }\n        *(&stack0xffffffffffffffca + arg3 * 2) = uVar10;\n        arg3 = arg3 + 2;\n    }\n    arg4 = arg1 + 0x28;\n    arg1_00 = arg1 + 0x468;\n    uVar9 = (*(arg1 + 0x34) - *(arg1 + 0x50)) - arg3;\n    if ((uVar2 & 0xc) == 0) {\n        fcn.14000d5b8(arg1_00, uVar2 & 0xffffff00 | 0x20, uVar9, arg4);\n    }\n    puStack72 = arg1 + 0x10;\n    arg2_00 = &stack0xffffffffffffffc8;\n    fcn.14000fecc(arg1_00, arg2_00, arg3, arg4);\n    if (((*(arg1 + 0x30) >> 3 & 1) != 0) && ((*(arg1 + 0x30) >> 2 & 1) == 0)) {\n        fcn.14000d5b8(arg1_00, arg2_00 & 0xffffffffffffff00 | 0x30, uVar9, arg4);\n    }\n    uVar8 = 0;\n    fcn.14000fd40(arg1);\n    if ((-1 < *(arg1 + 0x28)) && ((*(arg1 + 0x30) >> 2 & 1) != 0)) {\n        fcn.14000d5b8(arg1_00, uVar8 & 0xffffffffffffff00 | 0x20, uVar9, arg1 + 0x28);\n    }\ncode_r0x00014000ef17:\n    uVar8 = fcn.140009a80(uStack48 ^ &stack0xffffffffffffff98);\n    return uVar8;\n}\n",
        "token_count": 2698
    },
    "14000ec7": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nvoid fcn.14000ec78(int64_t arg1)\n\n{\n    int64_t arg4;\n    int64_t arg1_00;\n    int16_t iVar1;\n    uint32_t uVar2;\n    bool bVar3;\n    char cVar4;\n    uint16_t uVar5;\n    ulong arg2;\n    uint *arg2_00;\n    uint64_t uVar6;\n    uint32_t uVar7;\n    ushort uVar8;\n    int64_t arg3;\n    uchar auStack104 [32];\n    int64_t iStack72;\n    uint uStack56;\n    ushort uStack52;\n    uint64_t uStack48;\n    \n    uStack48 = *0x140037018 ^ auStack104;\n    uVar5 = *(arg1 + 0x42);\n    uVar8 = 0x78;\n    if (uVar5 < 0x65) {\n        if (uVar5 == 100) {\ncode_r0x00014000ed9f:\n            *(arg1 + 0x30) = *(arg1 + 0x30) | 0x10;\ncode_r0x00014000eda3:\n            arg2 = 10;\ncode_r0x00014000edab:\n            cVar4 = fcn.14000f734(arg1, arg2);\n        }\n        else {\n            if (uVar5 == 0x41) goto code_r0x00014000edb2;\n            if (uVar5 == 0x43) {\ncode_r0x00014000ed0b:\n                cVar4 = fcn.14000f50c(arg1);\n            }\n            else {\n                if (uVar5 < 0x45) goto code_r0x00014000ef17;\n                if (uVar5 < 0x48) goto code_r0x00014000edb2;\n                if (uVar5 == 0x53) {\ncode_r0x00014000ed5b:\n                    cVar4 = fcn.14000f9dc(arg1);\n                }\n                else {\n                    if (uVar5 == 0x58) goto code_r0x00014000ed70;\n                    if (uVar5 != 0x5a) {\n                        if (uVar5 != 0x61) {\n                            if (uVar5 != 99) goto code_r0x00014000ef17;\n                            goto code_r0x00014000ed0b;\n                        }\n                        goto code_r0x00014000edb2;\n                    }\n                    cVar4 = fcn.14000f02c(arg1);\n                }\n            }\n        }\n    }\n    else {\n        if (0x67 < uVar5) {\n            if (uVar5 == 0x69) goto code_r0x00014000ed9f;\n            if (uVar5 == 0x6e) {\n                cVar4 = fcn.14000f8bc(arg1);\n                goto code_r0x00014000edb7;\n            }\n            if (uVar5 == 0x6f) {\n                if ((*(arg1 + 0x30) >> 5 & 1) != 0) {\n                    *(arg1 + 0x30) = *(arg1 + 0x30) | 0x80;\n                }\n                arg2 = 8;\n            }\n            else if (uVar5 == 0x70) {\n                *(arg1 + 0x38) = 0x10;\n                *(arg1 + 0x3c) = 0xb;\ncode_r0x00014000ed70:\n                arg2 = 0x10;\n            }\n            else {\n                if (uVar5 == 0x73) goto code_r0x00014000ed5b;\n                if (uVar5 == 0x75) goto code_r0x00014000eda3;\n                if (uVar5 != 0x78) goto code_r0x00014000ef17;\n                arg2 = 0x10;\n            }\n            goto code_r0x00014000edab;\n        }\ncode_r0x00014000edb2:\n        cVar4 = fcn.14000f264(arg1);\n    }\ncode_r0x00014000edb7:\n    if ((cVar4 == '\\0') || (*(arg1 + 0x40) != '\\0')) goto code_r0x00014000ef17;\n    uVar2 = *(arg1 + 0x30);\n    uStack56 = 0;\n    uStack52 = 0;\n    arg3 = 0;\n    if ((uVar2 >> 4 & 1) != 0) {\n        if ((uVar2 >> 6 & 1) == 0) {\n            if ((uVar2 & 1) == 0) {\n                if ((uVar2 >> 1 & 1) != 0) {\n                    uStack56 = 0x20;\n                    arg3 = 1;\n                }\n                goto code_r0x00014000ee1c;\n            }\n            uVar5 = 0x2b;\n        }\n        else {\n            uVar5 = 0x2d;\n        }\n        uStack56 = uVar5;\n        arg3 = 1;\n    }\ncode_r0x00014000ee1c:\n    iVar1 = *(arg1 + 0x42);\n    if (((iVar1 - 0x58U & 0xffdf) == 0) && ((uVar2 >> 5 & 1) != 0)) {\n        bVar3 = true;\n    }\n    else {\n        bVar3 = false;\n    }\n    if ((bVar3) || ((iVar1 - 0x41U & 0xffdf) == 0)) {\n        *(&uStack56 + arg3 * 2) = 0x30;\n        if ((iVar1 == 0x58) || (iVar1 == 0x41)) {\n            uVar8 = 0x58;\n        }\n        *(&uStack56 + arg3 * 2 + 2) = uVar8;\n        arg3 = arg3 + 2;\n    }\n    arg4 = arg1 + 0x28;\n    arg1_00 = arg1 + 0x468;\n    uVar7 = (*(arg1 + 0x34) - *(arg1 + 0x50)) - arg3;\n    if ((uVar2 & 0xc) == 0) {\n        fcn.14000d5b8(arg1_00, uVar2 & 0xffffff00 | 0x20, uVar7, arg4);\n    }\n    iStack72 = arg1 + 0x10;\n    arg2_00 = &uStack56;\n    fcn.14000fecc(arg1_00, arg2_00, arg3, arg4);\n    if (((*(arg1 + 0x30) >> 3 & 1) != 0) && ((*(arg1 + 0x30) >> 2 & 1) == 0)) {\n        fcn.14000d5b8(arg1_00, arg2_00 & 0xffffffffffffff00 | 0x30, uVar7, arg4);\n    }\n    uVar6 = 0;\n    fcn.14000fd40(arg1);\n    if ((-1 < *(arg1 + 0x28)) && ((*(arg1 + 0x30) >> 2 & 1) != 0)) {\n        fcn.14000d5b8(arg1_00, uVar6 & 0xffffffffffffff00 | 0x20, uVar7, arg1 + 0x28);\n    }\ncode_r0x00014000ef17:\n    fcn.140009a80(uStack48 ^ auStack104);\n    return;\n}\n",
        "token_count": 1732
    },
    "14000f5b": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint64_t fcn.14000f5b4(int64_t arg1, ulong arg2)\n\n{\n    int64_t iVar1;\n    uint *puVar2;\n    uint64_t uVar3;\n    uint32_t uVar4;\n    int64_t arg1_00;\n    \n    iVar1 = fcn.14000ef50(*(arg1 + 0x3c));\n    if (iVar1 == 1) {\n        *(arg1 + 0x20) = *(arg1 + 0x20) + 8;\n        if ((*(arg1 + 0x30) >> 4 & 1) == 0) {\n            uVar3 = *(*(arg1 + 0x20) + -8);\n        }\n        else {\n            uVar3 = *(*(arg1 + 0x20) + -8);\n        }\n    }\n    else if (iVar1 == 2) {\n        *(arg1 + 0x20) = *(arg1 + 0x20) + 8;\n        if ((*(arg1 + 0x30) >> 4 & 1) == 0) {\n            uVar3 = *(*(arg1 + 0x20) + -8);\n        }\n        else {\n            uVar3 = *(*(arg1 + 0x20) + -8);\n        }\n    }\n    else {\n        arg1_00 = iVar1 + -4;\n        if (arg1_00 == 0) {\n            *(arg1 + 0x20) = *(arg1 + 0x20) + 8;\n            if ((*(arg1 + 0x30) >> 4 & 1) == 0) {\n                uVar3 = *(*(arg1 + 0x20) + -8);\n            }\n            else {\n                uVar3 = *(*(arg1 + 0x20) + -8);\n            }\n        }\n        else {\n            if (arg1_00 != 4) {\n                puVar2 = fcn.140015850(arg1_00);\n                *puVar2 = 0x16;\n                uVar3 = fcn.140015730();\n                return uVar3 & 0xffffffffffffff00;\n            }\n            *(arg1 + 0x20) = *(arg1 + 0x20) + 8;\n            uVar3 = *(*(arg1 + 0x20) + -8);\n        }\n    }\n    uVar4 = *(arg1 + 0x30);\n    if (((uVar4 >> 4 & 1) != 0) && (uVar3 < 0)) {\n        uVar3 = -uVar3;\n        uVar4 = uVar4 | 0x40;\n        *(arg1 + 0x30) = uVar4;\n    }\n    if (*(arg1 + 0x38) < 0) {\n        *(arg1 + 0x38) = 1;\n    }\n    else {\n        *(arg1 + 0x30) = uVar4 & 0xfffffff7;\n        fcn.14000d0c0(arg1 + 0x58, *(arg1 + 0x38));\n    }\n    if (uVar3 == 0) {\n        *(arg1 + 0x30) = *(arg1 + 0x30) & 0xffffffdf;\n    }\n    *(arg1 + 0x54) = 0;\n    if (iVar1 == 8) {\n        fcn.14000d380(arg1, uVar3, arg2);\n    }\n    else {\n        fcn.14000d254(arg1, uVar3 & 0xffffffff, arg2);\n    }\n    uVar4 = *(arg1 + 0x30);\n    if (((uVar4 >> 7 & 1) != 0) && ((*(arg1 + 0x50) == 0 || (**(arg1 + 0x48) != '0')))) {\n        *(arg1 + 0x48) = *(arg1 + 0x48) + -1;\n        **(arg1 + 0x48) = 0x30;\n        *(arg1 + 0x50) = *(arg1 + 0x50) + 1;\n    }\n    return CONCAT71(uVar4 >> 0xf, 1);\n}\n",
        "token_count": 955
    },
    "14000f73": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint64_t fcn.14000f734(int64_t arg1, ulong arg2)\n\n{\n    int64_t iVar1;\n    uint *puVar2;\n    uint64_t uVar3;\n    uint32_t uVar4;\n    int64_t arg1_00;\n    \n    iVar1 = fcn.14000ef50(*(arg1 + 0x3c));\n    if (iVar1 == 1) {\n        *(arg1 + 0x20) = *(arg1 + 0x20) + 8;\n        if ((*(arg1 + 0x30) >> 4 & 1) == 0) {\n            uVar3 = *(*(arg1 + 0x20) + -8);\n        }\n        else {\n            uVar3 = *(*(arg1 + 0x20) + -8);\n        }\n    }\n    else if (iVar1 == 2) {\n        *(arg1 + 0x20) = *(arg1 + 0x20) + 8;\n        if ((*(arg1 + 0x30) >> 4 & 1) == 0) {\n            uVar3 = *(*(arg1 + 0x20) + -8);\n        }\n        else {\n            uVar3 = *(*(arg1 + 0x20) + -8);\n        }\n    }\n    else {\n        arg1_00 = iVar1 + -4;\n        if (arg1_00 == 0) {\n            *(arg1 + 0x20) = *(arg1 + 0x20) + 8;\n            if ((*(arg1 + 0x30) >> 4 & 1) == 0) {\n                uVar3 = *(*(arg1 + 0x20) + -8);\n            }\n            else {\n                uVar3 = *(*(arg1 + 0x20) + -8);\n            }\n        }\n        else {\n            if (arg1_00 != 4) {\n                puVar2 = fcn.140015850(arg1_00);\n                *puVar2 = 0x16;\n                uVar3 = fcn.140015730();\n                return uVar3 & 0xffffffffffffff00;\n            }\n            *(arg1 + 0x20) = *(arg1 + 0x20) + 8;\n            uVar3 = *(*(arg1 + 0x20) + -8);\n        }\n    }\n    uVar4 = *(arg1 + 0x30);\n    if (((uVar4 >> 4 & 1) != 0) && (uVar3 < 0)) {\n        uVar3 = -uVar3;\n        uVar4 = uVar4 | 0x40;\n        *(arg1 + 0x30) = uVar4;\n    }\n    if (*(arg1 + 0x38) < 0) {\n        *(arg1 + 0x38) = 1;\n    }\n    else {\n        *(arg1 + 0x30) = uVar4 & 0xfffffff7;\n        fcn.14000d168(arg1 + 0x58, *(arg1 + 0x38));\n    }\n    if (uVar3 == 0) {\n        *(arg1 + 0x30) = *(arg1 + 0x30) & 0xffffffdf;\n    }\n    *(arg1 + 0x54) = 1;\n    if (iVar1 == 8) {\n        fcn.14000d410(arg1, uVar3, arg2);\n    }\n    else {\n        fcn.14000d2dc(arg1, uVar3 & 0xffffffff, arg2);\n    }\n    uVar4 = *(arg1 + 0x30) >> 7;\n    uVar3 = uVar4;\n    if (((uVar4 & 1) != 0) && ((uVar3 = 0,  *(arg1 + 0x50) == 0 || (**(arg1 + 0x48) != 0x30)))) {\n        *(arg1 + 0x48) = *(arg1 + 0x48) + -2;\n        **(arg1 + 0x48) = 0x30;\n        *(arg1 + 0x50) = *(arg1 + 0x50) + 1;\n    }\n    return CONCAT71(uVar3 >> 8, 1);\n}\n",
        "token_count": 970
    },
    "14001422": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0001400140c1)\n// WARNING: Removing unreachable block (ram,0x0001400140ce)\n// WARNING: Removing unreachable block (ram,0x0001400140d8)\n// WARNING: Removing unreachable block (ram,0x0001400140e7)\n// WARNING: Removing unreachable block (ram,0x0001400140f2)\n// WARNING: Removing unreachable block (ram,0x0001400140fb)\n// WARNING: Removing unreachable block (ram,0x000140014104)\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.140014220(void)\n\n{\n    code *pcVar1;\n    uint auStackX16 [2];\n    int32_t aiStackX24 [2];\n    ulong var_28h;\n    uchar var_30h [4];\n    ulong var_2ch;\n    uint *var_20h;\n    int32_t *var_bp_18h;\n    ulong *var_bp_10h;\n    \n    aiStackX24[0] = 1;\n    auStackX16[0] = 0;\n    var_20h = auStackX16;\n    var_28h._0_1_ = 0;\n    var_bp_18h = aiStackX24;\n    var_bp_10h = &var_28h;\n    var_2ch._0_4_ = 2;\n    var_2ch._4_4_ = 2;\n    fcn.140013f9c(var_30h, &var_2ch + 4, &var_20h, &var_2ch);\n    if (aiStackX24[0] == 0) {\n        fcn.140014160(0);\n        pcVar1 = swi(3);\n        (*pcVar1)();\n        return;\n    }\n    return;\n}\n",
        "token_count": 409
    },
    "14001490": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nulong fcn.140014900(void)\n\n{\n    char cVar1;\n    ulong uVar2;\n    int64_t *piVar3;\n    bool bVar4;\n    \n    piVar3 = 0x14002bdd0;\n    do {\n        if ((*piVar3 != 0) && (cVar1 = (**0x140025338)(),  cVar1 == '\\0')) break;\n        piVar3 = piVar3 + 2;\n    } while (piVar3 != 0x14002bed0);\n    if (piVar3 == 0x14002bed0) {\n        uVar2 = 1;\n    }\n    else {\n        if (piVar3 != 0x14002bdd0) {\n            piVar3 = piVar3 + -1;\n            do {\n                if ((piVar3[-1] != 0) && (*piVar3 != 0)) {\n                    (**0x140025338)(0);\n                }\n                bVar4 = piVar3 != 0x14002bdd8;\n                piVar3 = piVar3 + -2;\n            } while (bVar4);\n        }\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 268
    },
    "14001849": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1"
        ],
        "decompiled_code": "\nint32_t fcn.14001849c(uint16_t *arg1, uint8_t *arg2, uint64_t arg3, ulong arg4)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    int64_t iStack40;\n    uint64_t auStack32 [2];\n    char cStack16;\n    \n    if ((arg2 == NULL) || (arg3 == 0)) {\n        *0x140046fd0 = 0;\n        return 0;\n    }\n    if (*arg2 == 0) {\n        if (arg1 == NULL) {\n            return 0;\n        }\n        *arg1 = 0;\n        return 0;\n    }\n    fcn.14000d630(&iStack40, arg4);\n    if (*(auStack32[0] + 0xc) == 0xfde9) {\n        iVar1 = fcn.14001ab14(arg1);\n        if (iVar1 < 0) {\n            iVar1 = -1;\n        }\n        goto code_r0x000140018539;\n    }\n    if (*(auStack32[0] + 0x138) == 0) {\n        if (arg1 != NULL) {\n            *arg1 = *arg2;\n        }\ncode_r0x000140018534:\n        iVar1 = 1;\n    }\n    else {\n        iVar1 = fcn.14001aac8(*arg2, auStack32);\n        if (iVar1 == 0) {\n            auStack32[0] = *(auStack32[0] + 0xc);\n            iVar1 = fcn.140019e98(auStack32[0], 9);\n            if (iVar1 != 0) goto code_r0x000140018534;\n        }\n        else if ((((1 < *(auStack32[0] + 8)) && (*(auStack32[0] + 8) <= arg3)) &&\n                 (iVar1 = fcn.140019e98(*(auStack32[0] + 0xc), 9),  iVar1 != 0)) ||\n                ((*(auStack32[0] + 8) <= arg3 && (arg2[1] != 0)))) {\n            iVar1 = *(auStack32[0] + 8);\n            goto code_r0x000140018539;\n        }\n        puVar2 = fcn.140015850(auStack32[0]);\n        iVar1 = -1;\n        *puVar2 = 0x2a;\n    }\ncode_r0x000140018539:\n    if (cStack16 != '\\0') {\n        *(iStack40 + 0x3a8) = *(iStack40 + 0x3a8) & 0xfffffffd;\n        return iVar1;\n    }\n    return iVar1;\n}\n",
        "token_count": 617
    },
    "140019d2": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\n// WARNING: Possible PIC construction at 0x000140019dd4: Changing call to branch\n// WARNING: Removing unreachable block (ram,0x000140019dd9)\n\nint32_t fcn.140019d28(uint16_t *arg1, uint16_t *arg2)\n\n{\n    uint16_t uVar1;\n    uint16_t uVar2;\n    uint *puVar3;\n    uint32_t uVar4;\n    uint64_t uVar5;\n    int64_t iVar6;\n    int32_t iVar7;\n    uint32_t uVar8;\n    int64_t iStack56;\n    int64_t iStack48;\n    char cStack32;\n    \n    if (*0x1400469b4 != 0) {\n        if ((arg1 == NULL) || (arg2 == NULL)) {\n            puVar3 = fcn.140015850(arg1);\n            *puVar3 = 0x16;\n            fcn.140015730();\n            iVar7 = 0x7fffffff;\n        }\n        else {\n            fcn.14000d630(&stack0xffffffffffffffc8, 0);\n            iVar6 = iStack48;\n            if (*(iStack48 + 0x138) == 0) goto code_r0x000140019cee;\n            do {\n                if (*arg1 < 0x100) {\n                    uVar5 = *arg1;\n                    if ((*(\n                          L\"         (((((                  H\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x10\\x10\\x10\\x10\\x10\\x10\\x10\u0181\u0181\u0181\u0181\u0181\u0181\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\\x10\\x10\\x10\\x10\\x10\\x10\u0182\u0182\u0182\u0182\u0182\u0182\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\\x10\\x10\\x10\\x10      (                          \\b\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\u0112\\x10\\x100\\x10\\x10\\x10\\x10\\x14\\x14\\x10\u0112\\x10\\x10\\x10\\x14\u0112\\x10\\x10\\x10\\x10\\x10\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\\x10\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\\x10\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0101uk\"\n                          + uVar5) & 1) != 0) {\n                        uVar5 = *(uVar5 + *(iVar6 + 0x110));\n                    }\n                    uVar1 = uVar5;\n                }\n                else {\n                    uVar1 = fcn.14001f6cc(*arg1, &stack0xffffffffffffffd0);\n                    iVar6 = iStack48;\n                }\n                arg1 = arg1 + 1;\n                if (*arg2 < 0x100) {\n                    uVar5 = *arg2;\n                    if ((*(\n                          L\"         (((((                  H\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x84\\x10\\x10\\x10\\x10\\x10\\x10\\x10\u0181\u0181\u0181\u0181\u0181\u0181\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\\x10\\x10\\x10\\x10\\x10\\x10\u0182\u0182\u0182\u0182\u0182\u0182\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\\x10\\x10\\x10\\x10      (                          \\b\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\u0112\\x10\\x100\\x10\\x10\\x10\\x10\\x14\\x14\\x10\u0112\\x10\\x10\\x10\\x14\u0112\\x10\\x10\\x10\\x10\\x10\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0101\\x10\u0101\u0101\u0101\u0101\u0101\u0101\u0101\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\\x10\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0102\u0101uk\"\n                          + uVar5) & 1) != 0) {\n                        uVar5 = *(uVar5 + *(iVar6 + 0x110));\n                    }\n                    uVar2 = uVar5;\n                }\n                else {\n                    uVar2 = fcn.14001f6cc(*arg2, &stack0xffffffffffffffd0);\n                    iVar6 = iStack48;\n                }\n                arg2 = arg2 + 1;\n                iVar7 = uVar1 - uVar2;\n            } while ((iVar7 == 0) && (uVar1 != 0));\n            if (cStack32 != '\\0') {\n                *(iStack56 + 0x3a8) = *(iStack56 + 0x3a8) & 0xfffffffd;\n            }\n        }\n        return iVar7;\n    }\n    if ((arg1 == NULL) || (arg2 == NULL)) {\n        iStack48 = 0x140019d3f;\n        puVar3 = fcn.140015850(arg1);\n        *puVar3 = 0x16;\n        iStack48 = 0x140019d4a;\n        fcn.140015730();\n        return 0x7fffffff;\n    }\ncode_r0x000140019cee:\n    do {\n        uVar1 = *arg1;\n        arg1 = arg1 + 1;\n        uVar2 = *arg2;\n        arg2 = arg2 + 1;\n        uVar8 = uVar1 + 0x20;\n        if (0x19 < uVar1 - 0x41) {\n            uVar8 = uVar1;\n        }\n        uVar4 = uVar2 + 0x20;\n        if (0x19 < uVar2 - 0x41) {\n            uVar4 = uVar2;\n        }\n    } while ((uVar8 - uVar4 == 0) && (uVar8 != 0));\n    return uVar8 - uVar4;\n}\n",
        "token_count": 1548
    },
    "14002337": {
        "rules": [
            "check Internet connectivity via WinINet/46117370ea204ccbaff71c7a54b55d32",
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check OS version/c2d5920d27eb4726b54299bacf904e17"
        ],
        "decompiled_code": "\nuint32_t fcn.140023374(ulong arg1, ulong arg2)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint64_t arg1_00;\n    uint32_t uVar3;\n    \n    uVar1 = fcn.1400239f0();\n    uVar3 = uVar1 >> 3 & 0x10;\n    uVar2 = uVar3 | 8;\n    if ((uVar1 & 0x200) == 0) {\n        uVar2 = uVar3;\n    }\n    uVar3 = uVar2 | 4;\n    if ((uVar1 & 0x400) == 0) {\n        uVar3 = uVar2;\n    }\n    uVar2 = uVar3 | 2;\n    if ((uVar1 & 0x800) == 0) {\n        uVar2 = uVar3;\n    }\n    uVar3 = uVar2 | 1;\n    if ((uVar1 & 0x1000) == 0) {\n        uVar3 = uVar2;\n    }\n    uVar2 = uVar3 | 0x80000;\n    if ((uVar1 & 0x100) == 0) {\n        uVar2 = uVar3;\n    }\n    uVar3 = uVar1 & 0x6000;\n    if (uVar3 != 0) {\n        if (uVar3 == 0x2000) {\n            uVar2 = uVar2 | 0x100;\n        }\n        else if (uVar3 == 0x4000) {\n            uVar2 = uVar2 | 0x200;\n        }\n        else if (uVar3 == 0x6000) {\n            uVar2 = uVar2 | 0x300;\n        }\n    }\n    uVar1 = uVar1 & 0x8040;\n    if (uVar1 == 0x40) {\n        uVar2 = uVar2 | 0x2000000;\n    }\n    else if (uVar1 == 0x8000) {\n        uVar2 = uVar2 | 0x3000000;\n    }\n    else if (uVar1 == 0x8040) {\n        uVar2 = uVar2 | 0x1000000;\n    }\n    uVar1 = ~(arg2 & 0x308031f) & uVar2 | arg1 & arg2 & 0x308031f;\n    if (uVar1 != uVar2) {\n        uVar3 = (uVar1 & 0x10) << 3;\n        uVar2 = uVar3 | 0x200;\n        if ((uVar1 & 8) == 0) {\n            uVar2 = uVar3;\n        }\n        uVar3 = uVar2 | 0x400;\n        if ((uVar1 & 4) == 0) {\n            uVar3 = uVar2;\n        }\n        uVar2 = uVar3 | 0x800;\n        if ((uVar1 & 2) == 0) {\n            uVar2 = uVar3;\n        }\n        uVar3 = uVar2 | 0x1000;\n        if ((uVar1 & 1) == 0) {\n            uVar3 = uVar2;\n        }\n        uVar2 = uVar3 | 0x100;\n        if ((uVar1 & 0x80000) == 0) {\n            uVar2 = uVar3;\n        }\n        arg1_00 = uVar2;\n        uVar3 = uVar1 & 0x300;\n        if (uVar3 != 0) {\n            if (uVar3 == 0x100) {\n                arg1_00 = uVar2 | 0x2000;\n            }\n            else if (uVar3 == 0x200) {\n                arg1_00 = uVar2 | 0x4000;\n            }\n            else if (uVar3 == 0x300) {\n                arg1_00 = uVar2 | 0x6000;\n            }\n        }\n        uVar1 = uVar1 & 0x3000000;\n        uVar2 = arg1_00;\n        if (uVar1 == 0x1000000) {\n            arg1_00 = uVar2 | 0x8040;\n        }\n        else if (uVar1 == 0x2000000) {\n            arg1_00 = uVar2 | 0x40;\n        }\n        else if (uVar1 == 0x3000000) {\n            arg1_00 = uVar2 | 0x8000;\n        }\n        if ((*0x140037c00 == '\\0') || ((arg1_00 & 0x40) == 0)) {\n            arg1_00 = arg1_00 & 0xffffffbf;\n            fcn.140023a00(arg1_00);\n        }\n        else {\n            fcn.140023a00(arg1_00);\n        }\n        uVar1 = arg1_00 >> 3 & 0x10;\n        uVar2 = uVar1 | 8;\n        if ((arg1_00 & 0x200) == 0) {\n            uVar2 = uVar1;\n        }\n        uVar1 = uVar2 | 4;\n        if ((arg1_00 & 0x400) == 0) {\n            uVar1 = uVar2;\n        }\n        uVar2 = uVar1 | 2;\n        if ((arg1_00 & 0x800) == 0) {\n            uVar2 = uVar1;\n        }\n        uVar1 = uVar2 | 1;\n        if ((arg1_00 & 0x1000) == 0) {\n            uVar1 = uVar2;\n        }\n        uVar2 = uVar1 | 0x80000;\n        if ((arg1_00 & 0x100) == 0) {\n            uVar2 = uVar1;\n        }\n        uVar1 = arg1_00 & 0x6000;\n        if ((arg1_00 & 0x6000) != 0) {\n            if (uVar1 == 0x2000) {\n                uVar2 = uVar2 | 0x100;\n            }\n            else if (uVar1 == 0x4000) {\n                uVar2 = uVar2 | 0x200;\n            }\n            else if (uVar1 == 0x6000) {\n                uVar2 = uVar2 | 0x300;\n            }\n        }\n        uVar1 = arg1_00 & 0x8040;\n        if (uVar1 == 0x40) {\n            uVar2 = uVar2 | 0x2000000;\n        }\n        else if (uVar1 == 0x8000) {\n            uVar2 = uVar2 | 0x3000000;\n        }\n        else if (uVar1 == 0x8040) {\n            uVar2 = uVar2 | 0x1000000;\n        }\n    }\n    return uVar2;\n}\n",
        "token_count": 1605
    },
    "14000c1c": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nuint fcn.14000c1c0(int64_t arg1, ulong arg2, ulong arg3)\n\n{\n    uint uVar1;\n    uint *puVar2;\n    \n    if ((arg1 == 0) || (2 < arg3)) {\n        puVar2 = fcn.140015850(arg1);\n        *puVar2 = 0x16;\n        fcn.140015730();\n        uVar1 = 0xffffffff;\n    }\n    else {\n        fcn.14000cbc0(arg1);\n        uVar1 = fcn.14000c108(arg1, arg2, arg3);\n        fcn.14000cbcc(arg1);\n    }\n    return uVar1;\n}\n",
        "token_count": 156
    },
    "1400123f": {
        "rules": [
            "check OS version/730896de213f42198ce3af1d0fc93fbe",
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check if file exists/0479f02c3c8a4099bfdd7ca8c1e3802e/20122460e93841beb56e12792b6a4896"
        ],
        "decompiled_code": "\nvoid fcn.1400123f0(int64_t arg1, int32_t *arg2)\n\n{\n    code *pcVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    int64_t iVar5;\n    ulong uVar6;\n    uchar auStack664 [32];\n    ulong uStack632;\n    uint uStack624;\n    int32_t iStack616;\n    uchar auStack612 [8];\n    uchar auStack604 [8];\n    uchar auStack596 [12];\n    int32_t iStack584;\n    uchar auStack572 [548];\n    uint64_t uStack24;\n    \n    uStack24 = *0x140037018 ^ auStack664;\n    if ((arg2 == NULL) || (arg1 == 0)) {\n        puVar4 = fcn.140015850(arg1);\n        *puVar4 = 0x16;\n        fcn.140015730();\n        goto code_r0x00014001210a;\n    }\n    uStack624 = 0;\n    uStack632 = 0;\n    iVar5 = (*_sym.imp.KERNEL32.dll_FindFirstFileExW)(arg1, 0, &iStack616, 0);\n    if (iVar5 != -1) {\n        if (iStack616 == 0x80) {\n            iStack616 = 0;\n        }\n        *arg2 = iStack616;\n        uVar6 = fcn.140012338(auStack612);\n        *(arg2 + 2) = uVar6;\n        uVar6 = fcn.140012338(auStack604);\n        *(arg2 + 4) = uVar6;\n        uVar6 = fcn.140012338(auStack596);\n        *(arg2 + 6) = uVar6;\n        arg2[8] = iStack584;\n        iVar3 = fcn.14001aebc(arg2 + 9, 0x104, auStack572);\n        if (iVar3 != 0) {\n            uStack632 = 0;\n            fcn.140015750(0, 0, 0, 0);\n            pcVar1 = swi(3);\n            (*pcVar1)();\n            return;\n        }\n        goto code_r0x00014001210a;\n    }\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n    if (uVar2 < 2) {\ncode_r0x000140012170:\n        puVar4 = fcn.140015850(arg1);\n        *puVar4 = 0x16;\n    }\n    else {\n        if (3 < uVar2) {\n            if (uVar2 == 8) {\n                puVar4 = fcn.140015850(arg1);\n                *puVar4 = 0xc;\n                goto code_r0x00014001210a;\n            }\n            if (uVar2 != 0x12) goto code_r0x000140012170;\n        }\n        puVar4 = fcn.140015850(arg1);\n        *puVar4 = 2;\n    }\ncode_r0x00014001210a:\n    fcn.140009a80(uStack24 ^ auStack664);\n    return;\n}\n",
        "token_count": 714
    },
    "14000a79": {
        "rules": [
            "check OS version/eb1d2d86c0084793ad233d63869572f1",
            "check for software breakpoints/6dbbe1bd09a145a7938dedb5765a94dc"
        ],
        "decompiled_code": "\nuchar (*) [32] fcn.14000a790(uchar (*arg1) [32], uchar (*arg2) [32], uint64_t arg3)\n\n{\n    uint *puVar1;\n    uchar uVar2;\n    ushort uVar3;\n    uint uVar4;\n    uint uVar5;\n    uint uVar6;\n    uint uVar7;\n    uint uVar8;\n    uint uVar9;\n    uint uVar10;\n    uint uVar11;\n    uint uVar12;\n    uint uVar13;\n    uint uVar14;\n    uchar (*pauVar15) [32];\n    uchar (*pauVar16) [32];\n    uchar (*pauVar17) [32];\n    uint *puVar18;\n    uint *puVar19;\n    uchar (*pauVar20) [32];\n    uint *puVar21;\n    uint64_t uVar22;\n    int64_t iVar23;\n    uint64_t uVar24;\n    uint uVar25;\n    uint uVar27;\n    uint uVar28;\n    uint uVar29;\n    uchar auVar26 [32];\n    uchar auVar30 [32];\n    uchar auVar31 [32];\n    uchar auVar32 [32];\n    uchar auVar33 [32];\n    uchar auVar34 [32];\n    \n    pauVar15 = arg1;\n    if (arg3 < 0x10) {\n    // switch table (16 cases) at 0x14004a000\n        switch(*(arg3 * 4 + 0x14004a000) + 0x140000000) {\n        case 0x14000a7be:\n            return pauVar15;\n        case 0x14000a7c0:\n            uVar4 = *(*arg2 + 8);\n            uVar3 = *(*arg2 + 0xc);\n            uVar2 = (*arg2)[0xe];\n            **arg1 = **arg2;\n            *(*arg1 + 8) = uVar4;\n            *(*arg1 + 0xc) = uVar3;\n            (*arg1)[0xe] = uVar2;\n            return pauVar15;\n        case 0x14000a7e0:\n            uVar3 = *(*arg2 + 8);\n            uVar2 = (*arg2)[10];\n            **arg1 = **arg2;\n            *(*arg1 + 8) = uVar3;\n            (*arg1)[10] = uVar2;\n            return pauVar15;\n        case 0x14000a7f8:\n            **arg1 = **arg2;\n            return pauVar15;\n        case 0x14000a800:\n            uVar3 = *(*arg2 + 4);\n            uVar2 = (*arg2)[6];\n            **arg1 = **arg2;\n            *(*arg1 + 4) = uVar3;\n            (*arg1)[6] = uVar2;\n            return pauVar15;\n        case 0x14000a818:\n            uVar4 = *(*arg2 + 8);\n            uVar3 = *(*arg2 + 0xc);\n            **arg1 = **arg2;\n            *(*arg1 + 8) = uVar4;\n            *(*arg1 + 0xc) = uVar3;\n            return pauVar15;\n        case 0x14000a82f:\n            uVar2 = (*arg2)[2];\n            **arg1 = **arg2;\n            (*arg1)[2] = uVar2;\n            return pauVar15;\n        case 0x14000a840:\n            uVar4 = *(*arg2 + 8);\n            uVar2 = (*arg2)[0xc];\n            **arg1 = **arg2;\n            *(*arg1 + 8) = uVar4;\n            (*arg1)[0xc] = uVar2;\n            return pauVar15;\n        case 0x14000a856:\n            uVar3 = *(*arg2 + 8);\n            **arg1 = **arg2;\n            *(*arg1 + 8) = uVar3;\n            return pauVar15;\n        case 0x14000a865:\n            uVar2 = (*arg2)[8];\n            **arg1 = **arg2;\n            (*arg1)[8] = uVar2;\n            return pauVar15;\n        case 0x14000a873:\n            uVar4 = *(*arg2 + 8);\n            **arg1 = **arg2;\n            *(*arg1 + 8) = uVar4;\n            return pauVar15;\n        case 0x14000a880:\n            uVar3 = *(*arg2 + 4);\n            **arg1 = **arg2;\n            *(*arg1 + 4) = uVar3;\n            return pauVar15;\n        case 0x14000a88f:\n            uVar2 = (*arg2)[4];\n            **arg1 = **arg2;\n            (*arg1)[4] = uVar2;\n            return pauVar15;\n        case 0x14000a89d:\n            **arg1 = **arg2;\n            return pauVar15;\n        case 0x14000a8a4:\n            (*arg1)[0] = (*arg2)[0];\n            return pauVar15;\n        case 0x14000a8aa:\n            **arg1 = **arg2;\n            return pauVar15;\n        }\n    }\n    if (arg3 < 0x21) {\n        uVar4 = *(*arg2 + 4);\n        uVar5 = *(*arg2 + 8);\n        uVar6 = *(*arg2 + 0xc);\n        puVar18 = arg2[-1] + arg3 + 0x10;\n        uVar25 = *puVar18;\n        uVar27 = puVar18[1];\n        uVar28 = puVar18[2];\n        uVar29 = puVar18[3];\n        **arg1 = **arg2;\n        *(*arg1 + 4) = uVar4;\n        *(*arg1 + 8) = uVar5;\n        *(*arg1 + 0xc) = uVar6;\n        puVar18 = arg1[-1] + arg3 + 0x10;\n        *puVar18 = uVar25;\n        puVar18[1] = uVar27;\n        puVar18[2] = uVar28;\n        puVar18[3] = uVar29;\n        return pauVar15;\n    }\n    if ((arg2 < arg1) && (arg1 < *arg2 + arg3)) {\n        iVar23 = arg2 - arg1;\n        puVar18 = arg1 + iVar23 + (arg3 - 0x10);\n        uVar4 = puVar18[1];\n        uVar5 = puVar18[2];\n        uVar6 = puVar18[3];\n        puVar19 = arg1[-1] + arg3 + 0x10;\n        uVar22 = arg3 - 0x10;\n        puVar21 = puVar19;\n        uVar25 = *puVar18;\n        uVar27 = uVar4;\n        uVar28 = uVar5;\n        uVar29 = uVar6;\n        if ((puVar19 & 0xf) != 0) {\n            puVar21 = puVar19 & 0xfffffffffffffff0;\n            puVar1 = puVar21 + iVar23;\n            uVar25 = *puVar1;\n            uVar27 = puVar1[1];\n            uVar28 = puVar1[2];\n            uVar29 = puVar1[3];\n            *puVar19 = *puVar18;\n            *(arg1[-1] + arg3 + 0x14) = uVar4;\n            *(arg1[-1] + arg3 + 0x18) = uVar5;\n            *(arg1[-1] + arg3 + 0x1c) = uVar6;\n            uVar22 = puVar21 - arg1;\n        }\n        uVar24 = uVar22 >> 7;\n        if (uVar24 != 0) {\n            *puVar21 = uVar25;\n            puVar21[1] = uVar27;\n            puVar21[2] = uVar28;\n            puVar21[3] = uVar29;\n            puVar18 = puVar21;\n            while( true ) {\n                puVar19 = puVar18 + iVar23 + -0x10;\n                uVar4 = puVar19[1];\n                uVar5 = puVar19[2];\n                uVar6 = puVar19[3];\n                puVar21 = puVar18 + iVar23 + -0x20;\n                uVar25 = *puVar21;\n                uVar27 = puVar21[1];\n                uVar28 = puVar21[2];\n                uVar29 = puVar21[3];\n                puVar21 = puVar18 + -0x20;\n                puVar18[-4] = *puVar19;\n                puVar18[-3] = uVar4;\n                puVar18[-2] = uVar5;\n                puVar18[-1] = uVar6;\n                puVar18[-8] = uVar25;\n                puVar18[-7] = uVar27;\n                puVar18[-6] = uVar28;\n                puVar18[-5] = uVar29;\n                puVar19 = puVar18 + iVar23 + -0x30;\n                uVar4 = puVar19[1];\n                uVar5 = puVar19[2];\n                uVar6 = puVar19[3];\n                puVar1 = puVar18 + iVar23 + -0x40;\n                uVar25 = *puVar1;\n                uVar27 = puVar1[1];\n                uVar28 = puVar1[2];\n                uVar29 = puVar1[3];\n                uVar24 = uVar24 - 1;\n                puVar18[-0xc] = *puVar19;\n                puVar18[-0xb] = uVar4;\n                puVar18[-10] = uVar5;\n                puVar18[-9] = uVar6;\n                puVar18[-0x10] = uVar25;\n                puVar18[-0xf] = uVar27;\n                puVar18[-0xe] = uVar28;\n                puVar18[-0xd] = uVar29;\n                puVar19 = puVar18 + iVar23 + -0x50;\n                uVar4 = puVar19[1];\n                uVar5 = puVar19[2];\n                uVar6 = puVar19[3];\n                puVar1 = puVar18 + iVar23 + -0x60;\n                uVar25 = *puVar1;\n                uVar27 = puVar1[1];\n                uVar28 = puVar1[2];\n                uVar29 = puVar1[3];\n                puVar18[-0x14] = *puVar19;\n                puVar18[-0x13] = uVar4;\n                puVar18[-0x12] = uVar5;\n                puVar18[-0x11] = uVar6;\n                puVar18[-0x18] = uVar25;\n                puVar18[-0x17] = uVar27;\n                puVar18[-0x16] = uVar28;\n                puVar18[-0x15] = uVar29;\n                puVar1 = puVar18 + iVar23 + -0x70;\n                uVar4 = puVar1[1];\n                uVar5 = puVar1[2];\n                uVar6 = puVar1[3];\n                puVar19 = puVar21 + iVar23;\n                uVar25 = *puVar19;\n                uVar27 = puVar19[1];\n                uVar28 = puVar19[2];\n                uVar29 = puVar19[3];\n                if (uVar24 == 0) break;\n                puVar18[-0x1c] = *puVar1;\n                puVar18[-0x1b] = uVar4;\n                puVar18[-0x1a] = uVar5;\n                puVar18[-0x19] = uVar6;\n                *puVar21 = uVar25;\n                puVar18[-0x1f] = uVar27;\n                puVar18[-0x1e] = uVar28;\n                puVar18[-0x1d] = uVar29;\n                puVar18 = puVar21;\n            }\n            puVar18[-0x1c] = *puVar1;\n            puVar18[-0x1b] = uVar4;\n            puVar18[-0x1a] = uVar5;\n            puVar18[-0x19] = uVar6;\n            uVar22 = uVar22 & 0x7f;\n        }\n        for (uVar24 = uVar22 >> 4; uVar24 != 0; uVar24 = uVar24 - 1) {\n            *puVar21 = uVar25;\n            puVar21[1] = uVar27;\n            puVar21[2] = uVar28;\n            puVar21[3] = uVar29;\n            puVar21 = puVar21 + -4;\n            puVar18 = puVar21 + iVar23;\n            uVar25 = *puVar18;\n            uVar27 = puVar18[1];\n            uVar28 = puVar18[2];\n            uVar29 = puVar18[3];\n        }\n        if ((uVar22 & 0xf) != 0) {\n            uVar4 = *(*arg2 + 4);\n            uVar5 = *(*arg2 + 8);\n            uVar6 = *(*arg2 + 0xc);\n            **arg1 = **arg2;\n            *(*arg1 + 4) = uVar4;\n            *(*arg1 + 8) = uVar5;\n            *(*arg1 + 0xc) = uVar6;\n        }\n        *puVar21 = uVar25;\n        puVar21[1] = uVar27;\n        puVar21[2] = uVar28;\n        puVar21[3] = uVar29;\n        return arg1;\n    }\n    if (*0x140037028 < 3) {\n        if ((arg3 < 0x801) || ((*0x140046578 & 2) == 0)) {\n            if (0x80 < arg3) {\n                iVar23 = (arg1 & 0xf) - 0x10;\n                puVar18 = arg1 - iVar23;\n                puVar21 = arg2 - iVar23;\n                arg3 = arg3 + iVar23;\n                if (0x80 < arg3) {\n                    do {\n                        uVar4 = puVar21[1];\n                        uVar5 = puVar21[2];\n                        uVar6 = puVar21[3];\n                        uVar25 = puVar21[4];\n                        uVar27 = puVar21[5];\n                        uVar28 = puVar21[6];\n                        uVar29 = puVar21[7];\n                        uVar7 = puVar21[8];\n                        uVar8 = puVar21[9];\n                        uVar9 = puVar21[10];\n                        uVar10 = puVar21[0xb];\n                        uVar11 = puVar21[0xc];\n                        uVar12 = puVar21[0xd];\n                        uVar13 = puVar21[0xe];\n                        uVar14 = puVar21[0xf];\n                        *puVar18 = *puVar21;\n                        puVar18[1] = uVar4;\n                        puVar18[2] = uVar5;\n                        puVar18[3] = uVar6;\n                        puVar18[4] = uVar25;\n                        puVar18[5] = uVar27;\n                        puVar18[6] = uVar28;\n                        puVar18[7] = uVar29;\n                        puVar18[8] = uVar7;\n                        puVar18[9] = uVar8;\n                        puVar18[10] = uVar9;\n                        puVar18[0xb] = uVar10;\n                        puVar18[0xc] = uVar11;\n                        puVar18[0xd] = uVar12;\n                        puVar18[0xe] = uVar13;\n                        puVar18[0xf] = uVar14;\n                        uVar4 = puVar21[0x11];\n                        uVar5 = puVar21[0x12];\n                        uVar6 = puVar21[0x13];\n                        uVar25 = puVar21[0x14];\n                        uVar27 = puVar21[0x15];\n                        uVar28 = puVar21[0x16];\n                        uVar29 = puVar21[0x17];\n                        uVar7 = puVar21[0x18];\n                        uVar8 = puVar21[0x19];\n                        uVar9 = puVar21[0x1a];\n                        uVar10 = puVar21[0x1b];\n                        uVar11 = puVar21[0x1c];\n                        uVar12 = puVar21[0x1d];\n                        uVar13 = puVar21[0x1e];\n                        uVar14 = puVar21[0x1f];\n                        puVar18[0x10] = puVar21[0x10];\n                        puVar18[0x11] = uVar4;\n                        puVar18[0x12] = uVar5;\n                        puVar18[0x13] = uVar6;\n                        puVar18[0x14] = uVar25;\n                        puVar18[0x15] = uVar27;\n                        puVar18[0x16] = uVar28;\n                        puVar18[0x17] = uVar29;\n                        puVar18[0x18] = uVar7;\n                        puVar18[0x19] = uVar8;\n                        puVar18[0x1a] = uVar9;\n                        puVar18[0x1b] = uVar10;\n                        puVar18[0x1c] = uVar11;\n                        puVar18[0x1d] = uVar12;\n                        puVar18[0x1e] = uVar13;\n                        puVar18[0x1f] = uVar14;\n                        puVar18 = puVar18 + 0x20;\n                        puVar21 = puVar21 + 0x20;\n                        arg3 = arg3 - 0x80;\n                    } while (0x7f < arg3);\n                }\n            }\n    // WARNING: Could not recover jumptable at 0x00014000aca6. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (9 cases) at 0x14004a088\n            pauVar15 = (*(*((arg3 + 0xf >> 4) * 4 + 0x14004a088) + 0x140000000))();\n            return pauVar15;\n        }\n    }\n    else if (((arg3 < 0x2001) || (0x180000 < arg3)) || ((*0x140046578 & 2) == 0)) {\n        auVar26 = vmovdqu_avx(*arg2);\n        auVar34 = vmovdqu_avx(*(arg2[-1] + arg3));\n        if (0x100 < arg3) {\n            iVar23 = (arg1 & 0x1f) - 0x20;\n            pauVar16 = arg1 - iVar23;\n            arg2 = arg2 - iVar23;\n            arg3 = arg3 + iVar23;\n            if (0x100 < arg3) {\n                if (0x180000 < arg3) {\n                    do {\n                        uVar22 = arg3;\n                        pauVar20 = arg2;\n                        pauVar17 = pauVar16;\n                        auVar30 = vmovdqu_avx(*pauVar20);\n                        auVar31 = vmovdqu_avx(pauVar20[1]);\n                        auVar32 = vmovdqu_avx(pauVar20[2]);\n                        auVar33 = vmovdqu_avx(pauVar20[3]);\n                        auVar30 = vmovntdq_avx(auVar30);\n                        *pauVar17 = auVar30;\n                        auVar30 = vmovntdq_avx(auVar31);\n                        pauVar17[1] = auVar30;\n                        auVar30 = vmovntdq_avx(auVar32);\n                        pauVar17[2] = auVar30;\n                        auVar30 = vmovntdq_avx(auVar33);\n                        pauVar17[3] = auVar30;\n                        auVar30 = vmovdqu_avx(pauVar20[4]);\n                        auVar31 = vmovdqu_avx(pauVar20[5]);\n                        auVar32 = vmovdqu_avx(pauVar20[6]);\n                        auVar33 = vmovdqu_avx(pauVar20[7]);\n                        auVar30 = vmovntdq_avx(auVar30);\n                        pauVar17[4] = auVar30;\n                        auVar30 = vmovntdq_avx(auVar31);\n                        pauVar17[5] = auVar30;\n                        auVar30 = vmovntdq_avx(auVar32);\n                        pauVar17[6] = auVar30;\n                        auVar30 = vmovntdq_avx(auVar33);\n                        pauVar17[7] = auVar30;\n                        pauVar16 = pauVar17[8];\n                        arg2 = pauVar20[8];\n                        arg3 = uVar22 - 0x100;\n                    } while (0xff < uVar22 - 0x100);\n                    uVar24 = uVar22 - 0xe1 & 0xffffffffffffffe0;\n    // switch table (18 cases) at 0x14004a064\n                    switch(uVar22) {\n                    case 0x1e1:\n                    case 0x1e2:\n                    case 0x1e3:\n                    case 0x1e4:\n                    case 0x1e5:\n                    case 0x1e6:\n                    case 0x1e7:\n                    case 0x1e8:\n                    case 0x1e9:\n                    case 0x1ea:\n                    case 0x1eb:\n                    case 0x1ec:\n                    case 0x1ed:\n                    case 0x1ee:\n                    case 0x1ef:\n                    case 0x1f0:\n                    case 0x1f1:\n                    case 0x1f2:\n                    case 499:\n                    case 500:\n                    case 0x1f5:\n                    case 0x1f6:\n                    case 0x1f7:\n                    case 0x1f8:\n                    case 0x1f9:\n                    case 0x1fa:\n                    case 0x1fb:\n                    case 0x1fc:\n                    case 0x1fd:\n                    case 0x1fe:\n                    case 0x1ff:\n                        auVar30 = vmovdqu_avx(*(*pauVar20 + uVar24));\n                        auVar30 = vmovntdq_avx(auVar30);\n                        *(*pauVar17 + uVar24) = auVar30;\n                    case 0x1c1:\n                    case 0x1c2:\n                    case 0x1c3:\n                    case 0x1c4:\n                    case 0x1c5:\n                    case 0x1c6:\n                    case 0x1c7:\n                    case 0x1c8:\n                    case 0x1c9:\n                    case 0x1ca:\n                    case 0x1cb:\n                    case 0x1cc:\n                    case 0x1cd:\n                    case 0x1ce:\n                    case 0x1cf:\n                    case 0x1d0:\n                    case 0x1d1:\n                    case 0x1d2:\n                    case 0x1d3:\n                    case 0x1d4:\n                    case 0x1d5:\n                    case 0x1d6:\n                    case 0x1d7:\n                    case 0x1d8:\n                    case 0x1d9:\n                    case 0x1da:\n                    case 0x1db:\n                    case 0x1dc:\n                    case 0x1dd:\n                    case 0x1de:\n                    case 0x1df:\n                    case 0x1e0:\n                        auVar30 = vmovdqu_avx(*(pauVar20[1] + uVar24));\n                        auVar30 = vmovntdq_avx(auVar30);\n                        *(pauVar17[1] + uVar24) = auVar30;\n                    case 0x1a1:\n                    case 0x1a2:\n                    case 0x1a3:\n                    case 0x1a4:\n                    case 0x1a5:\n                    case 0x1a6:\n                    case 0x1a7:\n                    case 0x1a8:\n                    case 0x1a9:\n                    case 0x1aa:\n                    case 0x1ab:\n                    case 0x1ac:\n                    case 0x1ad:\n                    case 0x1ae:\n                    case 0x1af:\n                    case 0x1b0:\n                    case 0x1b1:\n                    case 0x1b2:\n                    case 0x1b3:\n                    case 0x1b4:\n                    case 0x1b5:\n                    case 0x1b6:\n                    case 0x1b7:\n                    case 0x1b8:\n                    case 0x1b9:\n                    case 0x1ba:\n                    case 0x1bb:\n                    case 0x1bc:\n                    case 0x1bd:\n                    case 0x1be:\n                    case 0x1bf:\n                    case 0x1c0:\n                        auVar30 = vmovdqu_avx(*(pauVar20[2] + uVar24));\n                        auVar30 = vmovntdq_avx(auVar30);\n                        *(pauVar17[2] + uVar24) = auVar30;\n                    case 0x181:\n                    case 0x182:\n                    case 0x183:\n                    case 0x184:\n                    case 0x185:\n                    case 0x186:\n                    case 0x187:\n                    case 0x188:\n                    case 0x189:\n                    case 0x18a:\n                    case 0x18b:\n                    case 0x18c:\n                    case 0x18d:\n                    case 0x18e:\n                    case 399:\n                    case 400:\n                    case 0x191:\n                    case 0x192:\n                    case 0x193:\n                    case 0x194:\n                    case 0x195:\n                    case 0x196:\n                    case 0x197:\n                    case 0x198:\n                    case 0x199:\n                    case 0x19a:\n                    case 0x19b:\n                    case 0x19c:\n                    case 0x19d:\n                    case 0x19e:\n                    case 0x19f:\n                    case 0x1a0:\n                        auVar30 = vmovdqu_avx(*(pauVar20[3] + uVar24));\n                        auVar30 = vmovntdq_avx(auVar30);\n                        *(pauVar17[3] + uVar24) = auVar30;\n                    case 0x161:\n                    case 0x162:\n                    case 0x163:\n                    case 0x164:\n                    case 0x165:\n                    case 0x166:\n                    case 0x167:\n                    case 0x168:\n                    case 0x169:\n                    case 0x16a:\n                    case 0x16b:\n                    case 0x16c:\n                    case 0x16d:\n                    case 0x16e:\n                    case 0x16f:\n                    case 0x170:\n                    case 0x171:\n                    case 0x172:\n                    case 0x173:\n                    case 0x174:\n                    case 0x175:\n                    case 0x176:\n                    case 0x177:\n                    case 0x178:\n                    case 0x179:\n                    case 0x17a:\n                    case 0x17b:\n                    case 0x17c:\n                    case 0x17d:\n                    case 0x17e:\n                    case 0x17f:\n                    case 0x180:\n                        auVar30 = vmovdqu_avx(*(pauVar20[4] + uVar24));\n                        auVar30 = vmovntdq_avx(auVar30);\n                        *(pauVar17[4] + uVar24) = auVar30;\n                    case 0x141:\n                    case 0x142:\n                    case 0x143:\n                    case 0x144:\n                    case 0x145:\n                    case 0x146:\n                    case 0x147:\n                    case 0x148:\n                    case 0x149:\n                    case 0x14a:\n                    case 0x14b:\n                    case 0x14c:\n                    case 0x14d:\n                    case 0x14e:\n                    case 0x14f:\n                    case 0x150:\n                    case 0x151:\n                    case 0x152:\n                    case 0x153:\n                    case 0x154:\n                    case 0x155:\n                    case 0x156:\n                    case 0x157:\n                    case 0x158:\n                    case 0x159:\n                    case 0x15a:\n                    case 0x15b:\n                    case 0x15c:\n                    case 0x15d:\n                    case 0x15e:\n                    case 0x15f:\n                    case 0x160:\n                        auVar30 = vmovdqu_avx(*(pauVar20[5] + uVar24));\n                        auVar30 = vmovntdq_avx(auVar30);\n                        *(pauVar17[5] + uVar24) = auVar30;\n                    case 0x121:\n                    case 0x122:\n                    case 0x123:\n                    case 0x124:\n                    case 0x125:\n                    case 0x126:\n                    case 0x127:\n                    case 0x128:\n                    case 0x129:\n                    case 0x12a:\n                    case 299:\n                    case 300:\n                    case 0x12d:\n                    case 0x12e:\n                    case 0x12f:\n                    case 0x130:\n                    case 0x131:\n                    case 0x132:\n                    case 0x133:\n                    case 0x134:\n                    case 0x135:\n                    case 0x136:\n                    case 0x137:\n                    case 0x138:\n                    case 0x139:\n                    case 0x13a:\n                    case 0x13b:\n                    case 0x13c:\n                    case 0x13d:\n                    case 0x13e:\n                    case 0x13f:\n                    case 0x140:\n                        auVar30 = vmovdqu_avx(*(pauVar20[6] + uVar24));\n                        auVar30 = vmovntdq_avx(auVar30);\n                        *(pauVar17[6] + uVar24) = auVar30;\n                    default:\n                        auVar34 = vmovdqu_avx(auVar34);\n                        *(pauVar17[-1] + uVar22) = auVar34;\n                    case 0x100:\n                        auVar26 = vmovdqu_avx(auVar26);\n                        *arg1 = auVar26;\n                        vzeroupper_avx();\n                        return pauVar15;\n                    }\n                }\n                do {\n                    auVar34 = vmovdqu_avx(*arg2);\n                    auVar30 = vmovdqu_avx(arg2[1]);\n                    auVar31 = vmovdqu_avx(arg2[2]);\n                    auVar32 = vmovdqu_avx(arg2[3]);\n                    *pauVar16 = auVar34;\n                    pauVar16[1] = auVar30;\n                    pauVar16[2] = auVar31;\n                    pauVar16[3] = auVar32;\n                    auVar34 = vmovdqu_avx(arg2[4]);\n                    auVar30 = vmovdqu_avx(arg2[5]);\n                    auVar31 = vmovdqu_avx(arg2[6]);\n                    auVar32 = vmovdqu_avx(arg2[7]);\n                    pauVar16[4] = auVar34;\n                    pauVar16[5] = auVar30;\n                    pauVar16[6] = auVar31;\n                    pauVar16[7] = auVar32;\n                    pauVar16 = pauVar16[8];\n                    arg2 = arg2[8];\n                    arg3 = arg3 - 0x100;\n                } while (0xff < arg3);\n            }\n        }\n    // WARNING: Could not recover jumptable at 0x00014000aa02. Too many branches\n    // WARNING: Treating indirect jump as call\n    // switch table (27 cases) at 0x14004a040\n        pauVar15 = (*(*((arg3 + 0x1f >> 5) * 4 + 0x14004a040) + 0x140000000))(SUB328(auVar26, 0));\n        return pauVar15;\n    }\n    for (; arg3 != 0; arg3 = arg3 - 1) {\n        (*arg1)[0] = (*arg2)[0];\n        arg2 = *arg2 + 1;\n        arg1 = *arg1 + 1;\n    }\n    return pauVar15;\n}\n",
        "token_count": 7536
    },
    "1400068b": {
        "rules": [
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353"
        ],
        "decompiled_code": "\nint64_t fcn.1400068b0(int64_t arg1, ulong lpMultiByteStr, ulong arg3)\n\n{\n    int32_t iVar1;\n    ulong arg4;\n    ulong uVar2;\n    \n    if (arg1 == 0) {\n        arg4 = 0xffffffff;\n        uVar2 = lpMultiByteStr;\n        arg3._0_4_ = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0xfde9, 0, lpMultiByteStr, 0xffffffff, 0, 0);\n        if (arg3 == 0) {\n            fcn.140001cd0(0x140027bb0, \"Failed to get wchar_t buffer size.\\n\", uVar2, arg4);\n            return 0;\n        }\n        arg1 = fcn.14000c97c(arg3 + 1, 2);\n        if (arg1 == 0) {\n            fcn.140001cd0(\"win32_utils_from_utf8\", \"Out of memory.\\n\", uVar2, arg4);\n            return 0;\n        }\n    }\n    uVar2 = 0xffffffff;\n    iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0xfde9, 0, lpMultiByteStr, 0xffffffff, arg1, arg3);\n    if (iVar1 == 0) {\n        fcn.140001cd0(0x140027bb0, \"Failed to decode wchar_t from UTF-8\\n\", lpMultiByteStr, uVar2);\n        return 0;\n    }\n    return arg1;\n}\n",
        "token_count": 355
    },
    "14001102": {
        "rules": [
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353"
        ],
        "decompiled_code": "\nint64_t fcn.140011028(int16_t *arg1, int16_t *arg2)\n\n{\n    uint *puVar1;\n    int64_t iVar2;\n    int64_t *arg1_00;\n    int64_t iStackX8;\n    \n    if (((arg1 == NULL) || (arg2 == NULL)) || (*arg2 == 0)) {\n        puVar1 = fcn.140015850(arg1);\n        *puVar1 = 0x16;\n        fcn.140015730();\n    }\n    else if (*arg1 == 0) {\n        puVar1 = fcn.140015850(arg1);\n        *puVar1 = 0x16;\n    }\n    else {\n        arg1_00 = &iStackX8;\n        fcn.140015a88(arg1_00);\n        if (iStackX8 != 0) {\n            iVar2 = fcn.14001aa2c(arg1, arg2, 0x40, iStackX8);\n            if (iVar2 == 0) {\n                fcn.140015ae0(iStackX8);\n            }\n            fcn.14000cbcc(iStackX8);\n            return iVar2;\n        }\n        puVar1 = fcn.140015850(arg1_00);\n        *puVar1 = 0x18;\n    }\n    return 0;\n}\n",
        "token_count": 304
    },
    "14001b74": {
        "rules": [
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353"
        ],
        "decompiled_code": "\nint64_t * fcn.14001b740(int64_t *arg1, ulong arg2)\n\n{\n    char cVar1;\n    code *pcVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    int64_t *piVar5;\n    int64_t *piVar6;\n    int64_t iVar7;\n    int64_t *piVar8;\n    int64_t *piVar9;\n    uint64_t uVar10;\n    uint32_t uVar11;\n    int64_t *piVar12;\n    int64_t iVar13;\n    \n    piVar9 = NULL;\n    uVar11 = 0;\n    if (arg1 == NULL) {\n        puVar4 = fcn.140015850(0);\n        *puVar4 = 0x16;\n        return 0xffffffffffffffff;\n    }\n    piVar8 = arg1;\n    piVar5 = fcn.14000ae08(arg1, 0x3d);\n    piVar12 = arg1;\n    if ((piVar5 == NULL) || (piVar5 == arg1)) {\ncode_r0x00014001b1f6:\n        puVar4 = fcn.140015850(piVar8);\n        uVar11 = 0xffffffff;\n        *puVar4 = 0x16;\n    }\n    else {\n        cVar1 = *(piVar5 + 1);\n        if (*0x140046980 == *0x140046998) {\n            piVar6 = fcn.14001b568(*0x140046980);\n            piVar8 = *0x140046980;\n            *0x140046980 = piVar6;\n        }\n        if (*0x140046980 == NULL) {\n            if ((arg2 != 0) && (*0x140046988 != 0)) {\n                iVar7 = fcn.140013df0();\n                if (iVar7 != 0) {\n                    if (*0x140046980 == *0x140046998) {\n                        *0x140046980 = fcn.14001b568(*0x140046980);\n                    }\n                    goto code_r0x00014001b068;\n                }\n                goto code_r0x00014001b1f6;\n            }\n            if (cVar1 != '\\0') {\n                *0x140046980 = fcn.140017c34(1, 8);\n                fcn.140015870(0);\n                if (*0x140046980 != NULL) {\n                    if (*0x140046988 == 0) {\n                        *0x140046988 = fcn.140017c34(1, 8);\n                        fcn.140015870(0);\n                        if (*0x140046988 == 0) goto code_r0x00014001b02b;\n                    }\ncode_r0x00014001b068:\n                    if (*0x140046980 != NULL) goto code_r0x00014001b06d;\n                }\ncode_r0x00014001b02b:\n                uVar11 = 0xffffffff;\n            }\n        }\n        else {\ncode_r0x00014001b06d:\n            piVar8 = *0x140046980;\n            iVar13 = piVar5 - arg1;\n            iVar7 = **0x140046980;\n            piVar6 = *0x140046980;\n            while (iVar7 != 0) {\n                iVar3 = fcn.140021500(arg1, iVar7, iVar13);\n                if ((iVar3 == 0) && ((*(iVar13 + *piVar6) == '=' || (*(iVar13 + *piVar6) == '\\0')))) {\n                    iVar7 = piVar6 - piVar8 >> 3;\n                    goto code_r0x00014001b0bc;\n                }\n                piVar6 = piVar6 + 1;\n                iVar7 = *piVar6;\n            }\n            iVar7 = -(piVar6 - piVar8 >> 3);\ncode_r0x00014001b0bc:\n            if ((-1 < iVar7) && (*piVar8 != 0)) {\n                fcn.140015870(piVar8[iVar7]);\n                if (cVar1 == '\\0') {\n                    for (; piVar8[iVar7] != 0; iVar7 = iVar7 + 1) {\n                        piVar8[iVar7] = piVar8[iVar7 + 1];\n                    }\n                    piVar8 = fcn.14001d890(piVar8, iVar7, 8);\n                    fcn.140015870(0);\n                    if (piVar8 != NULL) {\n                        *0x140046980 = piVar8;\n                    }\n                }\n                else {\n                    piVar8[iVar7] = arg1;\n                    piVar12 = piVar9;\n                }\ncode_r0x00014001b175:\n                if (arg2 != 0) {\n                    iVar7 = -1;\n                    do {\n                        iVar13 = iVar7;\n                        iVar7 = iVar13 + 1;\n                    } while (*(arg1 + iVar13 + 1) != '\\0');\n                    iVar7 = fcn.140017c34(iVar13 + 3, 1);\n                    if (iVar7 != 0) {\n                        iVar3 = fcn.140014a14(iVar7, iVar13 + 3, arg1);\n                        if (iVar3 != 0) {\n                            fcn.140015750(0, 0, 0, 0, 0);\n                            pcVar2 = swi(3);\n                            piVar9 = (*pcVar2)();\n                            return piVar9;\n                        }\n                        uVar10 = piVar5 + (iVar7 - arg1) + 1;\n                        *(uVar10 - 1) = 0;\n                        iVar13 = iVar7;\n                        iVar3 = fcn.140021618(iVar7, -(cVar1 != '\\0') & uVar10);\n                        if (iVar3 == 0) {\n                            puVar4 = fcn.140015850(iVar13);\n                            piVar9 = 0xffffffff;\n                            *puVar4 = 0x2a;\n                        }\n                    }\n                    fcn.140015870(iVar7);\n                }\n                goto code_r0x00014001b20d;\n            }\n            if (cVar1 != '\\0') {\n                uVar10 = -iVar7 + 2;\n                if ((-iVar7 <= uVar10) && (uVar10 < 0x1fffffffffffffff)) {\n                    piVar8 = fcn.14001d890(piVar8, uVar10, 8);\n                    fcn.140015870(0);\n                    if (piVar8 != NULL) {\n                        piVar8[-iVar7] = arg1;\n                        piVar8[1 - iVar7] = 0;\n                        piVar12 = piVar9;\n                        *0x140046980 = piVar8;\n                        goto code_r0x00014001b175;\n                    }\n                }\n                uVar11 = 0xffffffff;\n            }\n        }\n    }\n    piVar9 = uVar11;\ncode_r0x00014001b20d:\n    fcn.140015870(piVar12);\n    return piVar9;\n}\n",
        "token_count": 1583
    },
    "14001bb4": {
        "rules": [
            "validate payment card number using luhn algorithm with lookup table/6f7029bc2c134cb690df0e7c2f59f3d4",
            "validate payment card number using luhn algorithm with no lookup table/a90d4ac7cf5b4bde87d45a81715c7353"
        ],
        "decompiled_code": "\nulong fcn.14001bb48(uint64_t *arg1, ushort *arg2, uint64_t arg3, ulong arg4)\n\n{\n    code *pcVar1;\n    bool bVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    int64_t arg3_00;\n    int64_t iVar5;\n    uint64_t uVar7;\n    ulong uVar8;\n    ulong uVar9;\n    int64_t iVar6;\n    \n    uVar8 = 0xb;\n    fcn.14001ad2c(0xb);\n    uVar9 = 0;\n    if (arg1 != NULL) {\n        *arg1 = 0;\n        if (arg2 == NULL) {\ncode_r0x00014001ba8c:\n            if (arg3 == 0) goto code_r0x00014001ba91;\ncode_r0x00014001ba98:\n            bVar2 = false;\n        }\n        else {\n            if (arg3 == 0) {\n                if (arg2 == NULL) goto code_r0x00014001ba8c;\n                goto code_r0x00014001ba98;\n            }\ncode_r0x00014001ba91:\n            bVar2 = true;\n        }\n        if (bVar2) {\n            if (arg2 != NULL) {\n                *arg2 = 0;\n            }\n            arg3_00 = fcn.14001b998(arg4);\n            if (arg3_00 != 0) {\n                iVar5 = -1;\n                do {\n                    iVar6 = iVar5;\n                    iVar5 = iVar6 + 1;\n                } while (*(arg3_00 + iVar5 * 2) != 0);\n                uVar7 = iVar6 + 2;\n                *arg1 = uVar7;\n                if (arg3 != 0) {\n                    if (arg3 < uVar7) {\n                        uVar9 = 0x22;\n                    }\n                    else {\n                        iVar3 = fcn.14001aebc(arg2, arg3, arg3_00);\n                        if (iVar3 != 0) {\n                            fcn.140015750(0, 0, 0, 0, 0);\n                            pcVar1 = swi(3);\n                            uVar8 = (*pcVar1)();\n                            return uVar8;\n                        }\n                    }\n                }\n            }\n            goto code_r0x00014001baea;\n        }\n    }\n    puVar4 = fcn.140015850(uVar8);\n    uVar9 = 0x16;\n    *puVar4 = 0x16;\n    fcn.140015730();\ncode_r0x00014001baea:\n    fcn.14001ad80(0xb);\n    return uVar9;\n}\n",
        "token_count": 610
    },
    "14000877": {
        "rules": [
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df",
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df"
        ],
        "decompiled_code": "\n// WARNING: Removing unreachable block (ram,0x0001400085e3)\n\nuint fcn.140008770(int64_t arg1, char *arg2, ulong arg3)\n\n{\n    int64_t *piVar1;\n    code *pcVar2;\n    int64_t *piVar3;\n    ulong uVar4;\n    \n    if (((arg2 == NULL) || (*arg2 != '1')) || (arg3 != 0x58)) {\n        return 0xfffffffa;\n    }\n    if (arg1 == 0) {\n        return 0xfffffffe;\n    }\n    pcVar2 = *(arg1 + 0x30);\n    uVar4 = 0;\n    *(arg1 + 0x20) = 0;\n    if (pcVar2 == NULL) {\n        pcVar2 = 0x140008ea0;\n        *(arg1 + 0x40) = 0;\n        *(arg1 + 0x30) = 0x140008ea0;\n    }\n    else {\n        uVar4 = *(arg1 + 0x40);\n    }\n    if (*(arg1 + 0x38) == 0) {\n        *(arg1 + 0x38) = 0x140008eb0;\n    }\n    piVar3 = (*pcVar2)(uVar4, 1, 0x1bf0);\n    if (piVar3 != NULL) {\n        *(arg1 + 0x28) = piVar3;\n        *piVar3 = arg1;\n        piVar3[8] = 0;\n        *(piVar3 + 1) = 0x3f34;\n        if (((*(arg1 + 0x30) != 0) && (*(arg1 + 0x38) != NULL)) &&\n           ((piVar1 = *(arg1 + 0x28),  piVar1 != NULL && ((*piVar1 == arg1 && (*(piVar1 + 1) - 0x3f34U < 0x20)))))) {\n            if ((piVar1[8] != 0) && (*(piVar1 + 6) != 0xf)) {\n                (**(arg1 + 0x38))(*(arg1 + 0x40));\n                piVar1[8] = 0;\n            }\n            *(piVar1 + 2) = 5;\n            *(piVar1 + 6) = 0xf;\n            if ((((*(arg1 + 0x30) != 0) && (*(arg1 + 0x38) != 0)) && (piVar1 = *(arg1 + 0x28),  piVar1 != NULL)) &&\n               ((*piVar1 == arg1 && (*(piVar1 + 1) - 0x3f34U < 0x20)))) {\n                *(piVar1 + 0x34) = 0;\n                *(piVar1 + 0x3c) = 0;\n                if ((((*(arg1 + 0x30) != 0) && ((*(arg1 + 0x38) != 0 && (piVar1 = *(arg1 + 0x28),  piVar1 != NULL)))) &&\n                    (*piVar1 == arg1)) && (*(piVar1 + 1) - 0x3f34U < 0x20)) {\n                    *(piVar1 + 0x24) = 0;\n                    *(arg1 + 0x1c) = 0;\n                    *(arg1 + 0xc) = 0;\n                    *(arg1 + 0x20) = 0;\n                    if (*(piVar1 + 2) != 0) {\n                        *(arg1 + 0x4c) = *(piVar1 + 2) & 1;\n                    }\n                    piVar3 = piVar1 + 0xaa;\n                    piVar1[0x11] = piVar3;\n                    piVar1[0xd] = piVar3;\n                    piVar1[0xc] = piVar3;\n                    *(piVar1 + 0x14) = 0;\n                    piVar1[5] = 0;\n                    piVar1[9] = 0;\n                    piVar1[1] = 0x3f34;\n                    *(piVar1 + 0x1c) = 0x8000;\n                    *(piVar1 + 0x37c) = 1;\n                    *(piVar1 + 0x1be4) = 0xffffffff;\n                    return 0;\n                }\n            }\n        }\n        (**(arg1 + 0x38))(*(arg1 + 0x40), piVar3);\n        *(arg1 + 0x28) = 0;\n        return 0xfffffffe;\n    }\n    return 0xfffffffc;\n}\n",
        "token_count": 1061
    },
    "14001028": {
        "rules": [
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df"
        ],
        "decompiled_code": "\nulong fcn.140010280(int64_t arg1, uchar (*arg2) [16])\n\n{\n    char cVar1;\n    ushort uVar2;\n    uint *puVar3;\n    int64_t hFile;\n    ulong uVar4;\n    ulong unaff_RBX;\n    ulong unaff_RSI;\n    ulong uVar5;\n    ulong unaff_RDI;\n    ulong unaff_R14;\n    ulong in_stack_00000000;\n    int32_t iVar6;\n    uint in_stack_00000014;\n    uint32_t in_stack_ffffffffffffffcc;\n    uint32_t in_stack_ffffffffffffffd4;\n    uint uVar7;\n    ulong in_stack_ffffffffffffffe0;\n    \n    uVar5 = 0;\n    if (arg2 == NULL) {\ncode_r0x00014001029f:\n        puVar3 = fcn.140015830(arg1);\n        *puVar3 = 0;\n        puVar3 = fcn.140015850(arg1);\n        *puVar3 = 0x16;\n        fcn.140015730();\n        return 0xffffffff;\n    }\n    *arg2 = ZEXT816(0);\n    arg2[1] = ZEXT816(0);\n    arg2[2] = ZEXT816(0);\n    if (arg1 == 0) goto code_r0x00014001029f;\n    uVar7 = 0;\n    hFile = (*_sym.imp.KERNEL32.dll_CreateFileW)();\n    if (hFile == -1) {\n        cVar1 = fcn.140010850(arg1);\n        if (cVar1 == '\\0') {\n            fcn.1400157e0(2);\n        }\n        else {\n            uVar2 = fcn.14001060c(0x10, arg1);\n            *(*arg2 + 6) = uVar2;\n            *(*arg2 + 8) = 1;\n            iVar6 = 0;\n            cVar1 = fcn.140010748(arg1, &stack0x00000010);\n            if (cVar1 != '\\0') {\n                *arg2[1] = iVar6 + -1;\n                **arg2 = iVar6 + -1;\n                uVar4 = fcn.14001a180(0x7bc, 1, 1, 0, in_stack_ffffffffffffffcc << 0x20, \n                                      in_stack_ffffffffffffffd4 << 0x20, CONCAT44(uVar7, 0xffffffff), \n                                      in_stack_ffffffffffffffe0, unaff_R14, unaff_RDI, unaff_RSI, in_stack_00000000, \n                                      unaff_RBX, CONCAT44(in_stack_00000014, iVar6));\n                *arg2[2] = uVar4;\n                *(arg2[1] + 8) = uVar4;\n                *(arg2[2] + 8) = uVar4;\n                goto code_r0x000140010324;\n            }\n        }\n    }\n    else {\n        cVar1 = fcn.1400103cc(arg1, 0xffffffff, hFile, arg2);\n        if (cVar1 != '\\0') goto code_r0x000140010324;\n    }\n    uVar5 = 0xffffffff;\n    *arg2 = ZEXT816(0);\n    arg2[1] = ZEXT816(0);\n    arg2[2] = ZEXT816(0);\ncode_r0x000140010324:\n    if (hFile == -1) {\n        return uVar5;\n    }\n    (*_sym.imp.KERNEL32.dll_CloseHandle)(hFile);\n    return uVar5;\n}\n",
        "token_count": 809
    },
    "14001c37": {
        "rules": [
            "empty recycle bin quietly/a05fef7955a340fbb66225983c77e1df"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.14001c374(int16_t **arg1, int64_t *arg2)\n\n{\n    code *pcVar1;\n    uint8_t uVar2;\n    int32_t iVar3;\n    uint *puVar4;\n    int16_t *piVar5;\n    int16_t *piVar6;\n    int64_t iVar7;\n    uint16_t uVar8;\n    int64_t iVar9;\n    int64_t *piVar10;\n    uint64_t uVar11;\n    uint64_t uVar12;\n    uint64_t uVar13;\n    int64_t iVar14;\n    uint64_t uVar15;\n    ulong var_1b0h;\n    ulong var_1b8h;\n    uchar auStack760 [32];\n    ulong uStack728;\n    uint uStack720;\n    uchar auStack712 [16];\n    ulong uStack696;\n    uint64_t uStack688;\n    int64_t iStack680;\n    int64_t *piStack672;\n    uchar auStack664 [44];\n    int16_t iStack620;\n    int16_t iStack618;\n    int16_t iStack616;\n    ulong var_74h;\n    ulong uStack72;\n    uint64_t uStack64;\n    \n    uStack64 = *0x140037018 ^ auStack760;\n    uVar11 = 0;\n    piStack672 = arg2;\n    if (arg2 == NULL) {\n        puVar4 = fcn.140015850(arg1);\n        *puVar4 = 0x16;\n        fcn.140015730();\n    }\n    else {\n        *arg2 = 0;\n        piVar5 = *arg1;\n        auStack712 = ZEXT816(0);\n        auStack712._8_8_ = NULL;\n        auStack712._0_8_ = NULL;\n        uStack696 = 0;\n        while (piVar5 != NULL) {\n            uStack72 = CONCAT26(uStack72._6_2_, 0x3f002a);\n            piVar6 = fcn.140019cb4(piVar5, &uStack72);\n            piVar5 = *arg1;\n            if (piVar6 == NULL) {\n                iVar3 = fcn.14001c1e8(piVar5, 0, 0, auStack712);\ncode_r0x00014001c055:\n                if (iVar3 != 0) goto code_r0x00014001c169;\n            }\n            else {\n                while ((piVar6 != piVar5 &&\n                       ((0x2d < *piVar6 - 0x2fU || ((0x200000000801U >> (*piVar6 - 0x2fU & 0x3f) & 1) == 0))))) {\n                    piVar6 = piVar6 + -1;\n                }\n                if ((*piVar6 == 0x3a) && (piVar6 != piVar5 + 1)) {\ncode_r0x00014001bf2a:\n                    iVar3 = fcn.14001c1e8(piVar5, 0, 0, auStack712);\ncode_r0x00014001c048:\n                    goto code_r0x00014001c055;\n                }\n                uVar8 = *piVar6 - 0x2f;\n                if ((0x2d < uVar8) || (uVar2 = 1,  (0x200000000801U >> (uVar8 & 0x3f) & 1) == 0)) {\n                    uVar2 = 0;\n                }\n                uStack720 = 0;\n                uStack728 = 0;\n                uVar15 = -uVar2 & (piVar6 - piVar5 >> 1) + 1U;\n                uStack688 = uVar15;\n                iVar7 = (*_sym.imp.KERNEL32.dll_FindFirstFileExW)(piVar5, 0, auStack664, 0);\n                if (iVar7 == -1) goto code_r0x00014001bf2a;\n                iStack680 = auStack712._8_8_ - auStack712._0_8_ >> 3;\n                do {\n                    if (((iStack620 != 0x2e) || ((iStack618 != 0 && ((iStack618 != 0x2e || (iStack616 != 0)))))) &&\n                       (iVar3 = fcn.14001c1e8(&iStack620, piVar5, uVar15, auStack712),  uVar15 = uStack688,  iVar3 != 0)\n                       ) {\n                        (*_sym.imp.KERNEL32.dll_FindClose)(iVar7);\n                        goto code_r0x00014001c048;\n                    }\n                    iVar3 = (*_sym.imp.KERNEL32.dll_FindNextFileW)(iVar7, auStack664);\n                } while (iVar3 != 0);\n                iVar9 = auStack712._8_8_ - auStack712._0_8_ >> 3;\n                if (iStack680 != iVar9) {\n                    fcn.140021840(auStack712._0_8_ + iStack680, iVar9 - iStack680, 8, 0x14001be08);\n                    (*_sym.imp.KERNEL32.dll_FindClose)(iVar7);\n                    iVar3 = 0;\n                    goto code_r0x00014001c055;\n                }\n                (*_sym.imp.KERNEL32.dll_FindClose)(iVar7);\n            }\n            arg1 = arg1 + 1;\n            piVar5 = *arg1;\n        }\n        uStack72 = 0;\n        iVar7 = (auStack712._8_8_ - auStack712._0_8_ >> 3) + 1;\n        uVar15 = (auStack712._8_8_ - auStack712._0_8_) + 7U >> 3;\n        if (auStack712._8_8_ < auStack712._0_8_) {\n            uVar15 = uVar11;\n        }\n        piVar10 = auStack712._0_8_;\n        uVar12 = uVar11;\n        uVar13 = uVar11;\n        if (uVar15 != 0) {\n            do {\n                iVar9 = -1;\n                do {\n                    iVar9 = iVar9 + 1;\n                } while (*(*piVar10 + iVar9 * 2) != 0);\n                piVar10 = piVar10 + 1;\n                uVar13 = uVar13 + 1 + iVar9;\n                uVar12 = uVar12 + 1;\n                uStack72 = uVar13;\n            } while (uVar12 != uVar15);\n        }\n        iVar9 = fcn.140013718(iVar7, uStack72);\n        if (iVar9 != 0) {\n            uVar15 = iVar9 + iVar7 * 8;\n            uStack688 = uVar15;\n            if (auStack712._0_8_ != auStack712._8_8_) {\n                iStack680 = iVar9 - auStack712._0_8_;\n                piVar10 = auStack712._0_8_;\n                do {\n                    iVar7 = -1;\n                    do {\n                        iVar14 = iVar7;\n                        iVar7 = iVar14 + 1;\n                    } while (*(*piVar10 + iVar7 * 2) != 0);\n                    iVar14 = iVar14 + 2;\n                    iVar3 = fcn.14001bd24(uVar15, uStack72 - (uVar15 - uStack688 >> 1), *piVar10, iVar14);\n                    if (iVar3 != 0) {\n                        uStack728 = 0;\n                        fcn.140015750(0, 0, 0, 0);\n                        pcVar1 = swi(3);\n                        (*pcVar1)();\n                        return;\n                    }\n                    *(iStack680 + piVar10) = uVar15;\n                    piVar10 = piVar10 + 1;\n                    uVar15 = uVar15 + iVar14 * 2;\n                } while (piVar10 != auStack712._8_8_);\n            }\n            *piStack672 = iVar9;\n        }\n        fcn.140015870(0);\ncode_r0x00014001c169:\n        uVar15 = auStack712._8_8_ + (7 - auStack712._0_8_) >> 3;\n        if (auStack712._8_8_ < auStack712._0_8_) {\n            uVar15 = uVar11;\n        }\n        piVar10 = auStack712._0_8_;\n        if (uVar15 != 0) {\n            do {\n                fcn.140015870(*piVar10);\n                uVar11 = uVar11 + 1;\n                piVar10 = piVar10 + 1;\n            } while (uVar11 != uVar15);\n        }\n        fcn.140015870(auStack712._0_8_);\n    }\n    fcn.140009a80(uStack64 ^ auStack760);\n    return;\n}\n",
        "token_count": 2013
    },
    "140001c3": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nvoid fcn.140001c30(ulong arg1, ulong arg2, ulong arg3, ulong arg4)\n\n{\n    ulong uStackX24;\n    ulong uStackX32;\n    \n    uStackX24 = arg3;\n    uStackX32 = arg4;\n    fcn.140001d20(arg2, &uStackX24);\n    fcn.14000cc34(arg1);\n    return;\n}\n",
        "token_count": 92
    },
    "140001cd": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nvoid fcn.140001cd0(ulong arg1, ulong arg2, ulong arg3, ulong arg4)\n\n{\n    uint uVar1;\n    ulong arg3_00;\n    ulong uStackX24;\n    ulong uStackX32;\n    \n    uStackX24 = arg3;\n    uStackX32 = arg4;\n    fcn.140001d20(arg2, &uStackX24);\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n    arg3_00 = fcn.140006270(uVar1);\n    fcn.140001c00(\"%s: %s\", arg1, arg3_00, arg4);\n    return;\n}\n",
        "token_count": 151
    },
    "140002d9": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nvoid fcn.140002d90(ulong param_1, ulong param_2)\n\n{\n    int64_t iVar1;\n    uchar auStackX24 [16];\n    ulong uStack16;\n    \n    uStack16 = 0x140002d9c;\n    iVar1 = fcn.140009a10();\n    iVar1 = -iVar1;\n    *(&stack0x00002038 + iVar1) = *0x140037018 ^ &stack0xfffffffffffffff8 + iVar1;\n    *(&stack0xfffffffffffffff0 + iVar1) = 0x140002dc7;\n    fcn.1400068b0(&stack0x00000038 + iVar1, param_1, 0x1000);\n    *(&stack0xfffffffffffffff0 + iVar1) = 0x140002dda;\n    fcn.1400068b0(&stack0x00000018 + iVar1, param_2, 10);\n    *(&stack0xfffffffffffffff0 + iVar1) = 0x140002de9;\n    fcn.140011028(&stack0x00000038 + iVar1, &stack0x00000018 + iVar1);\n    *(&stack0xfffffffffffffff0 + iVar1) = 0x140002df9;\n    fcn.140009a80(*(&stack0x00002038 + iVar1) ^ &stack0xfffffffffffffff8 + iVar1);\n    return;\n}\n",
        "token_count": 313
    },
    "14000481": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nuint fcn.140004810(int64_t arg1, ulong arg2, ulong arg3, ulong arg4)\n\n{\n    ulong *puVar1;\n    ulong var_8h;\n    ulong uStackX8;\n    uint auStackX16 [2];\n    \n    auStackX16[0] = 0;\n    uStackX8 = 0;\n    puVar1 = (**0x140044f58)(0x40);\n    *puVar1 = 0x140003f60;\n    puVar1[4] = &uStackX8;\n    puVar1[5] = auStackX16;\n    puVar1[2] = arg1;\n    *(puVar1 + 3) = arg2;\n    puVar1[6] = arg4;\n    puVar1[7] = arg3;\n    (**0x140044ec8)(0x140044e50);\n    (**0x140044ef0)(*(arg1 + 8), puVar1, 0);\n    (**0x140044ef8)(*(arg1 + 8));\n    if (arg2 == 0) {\n        (**0x140044ee8)(&uStackX8, 0x140044e50, 0);\n        (**0x140044ed0)(0x140044e50);\n        (**0x140044ed8)(&uStackX8);\n    }\n    else {\n        (**0x140044ed0)(0x140044e50);\n    }\n    return auStackX16[0];\n}\n",
        "token_count": 338
    },
    "140004c5": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nuint fcn.140004c50(int64_t arg1, ulong arg2)\n\n{\n    ulong *puVar1;\n    uint auStackX8 [2];\n    ulong uStackX16;\n    \n    auStackX8[0] = 0;\n    uStackX16 = 0;\n    puVar1 = (**0x140044f58)(0x40);\n    *puVar1 = 0x140003f60;\n    puVar1[4] = &uStackX16;\n    puVar1[5] = auStackX8;\n    puVar1[6] = 0x140003f30;\n    puVar1[2] = arg1;\n    *(puVar1 + 3) = 1;\n    puVar1[7] = arg2;\n    (**0x140044ec8)(0x140044e50);\n    (**0x140044ef0)(*(arg1 + 8), puVar1, 0);\n    (**0x140044ef8)(*(arg1 + 8));\n    (**0x140044ed0)(0x140044e50);\n    return auStackX8[0];\n}\n",
        "token_count": 255
    },
    "14000627": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nvoid fcn.140006270(uint32_t param_1)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    uint64_t arg3;\n    uchar *arg3_00;\n    ulong uVar3;\n    int64_t iStackX24;\n    uint auStackX32 [2];\n    ulong uStack16;\n    \n    uStack16 = 0x14000627c;\n    iVar2 = fcn.140009a10();\n    iVar2 = -iVar2;\n    *(&stack0x00002038 + iVar2) = *0x140037018 ^ &stack0xfffffffffffffff8 + iVar2;\n    if (param_1 == 0) {\n        *(&stack0xfffffffffffffff0 + iVar2) = 0x14000629d;\n        param_1 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n    }\n    *(&stack0x00000028 + iVar2) = 0;\n    uVar3 = 0x400;\n    *(&stack0x00000020 + iVar2) = 0x1000;\n    arg3 = param_1;\n    *(&stack0x00000018 + iVar2) = &stack0x00000038 + iVar2;\n    *(&stack0xfffffffffffffff0 + iVar2) = 0x1400062cc;\n    iVar1 = (*_sym.imp.KERNEL32.dll_FormatMessageW)(0x1000, 0);\n    if (iVar1 == 0) {\n        *(&stack0xfffffffffffffff0 + iVar2) = 0x1400062e3;\n        fcn.140001cd0(0x1400279f8, \"No error messages generated.\\n\", arg3, uVar3);\n    }\n    else {\n        *(&stack0x00000030 + iVar2) = 0;\n        arg3_00 = &stack0x00000038 + iVar2;\n        *(&stack0x00000028 + iVar2) = 0;\n        uVar3 = 0xffffffff;\n        *(&stack0x00000020 + iVar2) = 0x1000;\n        *(&stack0x00000018 + iVar2) = 0x140044f90;\n        *(&stack0xfffffffffffffff0 + iVar2) = 0x140006322;\n        iVar1 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0xfde9, 0);\n        if (iVar1 == 0) {\n            *(&stack0xfffffffffffffff0 + iVar2) = 0x140006339;\n            fcn.140001cd0(0x140027ab8, \"Failed to encode wchar_t as UTF-8.\\n\", arg3_00, uVar3);\n        }\n    }\n    *(&stack0xfffffffffffffff0 + iVar2) = 0x140006355;\n    fcn.140009a80(*(&stack0x00002038 + iVar2) ^ &stack0xfffffffffffffff8 + iVar2);\n    return;\n}\n",
        "token_count": 660
    },
    "14000656": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nvoid fcn.140006560(ulong param_1)\n\n{\n    char16_t *pcVar1;\n    int32_t iVar2;\n    int64_t iVar3;\n    ulong uVar4;\n    ulong *arg1;\n    char16_t *arg4;\n    int64_t aiStackX24 [2];\n    ulong uStack16;\n    \n    uStack16 = 0x140006570;\n    iVar3 = fcn.140009a10();\n    iVar3 = -iVar3;\n    *(&stack0x00002058 + iVar3) = *0x140037018 ^ &stack0xfffffffffffffff8 + iVar3;\n    arg1 = NULL;\n    *(&stack0x00000030 + iVar3) = 0xffffffffffffffff;\n    *(&stack0x00000038 + iVar3) = 0;\n    *(&stack0x00000028 + iVar3) = 0;\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x1400065a6;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetCurrentProcess)();\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x1400065b7;\n    iVar2 = (*_sym.imp.ADVAPI32.dll_OpenProcessToken)(uVar4, 8, &stack0x00000030 + iVar3);\n    if (iVar2 != 0) {\n        *(&stack0x00000018 + iVar3) = &stack0x00000028 + iVar3;\n        *(&stack0xfffffffffffffff0 + iVar3) = 0x1400065d9;\n        iVar2 = (*_sym.imp.ADVAPI32.dll_GetTokenInformation)(*(&stack0x00000030 + iVar3), 1, 0, 0);\n        if (iVar2 == 0) {\n            *(&stack0xfffffffffffffff0 + iVar3) = 0x1400065e3;\n            iVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            if (iVar2 != 0x7a) goto code_r0x000140006631;\n        }\n        *(&stack0xfffffffffffffff0 + iVar3) = 0x1400065f6;\n        arg1 = fcn.14000c97c(1, *(&stack0x00000028 + iVar3));\n        if (arg1 != NULL) {\n            *(&stack0x00000018 + iVar3) = &stack0x00000028 + iVar3;\n            *(&stack0xfffffffffffffff0 + iVar3) = 0x140006620;\n            iVar2 = (*_sym.imp.ADVAPI32.dll_GetTokenInformation)\n                              (*(&stack0x00000030 + iVar3), 1, arg1, *(&stack0x00000028 + iVar3));\n            if (iVar2 != 0) {\n                uVar4 = *arg1;\n                *(&stack0xfffffffffffffff0 + iVar3) = 0x140006631;\n                sub.ADVAPI32.dll_ConvertSidToStringSidW(uVar4, &stack0x00000038 + iVar3);\n            }\n        }\n    }\ncode_r0x000140006631:\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140006639;\n    fcn.14000c984(arg1);\n    if (*(&stack0x00000030 + iVar3) != -1) {\n        *(&stack0xfffffffffffffff0 + iVar3) = 0x14000664a;\n        (*_sym.imp.KERNEL32.dll_CloseHandle)();\n    }\n    pcVar1 = *(&stack0x00000038 + iVar3);\n    arg4 = L\"S-1-3-4\";\n    if (pcVar1 != NULL) {\n        arg4 = pcVar1;\n    }\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140006673;\n    fcn.140006360(&stack0x00000058 + iVar3, 0x1000, L\"D:(A;;FA;;;%s)\", arg4);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x14000667c;\n    (*_sym.imp.KERNEL32.dll_LocalFree)(pcVar1);\n    *(&stack0x00000040 + iVar3) = 0x18;\n    *(&stack0x00000050 + iVar3) = 0;\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x1400066a2;\n    iVar2 = sub.ADVAPI32.dll_ConvertStringSecurityDescriptorToSecurityDescriptorW\n                      (&stack0x00000058 + iVar3, 1, &stack0x00000048 + iVar3);\n    if (iVar2 != 0) {\n        *(&stack0xfffffffffffffff0 + iVar3) = 0x1400066b4;\n        (*_sym.imp.KERNEL32.dll_CreateDirectoryW)(param_1, &stack0x00000040 + iVar3);\n    }\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x1400066d1;\n    fcn.140009a80(*(&stack0x00002058 + iVar3) ^ &stack0xfffffffffffffff8 + iVar3);\n    return;\n}\n",
        "token_count": 1144
    },
    "1400100f": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.1400100f8(uint64_t arg1, uchar *arg2, int64_t arg3, int64_t arg4)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    ulong in_stack_00000028;\n    ulong var_3b8h;\n    ulong var_3c0h;\n    ulong var_3c8h;\n    ulong var_3d0h;\n    ulong var_3e0h;\n    uchar auStack1320 [32];\n    uchar *puStack1288;\n    int64_t iStack1280;\n    int64_t iStack1272;\n    uchar uStack1264;\n    uint uStack1263;\n    ushort uStack1259;\n    uchar uStack1257;\n    int64_t iStack1256;\n    uchar auStack1248 [16];\n    char cStack1232;\n    uint64_t uStack1224;\n    uchar *puStack1216;\n    ulong uStack1208;\n    int64_t iStack1200;\n    ulong uStack1184;\n    ulong uStack1176;\n    uint uStack1168;\n    ushort uStack1160;\n    uint uStack1144;\n    uchar uStack1140;\n    ulong var_80h;\n    ulong var_78h;\n    ulong var_bp_70h;\n    ulong var_bp_68h;\n    ulong var_bp_60h;\n    uchar **ppuStack96;\n    ulong var_50h;\n    uint64_t uStack72;\n    \n    uStack72 = *0x140037018 ^ auStack1320;\n    if ((arg4 == 0) || ((arg3 != 0 && (arg2 == NULL)))) {\n        puVar2 = fcn.140015850(arg1);\n        *puVar2 = 0x16;\n        fcn.140015730();\n        goto code_r0x00014000ceaa;\n    }\n    fcn.14000d630(&iStack1256, in_stack_00000028);\n    uStack1263 = 0;\n    uStack1259 = 0;\n    uStack1257 = 0;\n    iStack1272 = 0;\n    if (((arg1 & 2) != 0) || (uStack1264 = 0,  arg2 == NULL)) {\n        uStack1264 = 1;\n    }\n    ppuStack96 = &puStack1288;\n    uStack1208 = 0;\n    puStack1216 = auStack1248;\n    uStack1184 = 0;\n    uStack1176 = 0;\n    uStack1168 = 0;\n    uStack1160 = 0;\n    uStack1144 = 0;\n    uStack1140 = 0;\n    var_bp_68h = 0;\n    var_bp_60h = 0;\n    var_50h._0_4_ = 0;\n    puStack1288 = arg2;\n    iStack1280 = arg3;\n    uStack1224 = arg1;\n    iStack1200 = arg4;\n    iVar1 = fcn.14000dc74(&uStack1224);\n    if (arg2 != NULL) {\n        if ((arg1 & 1) == 0) {\n            if ((arg1 & 2) == 0) {\n                if (arg3 != 0) {\n                    if (iStack1272 != arg3) goto code_r0x00014000ce7e;\ncode_r0x00014000cee4:\n                    arg2[arg3 + -1] = 0;\n                }\n            }\n            else if (arg3 != 0) {\n                if (-1 < iVar1) {\n                    if (iStack1272 == arg3) goto code_r0x00014000cee4;\n                    goto code_r0x00014000ce7e;\n                }\n                *arg2 = 0;\n            }\n        }\n        else if (((arg3 != 0) || (iVar1 == 0)) && (iStack1272 != arg3)) {\ncode_r0x00014000ce7e:\n            arg2[iStack1272] = 0;\n        }\n    }\n    fcn.140015870(var_bp_60h);\n    var_bp_60h = 0;\n    if (cStack1232 != '\\0') {\n        *(iStack1256 + 0x3a8) = *(iStack1256 + 0x3a8) & 0xfffffffd;\n    }\ncode_r0x00014000ceaa:\n    fcn.140009a80(uStack72 ^ auStack1320);\n    return;\n}\n",
        "token_count": 1020
    },
    "14001010": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.140010100(uint64_t arg1, ushort *arg2, int64_t arg3, int64_t arg4)\n\n{\n    int32_t iVar1;\n    uint *puVar2;\n    ulong in_stack_00000028;\n    ulong var_3b8h;\n    ulong var_3c0h;\n    ulong var_3c8h;\n    ulong var_3d0h;\n    ulong var_3e0h;\n    uchar auStack1320 [32];\n    ushort *puStack1288;\n    int64_t iStack1280;\n    int64_t iStack1272;\n    uchar uStack1264;\n    uint uStack1263;\n    ushort uStack1259;\n    uchar uStack1257;\n    int64_t iStack1256;\n    uchar auStack1248 [16];\n    char cStack1232;\n    uint64_t uStack1224;\n    uchar *puStack1216;\n    ulong uStack1208;\n    int64_t iStack1200;\n    ulong uStack1184;\n    ulong uStack1176;\n    uint uStack1168;\n    uchar uStack1160;\n    ushort uStack1158;\n    uint uStack1144;\n    uchar uStack1140;\n    ulong var_80h;\n    ulong var_78h;\n    ulong var_bp_70h;\n    ulong var_bp_68h;\n    ulong var_bp_60h;\n    ushort **ppuStack96;\n    ulong var_50h;\n    uint64_t uStack72;\n    \n    uStack72 = *0x140037018 ^ auStack1320;\n    if ((arg4 == 0) || ((arg3 != 0 && (arg2 == NULL)))) {\n        puVar2 = fcn.140015850(arg1);\n        *puVar2 = 0x16;\n        fcn.140015730();\n        goto code_r0x00014000d07c;\n    }\n    fcn.14000d630(&iStack1256, in_stack_00000028);\n    uStack1263 = 0;\n    uStack1259 = 0;\n    uStack1257 = 0;\n    iStack1272 = 0;\n    if (((arg1 & 2) != 0) || (uStack1264 = 0,  arg2 == NULL)) {\n        uStack1264 = 1;\n    }\n    ppuStack96 = &puStack1288;\n    uStack1208 = 0;\n    puStack1216 = auStack1248;\n    uStack1184 = 0;\n    uStack1176 = 0;\n    uStack1168 = 0;\n    uStack1160 = 0;\n    uStack1158 = 0;\n    uStack1144 = 0;\n    uStack1140 = 0;\n    var_bp_68h = 0;\n    var_bp_60h = 0;\n    var_50h._0_4_ = 0;\n    puStack1288 = arg2;\n    iStack1280 = arg3;\n    uStack1224 = arg1;\n    iStack1200 = arg4;\n    iVar1 = fcn.14000de7c(&uStack1224);\n    if (arg2 != NULL) {\n        if ((arg1 & 1) == 0) {\n            if ((arg1 & 2) == 0) {\n                if (arg3 != 0) {\n                    if (iStack1272 != arg3) goto code_r0x00014000d04f;\ncode_r0x00014000d0b6:\n                    arg2[arg3 + -1] = 0;\n                }\n            }\n            else if (arg3 != 0) {\n                if (-1 < iVar1) {\n                    if (iStack1272 == arg3) goto code_r0x00014000d0b6;\n                    goto code_r0x00014000d04f;\n                }\n                *arg2 = 0;\n            }\n        }\n        else if (((arg3 != 0) || (iVar1 == 0)) && (iStack1272 != arg3)) {\ncode_r0x00014000d04f:\n            arg2[iStack1272] = 0;\n        }\n    }\n    fcn.140015870(var_bp_60h);\n    var_bp_60h = 0;\n    if (cStack1232 != '\\0') {\n        *(iStack1256 + 0x3a8) = *(iStack1256 + 0x3a8) & 0xfffffffd;\n    }\ncode_r0x00014000d07c:\n    fcn.140009a80(uStack72 ^ auStack1320);\n    return;\n}\n",
        "token_count": 1041
    },
    "14001592": {
        "rules": [
            "execute shellcode via CopyFile2/5e26aed72a5343dd8575e85c80658d9d/1e72b327ed77488fa8075dcc8fba7738"
        ],
        "decompiled_code": "\nulong fcn.140015924(int64_t arg1)\n\n{\n    uint *puVar1;\n    ulong uVar2;\n    uint32_t auStackX8 [2];\n    uchar auStackX16 [8];\n    uint32_t auStackX24 [2];\n    uint32_t auStackX32 [2];\n    uint32_t *apuStack24 [3];\n    \n    auStackX8[0] = arg1;\n    if (auStackX8[0] == 0xfffffffe) {\n        puVar1 = fcn.140015830(arg1);\n        *puVar1 = 0;\n        puVar1 = fcn.140015850(arg1);\n        *puVar1 = 9;\n    }\n    else {\n        if (((-1 < auStackX8[0]) && (auStackX8[0] < *0x140046e00)) &&\n           (arg1 = (auStackX8[0] & 0x3f) * 9, \n           (*(*((auStackX8[0] >> 6) * 8 + 0x140046a00) + 0x38 + (auStackX8[0] & 0x3f) * 0x48) & 1) != 0)) {\n            apuStack24[0] = auStackX8;\n            auStackX24[0] = auStackX8[0];\n            auStackX32[0] = auStackX8[0];\n            uVar2 = fcn.1400158b0(auStackX16, auStackX32, apuStack24, auStackX24);\n            return uVar2;\n        }\n        puVar1 = fcn.140015830(arg1);\n        *puVar1 = 0;\n        puVar1 = fcn.140015850(arg1);\n        *puVar1 = 9;\n        fcn.140015730();\n    }\n    return 0xffffffff;\n}\n",
        "token_count": 434
    },
    "1400054e": {
        "rules": [
            "check OS version/55c4336dbd964ae3be35b3597c99c1c2"
        ],
        "decompiled_code": "\nvoid fcn.1400054e0(ulong param_1, int64_t param_2, ulong param_3, ulong param_4)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    int32_t iVar3;\n    int64_t iVar4;\n    int64_t lpMultiByteStr;\n    int64_t iVar5;\n    ulong uVar6;\n    ulong arg2;\n    int64_t arg2_00;\n    int64_t iStackX8;\n    uchar auStackX16 [8];\n    ulong uStack32;\n    \n    uStack32 = 0x1400054f8;\n    iVar4 = fcn.140009a10();\n    iVar4 = -iVar4;\n    *(&stack0x00002038 + iVar4) = *0x140037018 ^ &stack0xffffffffffffffe8 + iVar4;\n    if (param_2 == 0) {\n        lpMultiByteStr = *(&stack0x00000008 + iVar4);\n    }\n    else {\n        *(&stack0xffffffffffffffe0 + iVar4) = 0x140005524;\n        lpMultiByteStr = fcn.1400056f0(0x1400278c4);\n        *(&stack0xffffffffffffffe0 + iVar4) = 0x14000552f;\n        iVar5 = fcn.140005210(param_2);\n        if (iVar5 == 0) goto code_r0x0001400056c8;\n        *(&stack0xffffffffffffffe0 + iVar4) = 0x14000554a;\n        arg2_00 = iVar5;\n        iVar1 = fcn.140012068(0x1400278c8, iVar5);\n        *(&stack0xffffffffffffffe0 + iVar4) = 0x140005554;\n        fcn.14000c984(iVar5);\n        if (iVar1 != 0) {\n            *(&stack0xffffffffffffffe0 + iVar4) = 0x140005564;\n            fcn.140001c70(\"LOADER: Failed to set the TMP environment variable.\\n\", arg2_00, param_3, param_4);\n            goto code_r0x0001400056c8;\n        }\n    }\n    *(&stack0xffffffffffffffe0 + iVar4) = 0x140005580;\n    (*_sym.imp.KERNEL32.dll_GetTempPathW)(0x1000, &stack0x00000038 + iVar4);\n    *(&stack0xffffffffffffffe0 + iVar4) = 0x140005585;\n    uVar2 = sub.KERNEL32.dll_GetCurrentProcessId();\n    *(&stack0xffffffffffffffe0 + iVar4) = 0x14000559e;\n    fcn.140006080(&stack0x00000010 + iVar4, 0x10, L\"_MEI%d\", uVar2);\n    iVar1 = 0;\n    do {\n        *(&stack0xffffffffffffffe0 + iVar4) = 0x1400055af;\n        uVar6 = fcn.140013298(&stack0x00000038 + iVar4, &stack0x00000010 + iVar4);\n        *(&stack0xffffffffffffffe0 + iVar4) = 0x1400055ba;\n        iVar3 = fcn.140006560(uVar6);\n        if (iVar3 == 0) {\n            *(&stack0xffffffffffffffe0 + iVar4) = 0x140005657;\n            fcn.1400069c0(param_1, uVar6, 0x1000);\n            *(&stack0xffffffffffffffe0 + iVar4) = 0x14000565f;\n            fcn.14000c984(uVar6);\n            if (param_2 != 0) {\n                *(&stack0xffffffffffffffe0 + iVar4) = 0x140005675;\n                iVar5 = fcn.1400068b0(0, 0x1400278c4, 0);\n                if (lpMultiByteStr == 0) {\n                    *(&stack0xffffffffffffffe0 + iVar4) = 0x1400056bb;\n                    (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableW)(iVar5, 0);\n                }\n                else {\n                    *(&stack0xffffffffffffffe0 + iVar4) = 0x14000568a;\n                    uVar6 = fcn.1400068b0(0, lpMultiByteStr, 0);\n                    *(&stack0xffffffffffffffe0 + iVar4) = 0x140005698;\n                    fcn.140012068(iVar5, uVar6);\n                    *(&stack0xffffffffffffffe0 + iVar4) = 0x1400056a0;\n                    fcn.14000c984(iVar5);\n                    *(&stack0xffffffffffffffe0 + iVar4) = 0x1400056a8;\n                    fcn.14000c984(uVar6);\n                    iVar5 = lpMultiByteStr;\n                }\n                *(&stack0xffffffffffffffe0 + iVar4) = 0x1400056c3;\n                fcn.14000c984(iVar5);\n            }\n            goto code_r0x0001400056c8;\n        }\n        *(&stack0xffffffffffffffe0 + iVar4) = 0x1400055ca;\n        fcn.14000c984(uVar6);\n        iVar1 = iVar1 + 1;\n    } while (iVar1 < 5);\n    if (param_2 != 0) {\n        *(&stack0xffffffffffffffe0 + iVar4) = 0x1400055e7;\n        uVar6 = fcn.1400068b0(0, 0x1400278c4, 0);\n        if (lpMultiByteStr == 0) {\n            *(&stack0xffffffffffffffe0 + iVar4) = 0x140005637;\n            (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableW)(uVar6, 0);\n            *(&stack0xffffffffffffffe0 + iVar4) = 0x14000563f;\n            fcn.14000c984(uVar6);\n        }\n        else {\n            *(&stack0xffffffffffffffe0 + iVar4) = 0x1400055fc;\n            arg2 = fcn.1400068b0(0, lpMultiByteStr, 0);\n            *(&stack0xffffffffffffffe0 + iVar4) = 0x14000560a;\n            fcn.140012068(uVar6, arg2);\n            *(&stack0xffffffffffffffe0 + iVar4) = 0x140005612;\n            fcn.14000c984(uVar6);\n            *(&stack0xffffffffffffffe0 + iVar4) = 0x14000561a;\n            fcn.14000c984(arg2);\n            *(&stack0xffffffffffffffe0 + iVar4) = 0x140005622;\n            fcn.14000c984(lpMultiByteStr);\n        }\n    }\ncode_r0x0001400056c8:\n    *(&stack0xffffffffffffffe0 + iVar4) = 0x1400056d8;\n    fcn.140009a80(*(&stack0x00002038 + iVar4) ^ &stack0xffffffffffffffe8 + iVar4);\n    return;\n}\n",
        "token_count": 1622
    },
    "1400169f": {
        "rules": [
            "hash data with CRC32/3eb9336125364ec68f45469b7e7bd2b9"
        ],
        "decompiled_code": "\nulong fcn.1400169fc(uint64_t arg1, ulong arg2, ulong arg3)\n\n{\n    uint *puVar1;\n    uint32_t uVar2;\n    uint64_t arg1_00;\n    int64_t iVar3;\n    ulong uVar4;\n    \n    uVar2 = arg1;\n    if (uVar2 == 0xfffffffe) {\n        puVar1 = fcn.140015830(arg1);\n        *puVar1 = 0;\n        puVar1 = fcn.140015850(arg1);\n        *puVar1 = 9;\n    }\n    else {\n        if ((-1 < uVar2) && (uVar2 < *0x140046e00)) {\n            iVar3 = uVar2 >> 6;\n            if ((*(*(iVar3 * 8 + 0x140046a00) + 0x38 + (uVar2 & 0x3f) * 0x48) & 1) != 0) {\n                arg1_00 = uVar2 & 0xffffffff;\n                fcn.1400125a0(arg1_00);\n                uVar4 = 0xffffffffffffffff;\n                if ((*(*(iVar3 * 8 + 0x140046a00) + 0x38 + (uVar2 & 0x3f) * 0x48) & 1) == 0) {\n                    puVar1 = fcn.140015850(arg1_00);\n                    *puVar1 = 9;\n                    puVar1 = fcn.140015830(arg1_00);\n                    *puVar1 = 0;\n                }\n                else {\n                    uVar4 = fcn.140016960(arg1 & 0xffffffff, arg2, arg3);\n                }\n                fcn.140012688(arg1 & 0xffffffff);\n                return uVar4;\n            }\n        }\n        puVar1 = fcn.140015830(arg1);\n        *puVar1 = 0;\n        puVar1 = fcn.140015850(arg1);\n        *puVar1 = 9;\n        fcn.140015730();\n    }\n    return 0xffffffffffffffff;\n}\n",
        "token_count": 477
    },
    "140008b8": {
        "rules": [
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498",
            "hash data using murmur3/51beaa2d5a2f415db2ae4fc8ef819b72/938ec34b87fc49598ca2362852471498"
        ],
        "decompiled_code": "\nuint32_t fcn.140008b80(ulong arg1, uint32_t *arg2, ulong arg3)\n\n{\n    uint8_t uVar1;\n    uint64_t uVar2;\n    uint32_t uVar3;\n    uint64_t uVar4;\n    \n    uVar4 = arg3;\n    if (arg2 == NULL) {\n        return 0;\n    }\n    arg1._0_4_ = ~arg1;\n    for (; (uVar4 != 0 && ((arg2 & 3) != 0)); arg2 = arg2 + 1) {\n        arg1._0_4_ = arg1 >> 8 ^ *(((*arg2 ^ arg1) & 0xff) * 4 + 0x140028700);\n        uVar4 = uVar4 - 1;\n    }\n    if (0x1f < uVar4) {\n        uVar2 = uVar4 >> 5;\n        uVar4 = uVar4 + uVar2 * -0x20;\n        do {\n            arg1._0_4_ = arg1 ^ *arg2;\n            uVar3 = *((arg1 >> 0x10) * 4 + 0x140028b00) ^ *((arg1 >> 8) * 4 + 0x140028f00) ^\n                    *((arg1 >> 0x18) * 4 + 0x140028700) ^ *((arg1 & 0xff) * 4 + 0x140029300) ^ arg2[1];\n            uVar3 = *((uVar3 >> 0x10) * 4 + 0x140028b00) ^ *((uVar3 >> 8) * 4 + 0x140028f00) ^\n                    *((uVar3 >> 0x18) * 4 + 0x140028700) ^ *((uVar3 & 0xff) * 4 + 0x140029300) ^ arg2[2];\n            uVar3 = *((uVar3 >> 0x10) * 4 + 0x140028b00) ^ *((uVar3 >> 8) * 4 + 0x140028f00) ^\n                    *((uVar3 >> 0x18) * 4 + 0x140028700) ^ *((uVar3 & 0xff) * 4 + 0x140029300) ^ arg2[3];\n            uVar3 = *((uVar3 >> 0x10) * 4 + 0x140028b00) ^ *((uVar3 >> 8) * 4 + 0x140028f00) ^\n                    *((uVar3 >> 0x18) * 4 + 0x140028700) ^ *((uVar3 & 0xff) * 4 + 0x140029300) ^ arg2[4];\n            uVar3 = *((uVar3 >> 0x10) * 4 + 0x140028b00) ^ *((uVar3 >> 8) * 4 + 0x140028f00) ^\n                    *((uVar3 >> 0x18) * 4 + 0x140028700) ^ *((uVar3 & 0xff) * 4 + 0x140029300) ^ arg2[5];\n            uVar3 = *((uVar3 >> 0x10) * 4 + 0x140028b00) ^ *((uVar3 >> 8) * 4 + 0x140028f00) ^\n                    *((uVar3 >> 0x18) * 4 + 0x140028700) ^ *((uVar3 & 0xff) * 4 + 0x140029300) ^ arg2[6];\n            uVar3 = *((uVar3 >> 0x10) * 4 + 0x140028b00) ^ *((uVar3 >> 8) * 4 + 0x140028f00) ^\n                    *((uVar3 >> 0x18) * 4 + 0x140028700) ^ *((uVar3 & 0xff) * 4 + 0x140029300) ^ arg2[7];\n            arg2 = arg2 + 8;\n            arg1._0_4_ = *((uVar3 >> 0x10) * 4 + 0x140028b00) ^ *((uVar3 >> 8) * 4 + 0x140028f00) ^\n                         *((uVar3 >> 0x18) * 4 + 0x140028700) ^ *((uVar3 & 0xff) * 4 + 0x140029300);\n            uVar2 = uVar2 - 1;\n        } while (uVar2 != 0);\n    }\n    if (3 < uVar4) {\n        uVar2 = uVar4 >> 2;\n        uVar4 = uVar4 + uVar2 * -4;\n        do {\n            arg1._0_4_ = arg1 ^ *arg2;\n            arg2 = arg2 + 1;\n            arg1._0_4_ = *((arg1 >> 0x10) * 4 + 0x140028b00) ^ *((arg1 >> 8) * 4 + 0x140028f00) ^\n                         *((arg1 >> 0x18) * 4 + 0x140028700) ^ *((arg1 & 0xff) * 4 + 0x140029300);\n            uVar2 = uVar2 - 1;\n        } while (uVar2 != 0);\n    }\n    for (; uVar4 != 0; uVar4 = uVar4 - 1) {\n        uVar1 = *arg2;\n        arg2 = arg2 + 1;\n        arg1._0_4_ = arg1 >> 8 ^ *(((uVar1 ^ arg1) & 0xff) * 4 + 0x140028700);\n    }\n    return ~arg1;\n}\n",
        "token_count": 1332
    },
    "14000b06": {
        "rules": [
            "encrypt data using Curve25519/98eda359275044f0933c6ca58186cb36"
        ],
        "decompiled_code": "\nuchar (*) [16] fcn.14000b060(uchar (*arg1) [16], ulong noname_1, uint64_t arg3)\n\n{\n    uchar (*pauVar1) [16];\n    uchar (*pauVar2) [16];\n    uint16_t uVar3;\n    uint64_t uVar5;\n    uchar auVar6 [12];\n    uint32_t uVar4;\n    uchar auVar7 [13];\n    uchar auVar8 [16];\n    uchar uVar9;\n    \n    uVar5 = noname_1 * 0x101010101010101;\n    uVar3 = uVar5;\n    uVar4 = uVar5;\n    if (arg3 < 0x11) {\n        uVar9 = uVar5;\n    // switch table (17 cases) at 0x14004a0b0\n        switch(*(arg3 * 4 + 0x14004a0b0) + 0x140000000) {\n        case 0x14000b190:\n            *(arg1[-1] + arg3 + 1) = uVar5;\n        case 0x14000b194:\n            *(arg1[-1] + arg3 + 9) = uVar4;\n        case 0x14000b197:\n            *(arg1[-1] + arg3 + 0xd) = uVar3;\n        case 0x14000b19b:\n            arg1[-1][arg3 + 0xf] = uVar9;\n            return arg1;\n        case 0x14000b19e:\n            return arg1;\n        case 0x14000b1a0:\n            *(arg1[-1] + arg3 + 4) = uVar5;\n        case 0x14000b1a4:\n            *(arg1[-1] + arg3 + 0xc) = uVar4;\n            return arg1;\n        case 0x14000b1a8:\n            *(arg1[-1] + arg3 + 7) = uVar5;\n            arg1[-1][arg3 + 0xf] = uVar9;\n            return arg1;\n        case 0x14000b1b0:\n            *(arg1[-1] + arg3 + 3) = uVar5;\n        case 0x14000b1b4:\n            *(arg1[-1] + arg3 + 0xb) = uVar4;\n            arg1[-1][arg3 + 0xf] = uVar9;\n            return arg1;\n        case 0x14000b1c0:\n            *(arg1[-1] + arg3 + 2) = uVar5;\n        case 0x14000b1c4:\n            *(arg1[-1] + arg3 + 10) = uVar4;\n        case 0x14000b1c7:\n            *(arg1[-1] + arg3 + 0xe) = uVar3;\n            return arg1;\n        case 0x14000b1cc:\n            **arg1 = uVar5;\n            return arg1;\n        case 0x14000b1d0:\n            **arg1 = uVar5;\n            *(*arg1 + 8) = uVar3;\n            (*arg1)[10] = uVar9;\n            return arg1;\n        case 0x14000b1e0:\n            **arg1 = uVar5;\n            *(*arg1 + 8) = uVar3;\n            return arg1;\n        case 0x14000b1e8:\n            **arg1 = uVar5;\n            *(*arg1 + 8) = uVar5;\n            return arg1;\n        }\n    }\n    uVar9 = SUB141(ZEXT814(uVar5) >> 0x30, 0);\n    auVar7 = ZEXT813(uVar5);\n    auVar6 = ZEXT812(uVar5);\n    auVar8 = CONCAT142(SUB1614(CONCAT133(SUB1613(CONCAT124(SUB1612(CONCAT115(SUB1611(CONCAT106(SUB1610(CONCAT97(SUB169(\n                                                            CONCAT88(SUB168(CONCAT79(SUB167(CONCAT610(SUB166(CONCAT511(\n                                                            SUB165(CONCAT412(SUB164(CONCAT313(SUB163(CONCAT214(SUB162(\n                                                            CONCAT115(SUB161(ZEXT816(uVar5) >> 0x38, 0), \n                                                                      CONCAT114(SUB151(ZEXT815(uVar5) >> 0x38, 0), \n                                                                                ZEXT814(uVar5))) >> 0x70, 0), \n                                                            CONCAT113(uVar9, auVar7)) >> 0x68, 0), \n                                                            CONCAT112(uVar9, auVar6)) >> 0x60, 0), \n                                                            CONCAT111(SUB131(auVar7 >> 0x28, 0), ZEXT811(uVar5))) >>\n                                                            0x58, 0), CONCAT110(SUB121(auVar6 >> 0x28, 0), uVar5)) >>\n                                                            0x50, 0), CONCAT19(SUB131(auVar7 >> 0x20, 0), uVar5)) >>\n                                                            0x48, 0), CONCAT18(SUB121(auVar6 >> 0x20, 0), uVar5)) >>\n                                                            0x40, 0), (uVar5 >> 0x18) << 0x38) >> 0x38, 0), \n                                                            (uVar5 >> 0x18) << 0x30) >> 0x30, 0), \n                                                            (uVar5 >> 0x10) << 0x28) >> 0x28, 0), \n                                                            (uVar5 >> 0x10) << 0x20) >> 0x20, 0), (uVar4 >> 8) << 0x18)\n                                                 >> 0x18, 0), (uVar5 >> 8) << 0x10) >> 0x10, 0), \n                       uVar3 & 0xff | uVar3 << 8);\n    pauVar1 = arg1;\n    if (0x80 < arg3) {\n        if ((*0x140046578 & 2) != 0) {\n            for (; arg3 != 0; arg3 = arg3 - 1) {\n                (*pauVar1)[0] = noname_1;\n                pauVar1 = *pauVar1 + 1;\n            }\n            return arg1;\n        }\n        *arg1 = auVar8;\n        pauVar1 = arg1[1] & 0xfffffffffffffff0;\n        arg3 = arg1 + (arg3 - pauVar1);\n        uVar5 = arg3 >> 7;\n        if (uVar5 != 0) {\n            if (*0x140037038 < uVar5) {\n                do {\n                    *pauVar1 = auVar8;\n                    pauVar1[1] = auVar8;\n                    pauVar2 = pauVar1[8];\n                    pauVar1[2] = auVar8;\n                    pauVar1[3] = auVar8;\n                    uVar5 = uVar5 - 1;\n                    pauVar1[4] = auVar8;\n                    pauVar1[5] = auVar8;\n                    pauVar1[6] = auVar8;\n                    pauVar1[7] = auVar8;\n                    pauVar1 = pauVar2;\n                } while (uVar5 != 0);\n                arg3 = arg3 & 0x7f;\n            }\n            else {\n                do {\n                    *pauVar1 = auVar8;\n                    pauVar1[1] = auVar8;\n                    pauVar2 = pauVar1[8];\n                    pauVar1[2] = auVar8;\n                    pauVar1[3] = auVar8;\n                    uVar5 = uVar5 - 1;\n                    pauVar1[4] = auVar8;\n                    pauVar1[5] = auVar8;\n                    pauVar1[6] = auVar8;\n                    pauVar1[7] = auVar8;\n                    pauVar1 = pauVar2;\n                } while (uVar5 != 0);\n                arg3 = arg3 & 0x7f;\n            }\n        }\n    }\n    for (uVar5 = arg3 >> 4; uVar5 != 0; uVar5 = uVar5 - 1) {\n        *pauVar1 = auVar8;\n        pauVar1 = pauVar1[1];\n    }\n    if ((arg3 & 0xf) != 0) {\n        *(pauVar1[-1] + (arg3 & 0xf)) = auVar8;\n    }\n    return arg1;\n}\n",
        "token_count": 1960
    },
    "1400125a": {
        "rules": [
            "encrypt data using Curve25519/ee72fa54c57a4f96b956b5431c8943ad"
        ],
        "decompiled_code": "\nvoid fcn.1400125a0(ulong arg1)\n\n{\n    // WARNING: Could not recover jumptable at 0x0001400125c0. Too many branches\n    // WARNING: Treating indirect jump as call\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(*((arg1 >> 6) * 8 + 0x140046a00) + (arg1 & 0x3f) * 0x48);\n    return;\n}\n",
        "token_count": 104
    },
    "14001268": {
        "rules": [
            "encrypt data using Curve25519/ee72fa54c57a4f96b956b5431c8943ad"
        ],
        "decompiled_code": "\nvoid fcn.140012688(ulong arg1)\n\n{\n    // WARNING: Could not recover jumptable at 0x0001400126a8. Too many branches\n    // WARNING: Treating indirect jump as call\n    (*_sym.imp.KERNEL32.dll_LeaveCriticalSection)(*((arg1 >> 6) * 8 + 0x140046a00) + (arg1 & 0x3f) * 0x48);\n    return;\n}\n",
        "token_count": 103
    },
    "14001292": {
        "rules": [
            "encrypt data using Curve25519/ee72fa54c57a4f96b956b5431c8943ad"
        ],
        "decompiled_code": "\nuint64_t fcn.140012924(ulong noname_0, uint32_t *arg2, ulong noname_2, uint32_t *arg4)\n\n{\n    uint8_t uVar1;\n    uint64_t uVar2;\n    \n    fcn.14001ad2c(*arg2);\n    uVar1 = *0x140037018 & 0x3f;\n    uVar2 = *0x140037018 ^ *0x140046748;\n    fcn.14001ad80(*arg4);\n    return uVar2 >> uVar1 | uVar2 << 0x40 - uVar1;\n}\n",
        "token_count": 141
    },
    "14001696": {
        "rules": [
            "encrypt data using Curve25519/ee72fa54c57a4f96b956b5431c8943ad"
        ],
        "decompiled_code": "\nint64_t fcn.140016960(ulong arg1, ulong arg2, ulong arg3)\n\n{\n    uint8_t *puVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    int64_t iVar4;\n    uint *puVar5;\n    uint64_t arg1_00;\n    int64_t iStackX32;\n    \n    arg1_00 = arg1 & 0xffffffff;\n    iVar4 = fcn.1400128ac(arg1_00);\n    if (iVar4 == -1) {\n        puVar5 = fcn.140015850(arg1_00);\n        *puVar5 = 9;\n    }\n    else {\n        iVar2 = (*_sym.imp.KERNEL32.dll_SetFilePointerEx)(iVar4, arg2, &iStackX32, arg3);\n        if (iVar2 == 0) {\n            uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n            fcn.1400157e0(uVar3);\n        }\n        else if (iStackX32 != -1) {\n            puVar1 = *((arg1 >> 6) * 8 + 0x140046a00) + 0x38 + (arg1 & 0x3f) * 0x48;\n            *puVar1 = *puVar1 & 0xfd;\n            return iStackX32;\n        }\n    }\n    return -1;\n}\n",
        "token_count": 314
    },
    "140017d0": {
        "rules": [
            "encrypt data using Curve25519/ee72fa54c57a4f96b956b5431c8943ad"
        ],
        "decompiled_code": "\nuint64_t fcn.140017d0c(ulong arg1, ulong arg2, uint32_t *arg3, uint32_t *arg4)\n\n{\n    int64_t *piVar1;\n    ulong arg1_00;\n    int64_t iVar2;\n    uint8_t uVar3;\n    int32_t iVar4;\n    int64_t iVar5;\n    uint64_t uVar6;\n    uint64_t uVar7;\n    \n    uVar7 = arg1;\n    uVar6 = *0x140037018 ^ *(uVar7 * 8 + 0x140046ec0);\n    uVar3 = *0x140037018 & 0x3f;\n    uVar6 = uVar6 >> uVar3 | uVar6 << 0x40 - uVar3;\n    if (uVar6 != 0xffffffffffffffff) {\n        if (uVar6 != 0) {\n            return uVar6;\n        }\n        if (arg3 != arg4) {\n            do {\n                uVar6 = *arg3;\n                iVar5 = *(uVar6 * 8 + 0x140046e20);\n                if (iVar5 == 0) {\n                    arg1_00 = *(uVar6 * 8 + 0x14002c040);\n                    iVar5 = (*_sym.imp.KERNEL32.dll_LoadLibraryExW)(arg1_00, 0);\n                    if (iVar5 == 0) {\n                        iVar4 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n                        if (((iVar4 == 0x57) && (iVar4 = fcn.1400154f0(arg1_00, L\"api-ms-\", 7),  iVar4 != 0)) &&\n                           (iVar4 = fcn.1400154f0(arg1_00, L\"ext-ms-\", 7),  iVar4 != 0)) {\n                            iVar5 = (*_sym.imp.KERNEL32.dll_LoadLibraryExW)(arg1_00, 0, 0);\n                        }\n                        else {\n                            iVar5 = 0;\n                        }\n                    }\n                    if (iVar5 != 0) {\n                        piVar1 = uVar6 * 8 + 0x140046e20;\n                        iVar2 = *piVar1;\n                        *piVar1 = iVar5;\n                        if (iVar2 != 0) {\n                            (*_sym.imp.KERNEL32.dll_FreeLibrary)(iVar5);\n                        }\n                        goto code_r0x000140017e3e;\n                    }\n                    *(uVar6 * 8 + 0x140046e20) = 0xffffffffffffffff;\n                }\n                else if (iVar5 != -1) {\ncode_r0x000140017e3e:\n                    if (iVar5 != 0) goto code_r0x000140017e59;\n                }\n                arg3 = arg3 + 1;\n            } while (arg3 != arg4);\n        }\n        iVar5 = 0;\ncode_r0x000140017e59:\n        if ((iVar5 != 0) && (uVar6 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar5, arg2),  uVar6 != 0)) {\n            uVar3 = 0x40 - (*0x140037018 & 0x3f) & 0x3f;\n            *(uVar7 * 8 + 0x140046ec0) = (uVar6 >> uVar3 | uVar6 << 0x40 - uVar3) ^ *0x140037018;\n            return uVar6;\n        }\n        uVar3 = 0x40 - (*0x140037018 & 0x3f) & 0x3f;\n        *(uVar7 * 8 + 0x140046ec0) = (0xffffffffffffffffU >> uVar3 | -1 << 0x40 - uVar3) ^ *0x140037018;\n    }\n    return 0;\n}\n",
        "token_count": 868
    },
    "14000cbc": {
        "rules": [
            "PEB access/cd8d96519f6244b6acf2796407e948b9",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.14000cbc0(int64_t arg1)\n\n{\n    // WARNING: Could not recover jumptable at 0x00014000cbc4. Too many branches\n    // WARNING: Treating indirect jump as call\n    (*_sym.imp.KERNEL32.dll_EnterCriticalSection)(arg1 + 0x30);\n    return;\n}\n",
        "token_count": 75
    },
    "14000164": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint32_t * fcn.140001640(int64_t arg1, int64_t arg2)\n\n{\n    uint8_t *puVar1;\n    uint8_t *puVar2;\n    int32_t *arg3;\n    uint32_t uVar3;\n    int64_t arg4;\n    \n    arg3 = *(arg1 + 0x10);\n    do {\n        if (*(arg1 + 0x18) <= arg3) {\n            return NULL;\n        }\n        puVar2 = arg3 + 0x12;\n        arg4 = arg2 - puVar2;\n        do {\n            puVar1 = puVar2 + arg4;\n            uVar3 = *puVar2 - *puVar1;\n            if (uVar3 != 0) break;\n            puVar2 = puVar2 + 1;\n        } while (*puVar1 != 0);\n        if (uVar3 == 0) {\n            return arg3;\n        }\n        arg3 = *arg3 + arg3;\n        if (arg3 < *(arg1 + 0x10)) {\n            fcn.140001c70(\"Cannot read Table of Contents.\\n\", uVar3, arg3, arg4);\n            return NULL;\n        }\n    } while( true );\n}\n",
        "token_count": 278
    },
    "14000176": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nuint64_t fcn.140001760(int64_t arg1, int32_t *arg2, ulong arg3, ulong arg4)\n\n{\n    uint64_t uVar1;\n    \n    uVar1 = *arg2 + arg2;\n    if (uVar1 < *(arg1 + 0x10)) {\n        fcn.140001c70(\"Cannot read Table of Contents.\\n\", arg2, arg3, arg4);\n        uVar1 = *(arg1 + 0x18);\n    }\n    return uVar1;\n}\n",
        "token_count": 119
    },
    "140001b2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140001b20(int64_t *arg1)\n\n{\n    if (arg1 != NULL) {\n        if (arg1[2] != 0) {\n            fcn.14000c984(arg1[2]);\n        }\n        if (*arg1 != 0) {\n            fcn.14000bbd4(*arg1);\n            *arg1 = 0;\n        }\n        fcn.14000c984(arg1);\n    }\n    return;\n}\n",
        "token_count": 104
    },
    "140001b6": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint64_t fcn.140001b60(ulong param_1, ulong param_2, ulong param_3, ulong param_4)\n\n{\n    int64_t iVar1;\n    \n    iVar1 = fcn.14000c97c(1, 0x4090);\n    if (iVar1 == 0) {\n        fcn.140001c30(\"calloc\", \"Cannot allocate memory for ARCHIVE_STATUS\\n\", param_3, param_4);\n    }\n    return iVar1;\n}\n",
        "token_count": 109
    },
    "140001c0": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140001c00(ulong arg1, ulong arg2, ulong arg3, ulong arg4)\n\n{\n    ulong uStackX16;\n    ulong uStackX24;\n    ulong uStackX32;\n    \n    uStackX16 = arg2;\n    uStackX24 = arg3;\n    uStackX32 = arg4;\n    fcn.140001d20(arg1, &uStackX16);\n    return;\n}\n",
        "token_count": 97
    },
    "140001c7": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140001c70(ulong arg1, ulong arg2, ulong arg3, ulong arg4)\n\n{\n    ulong arg1_00;\n    uint32_t uVar1;\n    ulong uStackX16;\n    ulong uStackX24;\n    ulong uStackX32;\n    \n    uStackX16 = arg2;\n    uStackX24 = arg3;\n    uStackX32 = arg4;\n    uVar1 = sub.KERNEL32.dll_GetCurrentProcessId();\n    arg1_00 = fcn.14000cb50(2);\n    fcn.140001bb0(arg1_00, \"[%d] \", uVar1, arg4);\n    fcn.140001d20(arg1, &uStackX16);\n    return;\n}\n",
        "token_count": 167
    },
    "140001d2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140001d20(ulong param_1, ulong param_2)\n\n{\n    uint64_t uVar1;\n    uchar *puVar2;\n    int64_t iVar3;\n    uint64_t *puVar4;\n    int64_t iVar5;\n    ulong arg1;\n    ulong uStackX32;\n    ulong uStack16;\n    \n    uStack16 = 0x140001d30;\n    iVar3 = fcn.140009a10();\n    iVar3 = -iVar3;\n    *(&stack0x00001028 + iVar3) = *0x140037018 ^ &stack0xfffffffffffffff8 + iVar3;\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140001d50;\n    puVar4 = fcn.140001ba0();\n    *(&stack0x00000020 + iVar3) = param_2;\n    *(&stack0x00000018 + iVar3) = 0;\n    uVar1 = *puVar4;\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140001d78;\n    fcn.1400100f8(uVar1 | 2, &stack0x00000028 + iVar3, 0x800, param_1);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140001d90;\n    iVar5 = fcn.1400066f0(&stack0x00000828 + iVar3, &stack0x00000028 + iVar3, 0x800);\n    puVar2 = &stack0x00000828;\n    if (iVar5 == 0) {\n        puVar2 = &stack0x00000028;\n    }\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140001dae;\n    arg1 = fcn.14000cb50(2);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140001dc0;\n    fcn.140001bb0(arg1, 0x140025804, puVar2 + iVar3, param_1);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140001dd0;\n    fcn.140009a80(*(&stack0x00001028 + iVar3) ^ &stack0xfffffffffffffff8 + iVar3);\n    return;\n}\n",
        "token_count": 516
    },
    "14000224": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140002240(ulong arg1, ulong arg2, ulong arg3, ulong arg4)\n\n{\n    int32_t iVar1;\n    uint64_t *puVar2;\n    ulong uStackX24;\n    ulong uStackX32;\n    uchar auStack136 [32];\n    ulong uStack104;\n    ulong *puStack96;\n    uchar auStack88 [48];\n    uint64_t uStack40;\n    \n    uStack40 = *0x140037018 ^ auStack136;\n    puStack96 = &uStackX24;\n    uStackX24 = arg3;\n    uStackX32 = arg4;\n    puVar2 = fcn.140001ba0();\n    uStack104 = 0;\n    iVar1 = fcn.1400100f8(*puVar2 | 2, arg1, 0x1000, arg2);\n    if (iVar1 < 0) {\n        iVar1 = -1;\n    }\n    if (iVar1 < 0x1000) {\n        fcn.14001095c(arg1, auStack88);\n    }\n    fcn.140009a80(uStack40 ^ auStack136);\n    return;\n}\n",
        "token_count": 261
    },
    "1400022e": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.1400022e0(int64_t param_1, ulong param_2, int64_t param_3, int64_t param_4)\n\n{\n    uint uVar1;\n    int32_t iVar2;\n    int64_t iVar3;\n    int64_t iVar4;\n    int64_t iVar5;\n    ulong arg1;\n    ulong uVar6;\n    int64_t iVar7;\n    uint64_t arg2;\n    ulong uVar8;\n    ulong unaff_RBX;\n    ulong unaff_RSI;\n    char *arg3;\n    ulong unaff_R12;\n    ulong unaff_R14;\n    ulong unaff_R15;\n    uint auStackX16 [2];\n    int64_t iStackX24;\n    uchar auStackX32 [8];\n    ulong uStack24;\n    \n    uStack24 = 0x1400022ed;\n    iVar3 = fcn.140009a10();\n    iVar3 = -iVar3;\n    *(&stack0x00001020 + iVar3) = *0x140037018 ^ &stack0xfffffffffffffff0 + iVar3;\n    *(&stack0xffffffffffffffe8 + iVar3) = 0x14000230a;\n    iVar2 = fcn.1400039b0();\n    if (iVar2 == 0) {\n        *(param_1 + 0x407c) = 1;\n        *(&stack0xffffffffffffffe8 + iVar3) = 0x140002325;\n        iVar2 = fcn.140003d30(param_1);\n        if (iVar2 == 0) {\n            *(&stack0xffffffffffffffe8 + iVar3) = 0x140002335;\n            iVar2 = fcn.140003780(param_1);\n            if (iVar2 == 0) {\n                *(&stack0xffffffffffffffe8 + iVar3) = 0x140002345;\n                iVar2 = fcn.1400038b0(param_1, param_2, param_3, param_4);\n                if (iVar2 == 0) {\n                    *(&stack0x00001070 + iVar3) = unaff_RSI;\n                    arg2 = *(param_1 + 0x10);\n                    *(&stack0x00001030 + iVar3) = unaff_R15;\n                    *(&stack0xffffffffffffffe8 + iVar3) = 0x14000236e;\n                    iVar4 = (**0x140037cd8)(\"__main__\");\n                    if (iVar4 == 0) {\n                        *(&stack0xffffffffffffffe8 + iVar3) = 0x140002382;\n                        fcn.140001c70(\"Could not get __main__ module.\\n\", param_2, param_3, param_4);\n                    }\n                    else {\n                        *(&stack0x00001040 + iVar3) = unaff_R12;\n                        *(&stack0xffffffffffffffe8 + iVar3) = 0x14000239c;\n                        iVar5 = (**0x140037d18)(iVar4);\n                        if (iVar5 == 0) {\n                            *(&stack0xffffffffffffffe8 + iVar3) = 0x1400023b0;\n                            fcn.140001c70(\"Could not get __main__ module\\'s dict.\\n\", param_2, param_3, param_4);\n                        }\n                        else {\n                            *(&stack0x00001068 + iVar3) = unaff_RBX;\n                            *(&stack0x00001038 + iVar3) = unaff_R14;\n                            if (arg2 < *(param_1 + 0x18)) {\n                                do {\n                                    if (*(arg2 + 0x11) == 's') {\n                                        *(&stack0xffffffffffffffe8 + iVar3) = 0x1400023e9;\n                                        arg1 = fcn.1400012a0(param_1, arg2);\n                                        uVar8 = 0x1000;\n                                        *(&stack0x00000018 + iVar3) = arg2 + 0x12;\n                                        param_4 = param_1 + 0x3078;\n                                        *(&stack0x00000010 + iVar3) = 0x5c;\n                                        arg3 = \"%s%c%s.py\";\n                                        *(&stack0xffffffffffffffe8 + iVar3) = 0x14000241a;\n                                        iVar2 = fcn.1400027b0(&stack0x00000020 + iVar3, 0x1000, \"%s%c%s.py\", param_4);\n                                        if (0xfff < iVar2) {\n                                            *(&stack0xffffffffffffffe8 + iVar3) = 0x14000251d;\n                                            fcn.140001c70(\"Absolute path to script exceeds PATH_MAX\\n\", uVar8, arg3, \n                                                          param_4);\n                                            break;\n                                        }\n                                        *(&stack0xffffffffffffffe8 + iVar3) = 0x140002430;\n                                        uVar6 = (**0x140037d00)(&stack0x00000020 + iVar3);\n                                        *(&stack0xffffffffffffffe8 + iVar3) = 0x140002446;\n                                        uVar8 = uVar6;\n                                        (**0x140037ce0)(iVar4, \"__file__\");\n                                        *(&stack0xffffffffffffffe8 + iVar3) = 0x14000244f;\n                                        (**0x140037c88)(uVar6);\n                                        uVar1 = *(arg2 + 0xc);\n                                        *(&stack0xffffffffffffffe8 + iVar3) = 0x14000245b;\n                                        iVar7 = (**0x140037d90)(arg1, uVar1);\n                                        if (iVar7 == 0) {\n                                            *(&stack0xffffffffffffffe8 + iVar3) = 0x140002504;\n                                            fcn.140001c70(\"Failed to unmarshal code object for %s\\n\", arg2 + 0x12, uVar8\n                                                          , param_4);\n                                            *(&stack0xffffffffffffffe8 + iVar3) = 0x14000250a;\n                                            (**0x140037d38)();\n                                            break;\n                                        }\n                                        *(&stack0xffffffffffffffe8 + iVar3) = 0x14000247a;\n                                        (**0x140037ce0)(iVar4, \"_pyi_main_co\", iVar7);\n                                        *(&stack0xffffffffffffffe8 + iVar3) = 0x140002489;\n                                        param_3 = iVar5;\n                                        iVar7 = (**0x140037d88)(iVar7, iVar5);\n                                        if (iVar7 == 0) {\n                                            *(&stack0xffffffffffffffe8 + iVar3) = 0x1400024e2;\n                                            (**0x140037d38)();\n                                            *(&stack0xffffffffffffffe8 + iVar3) = 0x1400024f2;\n                                            fcn.140001c70(\"Failed to execute script \\'%s\\' due to unhandled exception!\\n\"\n                                                          , arg2 + 0x12, param_3, param_4);\n                                            break;\n                                        }\n                                        *(&stack0xffffffffffffffe8 + iVar3) = 0x140002496;\n                                        fcn.14000c984(arg1);\n                                    }\n                                    *(&stack0xffffffffffffffe8 + iVar3) = 0x1400024a1;\n                                    arg2 = fcn.140001760(param_1, arg2, param_3, param_4);\n                                } while (arg2 < *(param_1 + 0x18));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    *(&stack0xffffffffffffffe8 + iVar3) = 0x140002539;\n    fcn.140009a80(*(&stack0x00001020 + iVar3) ^ &stack0xfffffffffffffff0 + iVar3);\n    return;\n}\n",
        "token_count": 1717
    },
    "1400026b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.1400026b0(int64_t param_1, ulong param_2, ulong param_3, ulong param_4)\n\n{\n    int64_t iVar1;\n    int64_t iVar2;\n    uchar auStackX24 [16];\n    ulong uStack16;\n    \n    uStack16 = 0x1400026bc;\n    iVar1 = fcn.140009a10();\n    iVar1 = -iVar1;\n    *(&stack0x00001018 + iVar1) = *0x140037018 ^ &stack0xfffffffffffffff8 + iVar1;\n    *(&stack0xfffffffffffffff0 + iVar1) = 0x1400026e0;\n    iVar2 = fcn.1400016c0(param_1, \"pyi-windows-manifest-filename\", param_3, param_4);\n    if (iVar2 != 0) {\n        *(&stack0xfffffffffffffff0 + iVar1) = 0x1400026f9;\n        iVar2 = fcn.140002e10(&stack0x00000018 + iVar1, param_1 + 0x3078, iVar2);\n        if (iVar2 == 0) {\n            *(&stack0xfffffffffffffff0 + iVar1) = 0x140002717;\n            fcn.140001c70(\"Path of manifest-file (%s) length exceeds buffer[%d] space\\n\", param_1 + 0x3078, 0x1000, \n                          param_4);\n        }\n        *(&stack0xfffffffffffffff0 + iVar1) = 0x140002721;\n        fcn.1400060e0(&stack0x00000018 + iVar1);\n    }\n    *(&stack0xfffffffffffffff0 + iVar1) = 0x140002731;\n    fcn.140009a80(*(&stack0x00001018 + iVar1) ^ &stack0xfffffffffffffff8 + iVar1);\n    return;\n}\n",
        "token_count": 425
    },
    "14000274": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.140002740(int64_t arg1)\n\n{\n    uint8_t uVar1;\n    uint64_t arg2;\n    ulong in_R8;\n    ulong in_R9;\n    \n    arg2 = *(arg1 + 0x10);\n    if (arg2 < *(arg1 + 0x18)) {\n        do {\n            uVar1 = *(arg2 + 0x11) + 0xa6;\n            if ((uVar1 < 0x1f) && ((0x40000501U >> (uVar1 & 0x1f) & 1) != 0)) {\n                return 1;\n            }\n            arg2 = fcn.140001760(arg1, arg2, in_R8, in_R9);\n        } while (arg2 < *(arg1 + 0x18));\n    }\n    return 0;\n}\n",
        "token_count": 192
    },
    "140002ba": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.140002ba0(int64_t arg1, char *arg2)\n\n{\n    char cVar1;\n    int64_t iVar2;\n    \n    iVar2 = fcn.14000ae88(arg2, 0x5c);\n    if (iVar2 == 0) {\n        iVar2 = fcn.14000ae88(arg2, 0x2f);\n        if (iVar2 == 0) goto code_r0x000140002bd6;\n    }\n    arg2 = iVar2 + 1;\ncode_r0x000140002bd6:\n    arg1 = arg1 - arg2;\n    do {\n        cVar1 = *arg2;\n        arg2[arg1] = cVar1;\n        arg2 = arg2 + 1;\n    } while (cVar1 != '\\0');\n    return 1;\n}\n",
        "token_count": 187
    },
    "140002c8": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140002c80(ulong param_1, ulong param_2, ulong param_3, ulong param_4)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    int64_t iVar3;\n    uchar *lpWideCharStr;\n    ulong uVar4;\n    uchar auStackX24 [16];\n    ulong uStack16;\n    \n    uStack16 = 0x140002c8c;\n    iVar2 = fcn.140009a10();\n    iVar2 = -iVar2;\n    *(&stack0x00002018 + iVar2) = *0x140037018 ^ &stack0xfffffffffffffff8 + iVar2;\n    uVar4 = 0x1000;\n    *(&stack0xfffffffffffffff0 + iVar2) = 0x140002cb7;\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetModuleFileNameW)(0, &stack0x00000018 + iVar2);\n    if (iVar1 == 0) {\n        *(&stack0xfffffffffffffff0 + iVar2) = 0x140002cce;\n        fcn.140001cd0(0x140025ae8, \"Failed to get executable path.\\n\", uVar4, param_4);\n    }\n    else {\n        uVar4 = 0x1000;\n        lpWideCharStr = &stack0x00000018 + iVar2;\n        *(&stack0xfffffffffffffff0 + iVar2) = 0x140002ce5;\n        iVar3 = fcn.1400069c0(param_1, lpWideCharStr, 0x1000);\n        if (iVar3 == 0) {\n            *(&stack0xfffffffffffffff0 + iVar2) = 0x140002cf6;\n            fcn.140001c70(\"Failed to convert executable path to UTF-8.\\n\", lpWideCharStr, uVar4, param_4);\n        }\n    }\n    *(&stack0xfffffffffffffff0 + iVar2) = 0x140002d0f;\n    fcn.140009a80(*(&stack0x00002018 + iVar2) ^ &stack0xfffffffffffffff8 + iVar2);\n    return;\n}\n",
        "token_count": 479
    },
    "140002d2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140002d20(ulong param_1)\n\n{\n    int64_t iVar1;\n    uchar auStackX32 [8];\n    ulong uStack8;\n    \n    uStack8 = 0x140002d2a;\n    iVar1 = fcn.140009a10();\n    iVar1 = -iVar1;\n    *(&stack0x00002060 + iVar1) = *0x140037018 ^ &stack0x00000000 + iVar1;\n    *(&stack0xfffffffffffffff8 + iVar1) = 0x140002d52;\n    fcn.1400068b0(&stack0x00000050 + iVar1, param_1, 0x1000);\n    *(&stack0xfffffffffffffff8 + iVar1) = 0x140002d61;\n    fcn.140010a5c(&stack0x00000050 + iVar1, &stack0x00000020 + iVar1);\n    *(&stack0xfffffffffffffff8 + iVar1) = 0x140002d7a;\n    fcn.140009a80(*(&stack0x00002060 + iVar1) ^ &stack0x00000000 + iVar1);\n    return;\n}\n",
        "token_count": 266
    },
    "140002ed": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.140002ed0(ulong arg1, ulong noname_1, ulong arg3, ulong arg4)\n\n{\n    char *arg2;\n    \n    *0x140037c58 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_DontWriteBytecodeFlag\");\n    if (*0x140037c58 == 0) {\n        arg2 = \"Failed to get address for Py_DontWriteBytecodeFlag\\n\";\n    }\n    else {\n        *0x140037c40 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_FileSystemDefaultEncoding\");\n        if (*0x140037c40 == 0) {\n            arg2 = \"Failed to get address for Py_FileSystemDefaultEncoding\\n\";\n        }\n        else {\n            *0x140037c28 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_FrozenFlag\");\n            if (*0x140037c28 == 0) {\n                arg2 = \"Failed to get address for Py_FrozenFlag\\n\";\n            }\n            else {\n                *0x140037c50 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_IgnoreEnvironmentFlag\");\n                if (*0x140037c50 == 0) {\n                    arg2 = \"Failed to get address for Py_IgnoreEnvironmentFlag\\n\";\n                }\n                else {\n                    *0x140037c30 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_NoSiteFlag\");\n                    if (*0x140037c30 == 0) {\n                        arg2 = \"Failed to get address for Py_NoSiteFlag\\n\";\n                    }\n                    else {\n                        *0x140037c60 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_NoUserSiteDirectory\");\n                        if (*0x140037c60 == 0) {\n                            arg2 = \"Failed to get address for Py_NoUserSiteDirectory\\n\";\n                        }\n                        else {\n                            *0x140037c38 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_OptimizeFlag\");\n                            if (*0x140037c38 == 0) {\n                                arg2 = \"Failed to get address for Py_OptimizeFlag\\n\";\n                            }\n                            else {\n                                *0x140037c48 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_VerboseFlag\");\n                                if (*0x140037c48 == 0) {\n                                    arg2 = \"Failed to get address for Py_VerboseFlag\\n\";\n                                }\n                                else {\n                                    *0x140037c68 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                             (arg1, \"Py_UnbufferedStdioFlag\");\n                                    if (*0x140037c68 == 0) {\n                                        arg2 = \"Failed to get address for Py_UnbufferedStdioFlag\\n\";\n                                    }\n                                    else {\n                                        *0x140037cf8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_BuildValue\");\n                                        if (*0x140037cf8 == 0) {\n                                            arg2 = \"Failed to get address for Py_BuildValue\\n\";\n                                        }\n                                        else {\n                                            *0x140037c88 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"Py_DecRef\");\n                                            if (*0x140037c88 == 0) {\n                                                arg2 = \"Failed to get address for Py_DecRef\\n\";\n                                            }\n                                            else {\n                                                *0x140037c78 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                         (arg1, \"Py_Finalize\");\n                                                if (*0x140037c78 == 0) {\n                                                    arg2 = \"Failed to get address for Py_Finalize\\n\";\n                                                }\n                                                else {\n                                                    *0x140037c80 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                             (arg1, \"Py_IncRef\");\n                                                    if (*0x140037c80 == 0) {\n                                                        arg2 = \"Failed to get address for Py_IncRef\\n\";\n                                                    }\n                                                    else {\n                                                        *0x140037c70 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                 (arg1, \"Py_Initialize\");\n                                                        if (*0x140037c70 == 0) {\n                                                            arg2 = \"Failed to get address for Py_Initialize\\n\";\n                                                        }\n                                                        else {\n                                                            *0x140037ca0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                     (arg1, \"Py_SetPath\");\n                                                            if (*0x140037ca0 == 0) {\n                                                                arg2 = \"Failed to get address for Py_SetPath\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037ca8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \"Py_GetPath\");\n                                                                if (*0x140037ca8 == 0) {\n                                                                    arg2 = \"Failed to get address for Py_GetPath\\n\";\n                                                                }\n                                                                else {\n                                                                    *0x140037c90 = (*\n                                                            _sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                      (arg1, \"Py_SetProgramName\");\n                                                            if (*0x140037c90 == 0) {\n                                                                arg2 = \"Failed to get address for Py_SetProgramName\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037c98 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \"Py_SetPythonHome\");\n                                                                if (*0x140037c98 == 0) {\n                                                                    arg2 = \n                                                            \"Failed to get address for Py_SetPythonHome\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037d20 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \"PyDict_GetItemString\");\n                                                                if (*0x140037d20 == 0) {\n                                                                    arg2 = \n                                                            \"Failed to get address for PyDict_GetItemString\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037d28 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \"PyErr_Clear\");\n                                                                if (*0x140037d28 == 0) {\n                                                                    arg2 = \"Failed to get address for PyErr_Clear\\n\";\n                                                                }\n                                                                else {\n                                                                    *0x140037d30 = (*\n                                                            _sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                      (arg1, \"PyErr_Occurred\");\n                                                            if (*0x140037d30 == 0) {\n                                                                arg2 = \"Failed to get address for PyErr_Occurred\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037d38 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \"PyErr_Print\");\n                                                                if (*0x140037d38 == 0) {\n                                                                    arg2 = \"Failed to get address for PyErr_Print\\n\";\n                                                                }\n                                                                else {\n                                                                    *0x140037d98 = (*\n                                                            _sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyErr_Fetch\");\n                                                            if (*0x140037d98 == 0) {\n                                                                arg2 = \"Failed to get address for PyErr_Fetch\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037da0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \"PyErr_Restore\");\n                                                                if (*0x140037da0 == 0) {\n                                                                    arg2 = \"Failed to get address for PyErr_Restore\\n\";\n                                                                }\n                                                                else {\n                                                                    *0x140037cd8 = (*\n                                                            _sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                      (arg1, \"PyImport_AddModule\");\n                                                            if (*0x140037cd8 == 0) {\n                                                                arg2 = \"Failed to get address for PyImport_AddModule\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037cc8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \n                                                            \"PyImport_ExecCodeModule\");\n                                                            if (*0x140037cc8 == 0) {\n                                                                arg2 = \n                                                            \"Failed to get address for PyImport_ExecCodeModule\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037cd0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \"PyImport_ImportModule\")\n                                                                ;\n                                                                if (*0x140037cd0 == 0) {\n                                                                    arg2 = \n                                                            \"Failed to get address for PyImport_ImportModule\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037cf0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \"PyList_Append\");\n                                                                if (*0x140037cf0 == 0) {\n                                                                    arg2 = \"Failed to get address for PyList_Append\\n\";\n                                                                }\n                                                                else {\n                                                                    *0x140037ce8 = (*\n                                                            _sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyList_New\");\n                                                            if (*0x140037ce8 == 0) {\n                                                                arg2 = \"Failed to get address for PyList_New\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037d48 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \"PyLong_AsLong\");\n                                                                if (*0x140037d48 == 0) {\n                                                                    arg2 = \"Failed to get address for PyLong_AsLong\\n\";\n                                                                }\n                                                                else {\n                                                                    *0x140037d18 = (*\n                                                            _sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                      (arg1, \"PyModule_GetDict\");\n                                                            if (*0x140037d18 == 0) {\n                                                                arg2 = \"Failed to get address for PyModule_GetDict\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037d08 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \"PyObject_CallFunction\")\n                                                                ;\n                                                                if (*0x140037d08 == 0) {\n                                                                    arg2 = \n                                                            \"Failed to get address for PyObject_CallFunction\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037d10 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \n                                                            \"PyObject_CallFunctionObjArgs\");\n                                                            if (*0x140037d10 == 0) {\n                                                                arg2 = \n                                                            \"Failed to get address for PyObject_CallFunctionObjArgs\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037ce0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \"PyObject_SetAttrString\"\n                                                                                         );\n                                                                if (*0x140037ce0 == 0) {\n                                                                    arg2 = \n                                                            \"Failed to get address for PyObject_SetAttrString\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037db0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \"PyObject_GetAttrString\"\n                                                                                         );\n                                                                if (*0x140037db0 == 0) {\n                                                                    arg2 = \n                                                            \"Failed to get address for PyObject_GetAttrString\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037da8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \"PyObject_Str\");\n                                                                if (*0x140037da8 == 0) {\n                                                                    arg2 = \"Failed to get address for PyObject_Str\\n\";\n                                                                }\n                                                                else {\n                                                                    *0x140037cc0 = (*\n                                                            _sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                      (arg1, \"PyRun_SimpleString\");\n                                                            if (*0x140037cc0 == 0) {\n                                                                arg2 = \"Failed to get address for PyRun_SimpleString\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037d40 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \"PySys_AddWarnOption\");\n                                                                if (*0x140037d40 == 0) {\n                                                                    arg2 = \n                                                            \"Failed to get address for PySys_AddWarnOption\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037cb8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \"PySys_SetArgvEx\");\n                                                                if (*0x140037cb8 == 0) {\n                                                                    arg2 = \"Failed to get address for PySys_SetArgvEx\\n\"\n                                                                    ;\n                                                                }\n                                                                else {\n                                                                    *0x140037d68 = (*\n                                                            _sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                      (arg1, \"PySys_GetObject\");\n                                                            if (*0x140037d68 == 0) {\n                                                                arg2 = \"Failed to get address for PySys_GetObject\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037d50 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \"PySys_SetObject\");\n                                                                if (*0x140037d50 == 0) {\n                                                                    arg2 = \"Failed to get address for PySys_SetObject\\n\"\n                                                                    ;\n                                                                }\n                                                                else {\n                                                                    *0x140037cb0 = (*\n                                                            _sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PySys_SetPath\")\n                                                            ;\n                                                            if (*0x140037cb0 == 0) {\n                                                                arg2 = \"Failed to get address for PySys_SetPath\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037d88 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \"PyEval_EvalCode\");\n                                                                if (*0x140037d88 == 0) {\n                                                                    arg2 = \"Failed to get address for PyEval_EvalCode\\n\"\n                                                                    ;\n                                                                }\n                                                                else {\n                                                                    *0x140037d90 = (*\n                                                            _sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                      (arg1, \"PyMarshal_ReadObjectFromString\");\n                                                            if (*0x140037d90 == 0) {\n                                                                arg2 = \n                                                            \"Failed to get address for PyMarshal_ReadObjectFromString\\n\"\n                                                            ;\n                                                            }\n                                                            else {\n                                                                *0x140037d00 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \"PyUnicode_FromString\");\n                                                                if (*0x140037d00 == 0) {\n                                                                    arg2 = \n                                                            \"Failed to get address for PyUnicode_FromString\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037d58 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \"Py_DecodeLocale\");\n                                                                if (*0x140037d58 == 0) {\n                                                                    arg2 = \"Failed to get address for Py_DecodeLocale\\n\"\n                                                                    ;\n                                                                }\n                                                                else {\n                                                                    *0x140037d60 = (*\n                                                            _sym.imp.KERNEL32.dll_GetProcAddress)(arg1, \"PyMem_RawFree\")\n                                                            ;\n                                                            if (*0x140037d60 == 0) {\n                                                                arg2 = \"Failed to get address for PyMem_RawFree\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037d70 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \"PyUnicode_FromFormat\");\n                                                                if (*0x140037d70 == 0) {\n                                                                    arg2 = \n                                                            \"Failed to get address for PyUnicode_FromFormat\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037d80 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \"PyUnicode_Decode\");\n                                                                if (*0x140037d80 == 0) {\n                                                                    arg2 = \n                                                            \"Failed to get address for PyUnicode_Decode\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037d78 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \n                                                            \"PyUnicode_DecodeFSDefault\");\n                                                            if (*0x140037d78 == 0) {\n                                                                arg2 = \n                                                            \"Failed to get address for PyUnicode_DecodeFSDefault\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037db8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \"PyUnicode_AsUTF8\");\n                                                                if (*0x140037db8 == 0) {\n                                                                    arg2 = \n                                                            \"Failed to get address for PyUnicode_AsUTF8\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140037dc0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (arg1, \"PyUnicode_Join\");\n                                                                if (*0x140037dc0 == 0) {\n                                                                    arg2 = \"Failed to get address for PyUnicode_Join\\n\";\n                                                                }\n                                                                else {\n                                                                    *0x140037dc8 = (*\n                                                            _sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                      (arg1, \"PyUnicode_Replace\");\n                                                            if (*0x140037dc8 != 0) {\n                                                                return 0;\n                                                            }\n                                                            arg2 = \"Failed to get address for PyUnicode_Replace\\n\";\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    fcn.140001cd0(0x140025b88, arg2, arg3, arg4);\n    return 0xffffffff;\n}\n",
        "token_count": 3782
    },
    "140003d3": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.140003d30(int64_t arg1)\n\n{\n    int64_t *piVar1;\n    int64_t *piVar2;\n    int32_t iVar3;\n    int64_t iVar4;\n    int64_t iVar5;\n    int64_t *piVar6;\n    char *arg1_00;\n    int64_t *arg2;\n    ulong uVar7;\n    int64_t *in_R9;\n    \n    iVar5 = arg1 + 0x78;\n    uVar7 = 0x1000;\n    iVar4 = fcn.1400068b0(0x140042e40, iVar5, 0x1000);\n    if (iVar4 == 0) {\n        fcn.140001c70(\"Failed to convert progname to wchar_t\\n\", iVar5, uVar7, in_R9);\n        return 0xffffffff;\n    }\n    (**0x140037c90)(0x140042e40);\n    piVar6 = arg1 + 0x3078;\n    uVar7 = 0x1000;\n    arg2 = piVar6;\n    iVar5 = fcn.1400068b0(0x140040e30, piVar6, 0x1000);\n    if (iVar5 == 0) {\n        arg1_00 = \"Failed to convert pyhome to wchar_t\\n\";\n    }\n    else {\n        (**0x140037c98)(0x140040e30);\n        in_R9 = piVar6;\n        iVar3 = fcn.1400027b0(0x140037dd0, 0x3020, \"%s%c%s%c%s%c%s%c%s\", piVar6);\n        if (0x301f < iVar3) {\n            fcn.140001c70(\"sys.path (based on %s) exceeds buffer[%d] space\\n\", piVar6, 0x3020, in_R9);\n            return 0xffffffff;\n        }\n        uVar7 = 0x3020;\n        arg2 = 0x140037dd0;\n        iVar5 = fcn.1400068b0(0x14003adf0, 0x140037dd0, 0x3020);\n        if (iVar5 == 0) {\n            arg1_00 = \"Failed to convert pypath to wchar_t\\n\";\n        }\n        else {\n            (**0x140037ca8)();\n            (**0x140037ca0)(0x14003adf0);\n            fcn.140003b10(arg1);\n            (**0x140037c70)();\n            (**0x140037cb0)();\n            arg2 = *(arg1 + 0x4088);\n            piVar6 = fcn.140006ab0(*(arg1 + 0x4080), arg2);\n            if (piVar6 == NULL) {\n                arg1_00 = \"Failed to convert argv to wchar_t\\n\";\n            }\n            else {\n                uVar7 = 0;\n                arg2 = piVar6;\n                (**0x140037cb8)(*(arg1 + 0x4080));\n                iVar5 = *piVar6;\n                piVar2 = piVar6;\n                while (iVar5 != 0) {\n                    fcn.14000c984(iVar5);\n                    piVar1 = piVar2 + 1;\n                    piVar2 = piVar2 + 1;\n                    iVar5 = *piVar1;\n                }\n                fcn.14000c984(piVar6);\n                iVar5 = (**0x140037d30)();\n                if (iVar5 == 0) {\n                    return 0;\n                }\n                arg1_00 = \"Error detected starting Python VM.\\n\";\n            }\n        }\n    }\n    fcn.140001c70(arg1_00, arg2, uVar7, in_R9);\n    return 0xffffffff;\n}\n",
        "token_count": 849
    },
    "14000443": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.140004430(int64_t arg1)\n\n{\n    int64_t iVar1;\n    ulong uVar2;\n    int64_t iVar3;\n    ulong in_RDX;\n    char *arg2;\n    ulong in_R8;\n    ulong in_R9;\n    \n    uVar2 = fcn.140005eb0(arg1 + 0x10);\n    *(arg1 + 0x4048) = uVar2;\n    iVar3 = fcn.140005eb0(arg1 + 0x1010);\n    iVar1 = *(arg1 + 0x4048);\n    *(arg1 + 0x4050) = iVar3;\n    if ((iVar1 != 0) && (iVar3 != 0)) {\n        *0x140044e80 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, \"Tcl_Init\");\n        if (*0x140044e80 == 0) {\n            arg2 = \"Failed to get address for Tcl_Init\\n\";\n        }\n        else {\n            *0x140044e88 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, \"Tcl_CreateInterp\");\n            if (*0x140044e88 == 0) {\n                arg2 = \"Failed to get address for Tcl_CreateInterp\\n\";\n            }\n            else {\n                *0x140044e90 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, \"Tcl_FindExecutable\");\n                if (*0x140044e90 == 0) {\n                    arg2 = \"Failed to get address for Tcl_FindExecutable\\n\";\n                }\n                else {\n                    *0x140044e98 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, \"Tcl_DoOneEvent\");\n                    if (*0x140044e98 == 0) {\n                        arg2 = \"Failed to get address for Tcl_DoOneEvent\\n\";\n                    }\n                    else {\n                        *0x140044ea0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, \"Tcl_Finalize\");\n                        if (*0x140044ea0 == 0) {\n                            arg2 = \"Failed to get address for Tcl_Finalize\\n\";\n                        }\n                        else {\n                            *0x140044ea8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, \"Tcl_FinalizeThread\");\n                            if (*0x140044ea8 == 0) {\n                                arg2 = \"Failed to get address for Tcl_FinalizeThread\\n\";\n                            }\n                            else {\n                                *0x140044eb0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, \"Tcl_DeleteInterp\");\n                                if (*0x140044eb0 == 0) {\n                                    arg2 = \"Failed to get address for Tcl_DeleteInterp\\n\";\n                                }\n                                else {\n                                    *0x140044eb8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, \"Tcl_CreateThread\");\n                                    if (*0x140044eb8 == 0) {\n                                        arg2 = \"Failed to get address for Tcl_CreateThread\\n\";\n                                    }\n                                    else {\n                                        *0x140044ec0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                 (iVar1, \"Tcl_GetCurrentThread\");\n                                        if (*0x140044ec0 == 0) {\n                                            arg2 = \"Failed to get address for Tcl_GetCurrentThread\\n\";\n                                        }\n                                        else {\n                                            *0x140044ec8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                     (iVar1, \"Tcl_MutexLock\");\n                                            if (*0x140044ec8 == 0) {\n                                                arg2 = \"Failed to get address for Tcl_MutexLock\\n\";\n                                            }\n                                            else {\n                                                *0x140044ed0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                         (iVar1, \"Tcl_MutexUnlock\");\n                                                if (*0x140044ed0 == 0) {\n                                                    arg2 = \"Failed to get address for Tcl_MutexUnlock\\n\";\n                                                }\n                                                else {\n                                                    *0x140044ed8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                             (iVar1, \"Tcl_ConditionFinalize\");\n                                                    if (*0x140044ed8 == 0) {\n                                                        arg2 = \"Failed to get address for Tcl_ConditionFinalize\\n\";\n                                                    }\n                                                    else {\n                                                        *0x140044ee0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                 (iVar1, \"Tcl_ConditionNotify\");\n                                                        if (*0x140044ee0 == 0) {\n                                                            arg2 = \"Failed to get address for Tcl_ConditionNotify\\n\";\n                                                        }\n                                                        else {\n                                                            *0x140044ee8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                     (iVar1, \"Tcl_ConditionWait\");\n                                                            if (*0x140044ee8 == 0) {\n                                                                arg2 = \"Failed to get address for Tcl_ConditionWait\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140044ef0 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (iVar1, \"Tcl_ThreadQueueEvent\")\n                                                                ;\n                                                                if (*0x140044ef0 == 0) {\n                                                                    arg2 = \n                                                            \"Failed to get address for Tcl_ThreadQueueEvent\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140044ef8 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (iVar1, \"Tcl_ThreadAlert\");\n                                                                if (*0x140044ef8 == 0) {\n                                                                    arg2 = \"Failed to get address for Tcl_ThreadAlert\\n\"\n                                                                    ;\n                                                                }\n                                                                else {\n                                                                    *0x140044f00 = (*\n                                                            _sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, \"Tcl_GetVar2\");\n                                                            if (*0x140044f00 == 0) {\n                                                                arg2 = \"Failed to get address for Tcl_GetVar2\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140044f08 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (iVar1, \"Tcl_SetVar2\");\n                                                                if (*0x140044f08 == 0) {\n                                                                    arg2 = \"Failed to get address for Tcl_SetVar2\\n\";\n                                                                }\n                                                                else {\n                                                                    *0x140044f10 = (*\n                                                            _sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                      (iVar1, \"Tcl_CreateObjCommand\");\n                                                            if (*0x140044f10 == 0) {\n                                                                arg2 = \n                                                            \"Failed to get address for Tcl_CreateObjCommand\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140044f18 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (iVar1, \"Tcl_GetString\");\n                                                                if (*0x140044f18 == 0) {\n                                                                    arg2 = \"Failed to get address for Tcl_GetString\\n\";\n                                                                }\n                                                                else {\n                                                                    *0x140044f20 = (*\n                                                            _sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                      (iVar1, \"Tcl_NewStringObj\");\n                                                            if (*0x140044f20 == 0) {\n                                                                arg2 = \"Failed to get address for Tcl_NewStringObj\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140044f28 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (iVar1, \"Tcl_NewByteArrayObj\");\n                                                                if (*0x140044f28 == 0) {\n                                                                    arg2 = \n                                                            \"Failed to get address for Tcl_NewByteArrayObj\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140044f30 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (iVar1, \"Tcl_SetVar2Ex\");\n                                                                if (*0x140044f30 == 0) {\n                                                                    arg2 = \"Failed to get address for Tcl_SetVar2Ex\\n\";\n                                                                }\n                                                                else {\n                                                                    *0x140044f38 = (*\n                                                            _sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                      (iVar1, \"Tcl_GetObjResult\");\n                                                            if (*0x140044f38 == 0) {\n                                                                arg2 = \"Failed to get address for Tcl_GetObjResult\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140044f40 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (iVar1, \"Tcl_EvalFile\");\n                                                                if (*0x140044f40 == 0) {\n                                                                    arg2 = \"Failed to get address for Tcl_EvalFile\\n\";\n                                                                }\n                                                                else {\n                                                                    *0x140044f48 = (*\n                                                            _sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, \"Tcl_EvalEx\");\n                                                            if (*0x140044f48 == 0) {\n                                                                arg2 = \"Failed to get address for Tcl_EvalEx\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140044f50 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (iVar1, \"Tcl_EvalObjv\");\n                                                                if (*0x140044f50 == 0) {\n                                                                    arg2 = \"Failed to get address for Tcl_EvalObjv\\n\";\n                                                                }\n                                                                else {\n                                                                    *0x140044f58 = (*\n                                                            _sym.imp.KERNEL32.dll_GetProcAddress)(iVar1, \"Tcl_Alloc\");\n                                                            if (*0x140044f58 == 0) {\n                                                                arg2 = \"Failed to get address for Tcl_Alloc\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140044f60 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (iVar1, \"Tcl_Free\");\n                                                                if (*0x140044f60 == 0) {\n                                                                    arg2 = \"Failed to get address for Tcl_Free\\n\";\n                                                                }\n                                                                else {\n                                                                    *0x140044f68 = (*\n                                                            _sym.imp.KERNEL32.dll_GetProcAddress)(iVar3, \"Tk_Init\");\n                                                            if (*0x140044f68 == 0) {\n                                                                arg2 = \"Failed to get address for Tk_Init\\n\";\n                                                            }\n                                                            else {\n                                                                *0x140044f70 = (*_sym.imp.KERNEL32.dll_GetProcAddress)\n                                                                                         (iVar3, \"Tk_GetNumMainWindows\")\n                                                                ;\n                                                                if (*0x140044f70 != 0) {\n                                                                    return 0;\n                                                                }\n                                                                arg2 = \n                                                            \"Failed to get address for Tk_GetNumMainWindows\\n\";\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        fcn.140001cd0(0x140025b88, arg2, in_R8, in_R9);\n        return 0xffffffff;\n    }\n    fcn.140001c70(\"LOADER: Failed to load tcl/tk libraries\\n\", in_RDX, in_R8, in_R9);\n    return 0xffffffff;\n}\n",
        "token_count": 2381
    },
    "14000471": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.140004710(int64_t *arg1)\n\n{\n    int64_t iVar1;\n    \n    if (arg1 != NULL) {\n        iVar1 = (**0x140044ec0)();\n        if (arg1[1] == iVar1) {\n            if (*arg1 != 0) {\n                (**0x140044eb0)();\n                *arg1 = 0;\n                return 0;\n            }\n        }\n        else {\n            if (*arg1 != 0) {\n                (**0x140044ec8)(0x140044e70);\n                *0x140044e78 = 1;\n                fcn.140004810(arg1, 1, 0, 0);\n                (**0x140044ee8)(0x140044e68, 0x140044e70, 0);\n                (**0x140044ed0)(0x140044e70);\n                (**0x140044ed8)(0x140044e68);\n            }\n            (**0x140044ea0)();\n            if (arg1[0x809] != 0) {\n                fcn.140005e90(arg1[0x809]);\n                arg1[0x809] = 0;\n                *(arg1 + 0x403c) = 0;\n            }\n            if (arg1[0x80a] != 0) {\n                fcn.140005e90(arg1[0x80a]);\n                arg1[0x80a] = 0;\n                *(arg1 + 0x808) = 0;\n            }\n        }\n    }\n    return 0;\n}\n",
        "token_count": 354
    },
    "140004b9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140004b90(int64_t *arg1)\n\n{\n    int64_t arg1_00;\n    \n    arg1_00 = *arg1;\n    if (arg1_00 != 0) {\n        if (*(arg1_00 + 0x4010) != 0) {\n            fcn.14000c984(*(arg1_00 + 0x4010));\n        }\n        if (*(arg1_00 + 0x4020) != 0) {\n            fcn.14000c984(*(arg1_00 + 0x4020));\n        }\n        if (*(arg1_00 + 0x4030) != 0) {\n            fcn.14000c984(*(arg1_00 + 0x4030));\n        }\n        fcn.14000c984(arg1_00);\n        *arg1 = 0;\n        return;\n    }\n    *arg1 = 0;\n    return;\n}\n",
        "token_count": 210
    },
    "140004c1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint64_t fcn.140004c10(ulong param_1, ulong param_2, ulong param_3, ulong param_4)\n\n{\n    int64_t iVar1;\n    \n    iVar1 = fcn.14000c97c(1, 0x4058);\n    if (iVar1 == 0) {\n        fcn.140001c30(\"calloc\", \"Cannot allocate memory for SPLASH_STATUS.\\n\", param_3, param_4);\n    }\n    return iVar1;\n}\n",
        "token_count": 110
    },
    "14000521": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140005210(ulong param_1, ulong param_2, ulong param_3, ulong param_4)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    int64_t iVar3;\n    int64_t iVar4;\n    uchar *puVar5;\n    ulong unaff_RBX;\n    ulong uVar6;\n    uchar auStackX24 [16];\n    ulong uStack16;\n    \n    uStack16 = 0x14000521c;\n    iVar2 = fcn.140009a10();\n    iVar2 = -iVar2;\n    *(&stack0x00004018 + iVar2) = *0x140037018 ^ &stack0xfffffffffffffff8 + iVar2;\n    uVar6 = 0;\n    *(&stack0xfffffffffffffff0 + iVar2) = 0x14000523e;\n    iVar3 = fcn.1400068b0(0, param_1, 0);\n    if (iVar3 == 0) {\n        *(&stack0xfffffffffffffff0 + iVar2) = 0x140005252;\n        fcn.140001c70(\"LOADER: Failed to convert runtime-tmpdir to a wide string.\\n\", param_1, uVar6, param_4);\n    }\n    else {\n        uVar6 = 0x1000;\n        *(&stack0x00004040 + iVar2) = unaff_RBX;\n        puVar5 = &stack0x00002018 + iVar2;\n        *(&stack0xfffffffffffffff0 + iVar2) = 0x140005278;\n        iVar1 = (*_sym.imp.KERNEL32.dll_ExpandEnvironmentStringsW)(iVar3);\n        *(&stack0xfffffffffffffff0 + iVar2) = 0x140005282;\n        fcn.14000c984(iVar3);\n        if (iVar1 == 0) {\n            *(&stack0xfffffffffffffff0 + iVar2) = 0x140005292;\n            fcn.140001c70(\"LOADER: Failed to expand environment variables in the runtime-tmpdir.\\n\", puVar5, uVar6, \n                          param_4);\n        }\n        else {\n            uVar6 = 0x1000;\n            puVar5 = &stack0x00002018 + iVar2;\n            *(&stack0xfffffffffffffff0 + iVar2) = 0x1400052ae;\n            iVar3 = fcn.140010ea8(0, puVar5, 0x1000);\n            if (iVar3 == 0) {\n                *(&stack0xfffffffffffffff0 + iVar2) = 0x1400052c2;\n                fcn.140001c70(\"LOADER: Failed to obtain the absolute path of the runtime-tmpdir.\\n\", puVar5, uVar6, \n                              param_4);\n            }\n            else {\n                *(&stack0xfffffffffffffff0 + iVar2) = 0x1400052d8;\n                fcn.14000b060(&stack0x00000018 + iVar2, 0, 0x2000);\n                *(&stack0xfffffffffffffff0 + iVar2) = 0x1400052e5;\n                for (iVar4 = fcn.14000afb4(iVar3); iVar4 != 0; iVar4 = fcn.14000afb4(iVar4 + 2)) {\n                    *(&stack0xfffffffffffffff0 + iVar2) = 0x140005309;\n                    fcn.140011974(&stack0x00000018 + iVar2, iVar3, (iVar4 - iVar3 >> 1) + 1);\n                    *(&stack0xfffffffffffffff0 + iVar2) = 0x140005316;\n                    (*_sym.imp.KERNEL32.dll_CreateDirectoryW)(&stack0x00000018 + iVar2, 0);\n                    *(&stack0xfffffffffffffff0 + iVar2) = 0x140005324;\n                }\n                *(&stack0xfffffffffffffff0 + iVar2) = 0x140005337;\n                (*_sym.imp.KERNEL32.dll_CreateDirectoryW)(iVar3, 0);\n            }\n        }\n    }\n    *(&stack0xfffffffffffffff0 + iVar2) = 0x140005352;\n    fcn.140009a80(*(&stack0x00004018 + iVar2) ^ &stack0xfffffffffffffff8 + iVar2);\n    return;\n}\n",
        "token_count": 963
    },
    "14000536": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140005360(ulong param_1, ulong param_2, ulong param_3)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    int64_t arg1;\n    int64_t arg4;\n    int64_t iVar3;\n    int64_t iVar4;\n    uchar auStackX8 [32];\n    ulong uStack32;\n    \n    uStack32 = 0x14000536e;\n    iVar2 = fcn.140009a10();\n    iVar2 = -iVar2;\n    *(&stack0x00001008 + iVar2) = *0x140037018 ^ &stack0xffffffffffffffe8 + iVar2;\n    *(&stack0xffffffffffffffe0 + iVar2) = 0x140005395;\n    arg1 = fcn.140002d90();\n    *(&stack0xffffffffffffffe0 + iVar2) = 0x1400053a3;\n    arg4 = fcn.1400057a0(param_2, param_3);\n    if (arg1 == 0) {\n        arg1 = arg4;\n        if (arg4 == 0) goto code_r0x000140005465;\n    }\n    else if (arg4 != 0) {\n        *(&stack0xffffffffffffffe0 + iVar2) = 0x1400053c2;\n        iVar1 = fcn.14000bc38(arg1);\n        while (iVar1 == 0) {\n            *(&stack0xffffffffffffffe0 + iVar2) = 0x1400053e8;\n            iVar3 = fcn.14000bef0(&stack0x00000008 + iVar2, 1, 0x1000, arg1);\n            if (iVar3 != 0) {\n                *(&stack0xffffffffffffffe0 + iVar2) = 0x140005413;\n                iVar4 = fcn.14000c8f8(&stack0x00000008 + iVar2, 1, iVar3, arg4);\n                iVar3 = arg4;\n                if (iVar4 != 0) {\n                    *(&stack0xffffffffffffffe0 + iVar2) = 0x140005420;\n                    iVar1 = fcn.14000bc64(arg4);\n                    if (iVar1 == 0) goto code_r0x000140005424;\n                }\ncode_r0x000140005435:\n                *(&stack0xffffffffffffffe0 + iVar2) = 0x14000543a;\n                fcn.1400132b4(iVar3);\n                break;\n            }\n            *(&stack0xffffffffffffffe0 + iVar2) = 0x1400053f5;\n            iVar1 = fcn.14000bc64(arg1);\n            iVar3 = arg1;\n            if (iVar1 != 0) goto code_r0x000140005435;\ncode_r0x000140005424:\n            *(&stack0xffffffffffffffe0 + iVar2) = 0x14000542c;\n            iVar1 = fcn.14000bc38(arg1);\n        }\n        *(&stack0xffffffffffffffe0 + iVar2) = 0x140005447;\n        fcn.14000bbd4(arg1);\n        *(&stack0xffffffffffffffe0 + iVar2) = 0x14000544f;\n        fcn.14000bbd4(arg4);\n        goto code_r0x000140005465;\n    }\n    *(&stack0xffffffffffffffe0 + iVar2) = 0x140005460;\n    fcn.14000bbd4(arg1);\ncode_r0x000140005465:\n    *(&stack0xffffffffffffffe0 + iVar2) = 0x140005475;\n    fcn.140009a80(*(&stack0x00001008 + iVar2) ^ &stack0xffffffffffffffe8 + iVar2);\n    return;\n}\n",
        "token_count": 852
    },
    "140005c2": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.140005c20(ulong arg1, ulong arg2)\n\n{\n    uint uVar1;\n    ulong arg1_00;\n    ulong arg2_00;\n    \n    arg1_00 = fcn.1400068b0(0, arg1, 0);\n    arg2_00 = fcn.1400068b0(0, arg2, 0);\n    uVar1 = fcn.140012068(arg1_00, arg2_00);\n    fcn.14000c984(arg1_00);\n    fcn.14000c984(arg2_00);\n    return uVar1;\n}\n",
        "token_count": 140
    },
    "140005c9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "set environment variable"
        ],
        "decompiled_code": "\nuint fcn.140005c90(ulong arg1)\n\n{\n    uint uVar1;\n    ulong arg1_00;\n    \n    arg1_00 = fcn.1400068b0(0, arg1, 0);\n    uVar1 = (*_sym.imp.KERNEL32.dll_SetEnvironmentVariableW)(arg1_00, 0);\n    fcn.14000c984(arg1_00);\n    return uVar1;\n}\n",
        "token_count": 98
    },
    "140005cd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140005cd0(ulong param_1)\n\n{\n    uint32_t uVar1;\n    int32_t iVar2;\n    int64_t iVar3;\n    ulong uVar4;\n    uchar *arg3;\n    ulong arg4;\n    uint auStackX24 [4];\n    ulong uStack16;\n    \n    uStack16 = 0x140005ce0;\n    iVar3 = fcn.140009a10();\n    iVar3 = -iVar3;\n    *(&stack0x000020f8 + iVar3) = *0x140037018 ^ &stack0xfffffffffffffff8 + iVar3;\n    *(&stack0x00000048 + iVar3) = 0;\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140005d11;\n    fcn.1400068b0(&stack0x000000f8 + iVar3, param_1, 0x1000);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140005d20;\n    fcn.140012cf8(0x16, 1);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140005d2a;\n    fcn.140012cf8(2, 1);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140005d34;\n    fcn.140012cf8(0xf, 1);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140005d3e;\n    fcn.140012cf8(0x15, 1);\n    *(&stack0x00000050 + iVar3) = 0x18;\n    *(&stack0x00000058 + iVar3) = 0;\n    *(&stack0x00000060 + iVar3) = 1;\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140005d5d;\n    (*_sym.imp.KERNEL32.dll_GetStartupInfoW)();\n    *(&stack0x00000090 + iVar3) = 0;\n    *(&stack0x00000098 + iVar3) = ZEXT816(0);\n    *(&stack0x000000c4 + iVar3) = 0x101;\n    *(&stack0x000000c8 + iVar3) = 1;\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140005d8b;\n    uVar4 = fcn.14000cb50(0);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140005d93;\n    uVar1 = fcn.1400149ec(uVar4);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140005d9a;\n    uVar4 = fcn.1400128ac(uVar1);\n    *(&stack0x000000d8 + iVar3) = uVar4;\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140005da9;\n    uVar4 = fcn.14000cb50(1);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140005db1;\n    uVar1 = fcn.1400149ec(uVar4);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140005db8;\n    uVar4 = fcn.1400128ac(uVar1);\n    *(&stack0x000000e0 + iVar3) = uVar4;\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140005dc8;\n    uVar4 = fcn.14000cb50(2);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140005dd0;\n    uVar1 = fcn.1400149ec(uVar4);\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140005dd7;\n    uVar4 = fcn.1400128ac(uVar1);\n    *(&stack0x000000e8 + iVar3) = uVar4;\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140005de5;\n    uVar4 = (*_sym.imp.KERNEL32.dll_GetCommandLineW)();\n    arg4 = 0;\n    arg3 = &stack0x00000050 + iVar3;\n    *(&stack0x00000040 + iVar3) = &stack0x00000068 + iVar3;\n    *(&stack0x00000038 + iVar3) = &stack0x00000088 + iVar3;\n    *(&stack0x00000030 + iVar3) = 0;\n    *(&stack0x00000028 + iVar3) = 0;\n    *(&stack0x00000020 + iVar3) = 0;\n    *(&stack0x00000018 + iVar3) = 1;\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140005e27;\n    iVar2 = (*_sym.imp.KERNEL32.dll_CreateProcessW)(&stack0x000000f8 + iVar3, uVar4);\n    if (iVar2 == 0) {\n        *(&stack0xfffffffffffffff0 + iVar3) = 0x140005e64;\n        fcn.140001cd0(0x1400279c8, \"Error creating child process!\\n\", arg3, arg4);\n    }\n    else {\n        *(&stack0xfffffffffffffff0 + iVar3) = 0x140005e3b;\n        (*_sym.imp.KERNEL32.dll_WaitForSingleObject)(*(&stack0x00000068 + iVar3), 0xffffffff);\n        *(&stack0xfffffffffffffff0 + iVar3) = 0x140005e4b;\n        (*_sym.imp.KERNEL32.dll_GetExitCodeProcess)(*(&stack0x00000068 + iVar3), &stack0x00000048 + iVar3);\n    }\n    *(&stack0xfffffffffffffff0 + iVar3) = 0x140005e79;\n    fcn.140009a80(*(&stack0x000020f8 + iVar3) ^ &stack0xfffffffffffffff8 + iVar3);\n    return;\n}\n",
        "token_count": 1372
    },
    "140005eb": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.140005eb0(ulong arg1)\n\n{\n    ulong arg1_00;\n    ulong uVar1;\n    \n    arg1_00 = fcn.1400068b0(0, arg1, 0);\n    uVar1 = (*_sym.imp.KERNEL32.dll_LoadLibraryExW)(arg1_00, 0, 8);\n    fcn.14000c984(arg1_00);\n    return uVar1;\n}\n",
        "token_count": 101
    },
    "1400063c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint64_t * fcn.1400063c0(ulong arg1, int64_t arg2)\n\n{\n    int32_t iVar1;\n    int64_t *arg1_00;\n    int64_t iVar2;\n    char *arg1_01;\n    char *arg2_00;\n    uint64_t uVar3;\n    uint32_t uVar4;\n    uint64_t uVar6;\n    int64_t *piVar7;\n    ulong arg3;\n    ulong uVar8;\n    ulong arg4;\n    uint64_t uVar5;\n    \n    arg1_00 = fcn.14000c97c(arg1 + 1, 8);\n    if (arg1_00 == NULL) {\n        return NULL;\n    }\n    uVar3 = 0;\n    if (0 < arg1) {\n        uVar5 = uVar3;\n        uVar6 = uVar3;\n        piVar7 = arg1_00;\n        do {\n            uVar8 = *((arg2 - arg1_00) + piVar7);\n            arg4 = 0xffffffff;\n            arg3 = uVar8;\n            iVar1 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0xfde9, 0, uVar8, 0xffffffff, 0, 0, 0, 0);\n            if (iVar1 == 0) {\n                arg2_00 = \"Failed to get UTF-8 buffer size.\\n\";\ncode_r0x0001400064f7:\n                arg1_01 = 0x140027ab8;\ncode_r0x0001400064fe:\n                fcn.140001cd0(arg1_01, arg2_00, arg3, arg4);\n                *piVar7 = 0;\n                if (-1 < uVar6) {\n                    do {\n                        fcn.14000c984(arg1_00[uVar3]);\n                        uVar3 = uVar3 + 1;\n                    } while (uVar3 <= uVar6);\n                }\n                fcn.14000c984(arg1_00);\n                return NULL;\n            }\n            iVar2 = fcn.14000c97c(iVar1 + 1, 1);\n            if (iVar2 == 0) {\n                arg2_00 = \"Out of memory.\\n\";\n                arg1_01 = \"win32_utils_to_utf8\";\n                goto code_r0x0001400064fe;\n            }\n            arg4 = 0xffffffff;\n            iVar1 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0xfde9);\n            if (iVar1 == 0) {\n                arg2_00 = \"Failed to encode wchar_t as UTF-8.\\n\";\n                arg3 = uVar8;\n                goto code_r0x0001400064f7;\n            }\n            *piVar7 = iVar2;\n            uVar4 = uVar5 + 1;\n            uVar5 = uVar4;\n            piVar7 = piVar7 + 1;\n            uVar6 = uVar6 + 1;\n        } while (uVar4 < arg1);\n    }\n    arg1_00[arg1] = 0;\n    return arg1_00;\n}\n",
        "token_count": 707
    },
    "1400066f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint64_t fcn.1400066f0(int64_t arg1, ulong lpMultiByteStr, ulong arg3)\n\n{\n    int32_t iVar1;\n    int64_t arg1_00;\n    int64_t arg2;\n    char *arg1_01;\n    char *arg2_00;\n    int64_t arg3_00;\n    ulong arg4;\n    ulong uVar2;\n    \n    arg4 = 0xffffffff;\n    uVar2 = lpMultiByteStr;\n    iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0xfde9, 0, lpMultiByteStr, 0xffffffff, 0, 0);\n    if (iVar1 == 0) {\n        fcn.140001cd0(0x140027bb0, \"Failed to get wchar_t buffer size.\\n\", uVar2, arg4);\n        return 0;\n    }\n    arg1_00 = fcn.14000c97c(iVar1 + 1, 2);\n    if (arg1_00 == 0) {\n        fcn.140001cd0(\"win32_utils_from_utf8\", \"Out of memory.\\n\", uVar2, arg4);\n        return 0;\n    }\n    uVar2 = 0xffffffff;\n    iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0xfde9, 0, lpMultiByteStr, 0xffffffff, arg1_00, iVar1);\n    if (iVar1 == 0) {\n        fcn.140001cd0(0x140027bb0, \"Failed to decode wchar_t from UTF-8\\n\", lpMultiByteStr, uVar2);\n        return 0;\n    }\n    uVar2 = 0xffffffff;\n    arg3_00 = arg1_00;\n    iVar1 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, arg1_00, 0xffffffff, 0, 0, 0, 0);\n    if (iVar1 == 0) {\n        arg2_00 = \"Failed to get ANSI buffer size.\\n\";\n    }\n    else {\n        arg2 = fcn.14000c97c(iVar1 + 1, 1);\n        if (arg2 == 0) {\n            arg1_01 = \"win32_wcs_to_mbs\";\n            arg2_00 = \"Out of memory.\\n\";\n            goto code_r0x000140006853;\n        }\n        uVar2 = 0xffffffff;\n        arg3_00 = arg1_00;\n        iVar1 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0, 0, arg1_00, 0xffffffff, arg2, iVar1, 0, 0);\n        if (iVar1 != 0) {\n            fcn.14000c984(arg1_00);\n            if (arg1 == 0) {\n                return arg2;\n            }\n            fcn.140011810(arg1, arg2, arg3);\n            fcn.14000c984(arg2);\n            return arg1;\n        }\n        arg2_00 = \"Failed to encode filename as ANSI.\\n\";\n    }\n    arg1_01 = 0x140027ab8;\ncode_r0x000140006853:\n    fcn.140001cd0(arg1_01, arg2_00, arg3_00, uVar2);\n    fcn.14000c984(arg1_00);\n    return 0;\n}\n",
        "token_count": 775
    },
    "1400069c": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint64_t fcn.1400069c0(int64_t arg1, ulong lpWideCharStr, ulong arg3)\n\n{\n    int32_t iVar1;\n    ulong arg4;\n    ulong uVar2;\n    \n    if (arg1 == 0) {\n        arg4 = 0xffffffff;\n        uVar2 = lpWideCharStr;\n        arg3._0_4_ = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0xfde9, 0, lpWideCharStr, 0xffffffff, 0, 0, 0, 0);\n        if (arg3 == 0) {\n            fcn.140001cd0(0x140027ab8, \"Failed to get UTF-8 buffer size.\\n\", uVar2, arg4);\n            return 0;\n        }\n        arg1 = fcn.14000c97c(arg3 + 1, 1);\n        if (arg1 == 0) {\n            fcn.140001cd0(\"win32_utils_to_utf8\", \"Out of memory.\\n\", uVar2, arg4);\n            return 0;\n        }\n    }\n    uVar2 = 0xffffffff;\n    iVar1 = (*_sym.imp.KERNEL32.dll_WideCharToMultiByte)(0xfde9, 0, lpWideCharStr, 0xffffffff, arg1, arg3, 0, 0);\n    if (iVar1 == 0) {\n        fcn.140001cd0(0x140027ab8, \"Failed to encode wchar_t as UTF-8.\\n\", lpWideCharStr, uVar2);\n        arg1 = 0;\n    }\n    return arg1;\n}\n",
        "token_count": 371
    },
    "140006ab": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint64_t * fcn.140006ab0(ulong arg1, int64_t arg2)\n\n{\n    int32_t iVar1;\n    int64_t *arg1_00;\n    int64_t iVar2;\n    char *arg1_01;\n    char *arg2_00;\n    uint64_t uVar3;\n    uint32_t uVar4;\n    uint64_t uVar6;\n    int64_t *piVar7;\n    ulong arg3;\n    ulong uVar8;\n    ulong arg4;\n    uint64_t uVar5;\n    \n    arg1_00 = fcn.14000c97c(arg1 + 1, 8);\n    if (arg1_00 == NULL) {\n        return NULL;\n    }\n    uVar3 = 0;\n    if (0 < arg1) {\n        uVar5 = uVar3;\n        uVar6 = uVar3;\n        piVar7 = arg1_00;\n        do {\n            uVar8 = *((arg2 - arg1_00) + piVar7);\n            arg4 = 0xffffffff;\n            arg3 = uVar8;\n            iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0xfde9, 0, uVar8, 0xffffffff, 0, 0);\n            if (iVar1 == 0) {\n                arg2_00 = \"Failed to get wchar_t buffer size.\\n\";\ncode_r0x000140006bcc:\n                arg1_01 = 0x140027bb0;\ncode_r0x000140006bd3:\n                fcn.140001cd0(arg1_01, arg2_00, arg3, arg4);\n                *piVar7 = 0;\n                if (-1 < uVar6) {\n                    do {\n                        fcn.14000c984(arg1_00[uVar3]);\n                        uVar3 = uVar3 + 1;\n                    } while (uVar3 <= uVar6);\n                }\n                fcn.14000c984(arg1_00);\n                return NULL;\n            }\n            iVar2 = fcn.14000c97c(iVar1 + 1, 2);\n            if (iVar2 == 0) {\n                arg2_00 = \"Out of memory.\\n\";\n                arg1_01 = \"win32_utils_from_utf8\";\n                goto code_r0x000140006bd3;\n            }\n            arg4 = 0xffffffff;\n            iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0xfde9);\n            if (iVar1 == 0) {\n                arg2_00 = \"Failed to decode wchar_t from UTF-8\\n\";\n                arg3 = uVar8;\n                goto code_r0x000140006bcc;\n            }\n            *piVar7 = iVar2;\n            uVar4 = uVar5 + 1;\n            uVar5 = uVar4;\n            piVar7 = piVar7 + 1;\n            uVar6 = uVar6 + 1;\n        } while (uVar4 < arg1);\n    }\n    arg1_00[arg1] = 0;\n    return arg1_00;\n}\n",
        "token_count": 694
    },
    "14000878": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.140008780(int64_t arg1, int64_t arg2, uint64_t arg3)\n\n{\n    int64_t iVar1;\n    int32_t iVar2;\n    int64_t arg1_00;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    \n    iVar1 = *(arg1 + 0x28);\n    uVar3 = arg3 & 0xffffffff;\n    arg1_00 = *(iVar1 + 0x40);\n    if (arg1_00 == 0) {\n        arg1_00 = (**(arg1 + 0x30))(*(arg1 + 0x40), 1 << (*(iVar1 + 0x30) & 0x1f));\n        *(iVar1 + 0x40) = arg1_00;\n        if (arg1_00 == 0) {\n            return 1;\n        }\n    }\n    uVar4 = *(iVar1 + 0x34);\n    if (uVar4 == 0) {\n        uVar4 = 1 << (*(iVar1 + 0x30) & 0x1f);\n        *(iVar1 + 0x34) = uVar4;\n        *(iVar1 + 0x38) = 0;\n    }\n    if (uVar3 < uVar4) {\n        uVar4 = uVar4 - *(iVar1 + 0x3c);\n        if (uVar3 < uVar4) {\n            uVar4 = uVar3;\n        }\n        fcn.14000a790(*(iVar1 + 0x3c) + arg1_00, arg2 - (arg3 & 0xffffffff), uVar4);\n        uVar3 = uVar3 - uVar4;\n        if (uVar3 == 0) {\n            *(iVar1 + 0x3c) = *(iVar1 + 0x3c) + uVar4;\n            iVar2 = *(iVar1 + 0x3c);\n            if (*(iVar1 + 0x3c) == *(iVar1 + 0x34)) {\n                iVar2 = 0;\n            }\n            *(iVar1 + 0x3c) = iVar2;\n            if (*(iVar1 + 0x34) <= *(iVar1 + 0x38)) {\n                return 0;\n            }\n            iVar2 = *(iVar1 + 0x38) + uVar4;\n        }\n        else {\n            fcn.14000a790(*(iVar1 + 0x40), arg2 - uVar3, uVar3);\n            iVar2 = *(iVar1 + 0x34);\n            *(iVar1 + 0x3c) = uVar3;\n        }\n    }\n    else {\n        fcn.14000a790(arg1_00, arg2 - uVar4, uVar4);\n        iVar2 = *(iVar1 + 0x34);\n        *(iVar1 + 0x3c) = 0;\n    }\n    *(iVar1 + 0x38) = iVar2;\n    return 0;\n}\n",
        "token_count": 675
    },
    "140017ca": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nint64_t fcn.140017cac(uint64_t arg1)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    uint *puVar3;\n    uint64_t arg1_00;\n    \n    if (arg1 < 0xffffffffffffffe1) {\n        arg1_00 = arg1;\n        if (arg1 == 0) {\n            arg1_00 = 1;\n        }\n        do {\n            arg1 = *0x140047250;\n            iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x140047250, 0, arg1_00);\n            if (iVar2 != 0) {\n                return iVar2;\n            }\n            iVar1 = fcn.14001439c();\n        } while ((iVar1 != 0) && (arg1 = arg1_00,  iVar1 = fcn.14001da14(arg1_00),  iVar1 != 0));\n    }\n    puVar3 = fcn.140015850(arg1);\n    *puVar3 = 0xc;\n    return 0;\n}\n",
        "token_count": 240
    },
    "14001587": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140015870(int64_t lpMem)\n\n{\n    uint *puVar1;\n    int32_t iVar2;\n    uint32_t uVar3;\n    uint uVar4;\n    ulong arg1;\n    \n    if ((lpMem != 0) &&\n       (arg1 = *0x140047250,  iVar2 = (*_sym.imp.KERNEL32.dll_HeapFree)(*0x140047250, 0, lpMem),  iVar2 == 0)) {\n        puVar1 = fcn.140015850(arg1);\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        uVar4 = fcn.140015798(uVar3);\n        *puVar1 = uVar4;\n    }\n    return;\n}\n",
        "token_count": 168
    },
    "14000a53": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.14000a530(void)\n\n{\n    int64_t *piVar1;\n    \n    for (piVar1 = 0x140033c18; piVar1 < 0x140033c18; piVar1 = piVar1 + 1) {\n        if (*piVar1 != 0) {\n            (**0x140025338)();\n        }\n    }\n    return;\n}\n",
        "token_count": 88
    },
    "14000b6f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.14000b6f8(void)\n\n{\n    uint64_t uVar1;\n    \n    uVar1 = *0x140046638;\n    while (uVar1 != 0) {\n        uVar1 = uVar1 - 1;\n        (*_sym.imp.KERNEL32.dll_DeleteCriticalSection)(uVar1 * 0x28 + 0x140046610);\n        *0x140046638 = *0x140046638 - 1;\n    }\n    return 1;\n}\n",
        "token_count": 112
    },
    "14000c69": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.14000c698(int64_t arg1)\n\n{\n    uint *puVar1;\n    ulong uVar2;\n    \n    if (arg1 == 0) {\n        puVar1 = fcn.140015850(0);\n        *puVar1 = 0x16;\n        fcn.140015730();\n        uVar2 = 0xffffffffffffffff;\n    }\n    else {\n        fcn.14000cbc0(arg1);\n        uVar2 = fcn.14000c21c(arg1);\n        fcn.14000cbcc(arg1);\n    }\n    return uVar2;\n}\n",
        "token_count": 135
    },
    "14000c6a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.14000c6a8(ulong noname_0, ulong *arg2, ulong arg3, ulong *arg4)\n\n{\n    ulong uVar1;\n    \n    fcn.14000cbc0(*arg2);\n    uVar1 = fcn.14000c6e8(arg3);\n    fcn.14000cbcc(*arg4);\n    return uVar1;\n}\n",
        "token_count": 88
    },
    "14000cce": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nuint fcn.14000cce0(ulong noname_0, ulong *arg2, ulong arg3, ulong *arg4)\n\n{\n    uint uVar1;\n    \n    fcn.14000cbc0(*arg2);\n    uVar1 = fcn.14000d6cc(arg3);\n    fcn.14000cbcc(*arg4);\n    return uVar1;\n}\n",
        "token_count": 85
    },
    "14001006": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.14001006c(ulong arg1, int64_t arg2, int64_t arg3, ulong arg4, ulong arg_30h)\n\n{\n    uint *puVar1;\n    ulong uVar2;\n    int64_t var_10h;\n    ulong var_18h;\n    ulong var_20h;\n    int64_t var_28h;\n    ulong var_40h;\n    int64_t var_38h;\n    int64_t var_30h;\n    ulong *var_28h_2;\n    ulong *var_20h_2;\n    ulong *var_18h_2;\n    ulong *var_10h_2;\n    ulong *var_8h;\n    \n    var_40h = arg_30h;\n    var_10h = arg2;\n    var_18h = arg4;\n    var_20h = arg1;\n    var_28h = arg3;\n    if ((arg2 == 0) || (arg3 == 0)) {\n        puVar1 = fcn.140015850(arg1);\n        *puVar1 = 0x16;\n        fcn.140015730();\n        uVar2 = 0xffffffff;\n    }\n    else {\n        var_28h_2 = &var_10h;\n        var_20h_2 = &var_18h;\n        var_18h_2 = &var_20h;\n        var_10h_2 = &var_28h;\n        var_8h = &var_40h;\n        var_38h = arg2;\n        var_30h = arg2;\n        uVar2 = fcn.14000cce0(&arg_30h, &var_30h, &var_28h_2, &var_38h);\n    }\n    return uVar2;\n}\n",
        "token_count": 401
    },
    "14001125": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.140011250(uint *arg1)\n\n{\n    uint *puVar1;\n    ulong uVar2;\n    \n    if (arg1 == NULL) {\n        puVar1 = fcn.140015850(0);\n        *puVar1 = 0x16;\n        fcn.140015730();\n        uVar2 = 0x16;\n    }\n    else {\n        *arg1 = *0x140046fe8;\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 115
    },
    "1400120a": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.1400120a0(ulong lpPathName)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    ulong uVar3;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_RemoveDirectoryW)();\n    if (iVar1 == 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        fcn.1400157e0(uVar2);\n        uVar3 = 0xffffffff;\n    }\n    else {\n        uVar3 = 0;\n    }\n    return uVar3;\n}\n",
        "token_count": 125
    },
    "140012ed": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.140012ed4(ulong lpFileName)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    ulong uVar3;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_DeleteFileW)();\n    if (iVar1 == 0) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetLastError)();\n        fcn.1400157e0(uVar2);\n        uVar3 = 0xffffffff;\n    }\n    else {\n        uVar3 = 0;\n    }\n    return uVar3;\n}\n",
        "token_count": 123
    },
    "140013db": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140013db8(int64_t *arg1)\n\n{\n    if (*arg1 != *0x140046998) {\n        fcn.140013bec(*arg1);\n    }\n    return;\n}\n",
        "token_count": 48
    },
    "140013dd": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140013dd4(int64_t *arg1)\n\n{\n    if (*arg1 != *0x140046990) {\n        fcn.140013bec(*arg1);\n    }\n    return;\n}\n",
        "token_count": 48
    },
    "14001396": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.140013968(void)\n\n{\n    int64_t iVar1;\n    ulong uVar2;\n    int64_t arg1;\n    int64_t iVar3;\n    \n    uVar2 = 0;\n    if (*0x140046988 == 0) {\n        arg1 = fcn.14001cee0();\n        if (arg1 == 0) {\n            uVar2 = 0xffffffff;\n        }\n        else {\n            iVar3 = fcn.140013ad8(arg1);\n            iVar1 = iVar3;\n            if (iVar3 == 0) {\n                uVar2 = 0xffffffff;\n                iVar3 = *0x140046988;\n                iVar1 = *0x140046990;\n            }\n            *0x140046990 = iVar1;\n            *0x140046988 = iVar3;\n            fcn.140015870(0);\n        }\n        fcn.140015870(arg1);\n    }\n    else {\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 226
    },
    "14001478": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nvoid fcn.14001478c(ulong arg1, ulong arg2)\n\n{\n    ulong uStackX8;\n    ulong uStackX16;\n    ulong var_20h_2;\n    ulong var_28h;\n    ulong var_20h;\n    ulong *var_18h;\n    ulong *var_bp_10h;\n    \n    var_18h = &uStackX8;\n    var_bp_10h = &uStackX16;\n    var_28h._0_4_ = 2;\n    var_20h._0_4_ = 2;\n    uStackX8 = arg1;\n    uStackX16 = arg2;\n    fcn.1400143d8(&var_20h_2, &var_20h, &var_18h, &var_28h);\n    return;\n}\n",
        "token_count": 194
    },
    "140018de": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140018de0(int64_t arg1, int64_t *arg2)\n\n{\n    int64_t iVar1;\n    \n    if ((*arg2 != *0x140046fe0) && ((*0x14003742c & *(arg1 + 0x3a8)) == 0)) {\n        iVar1 = fcn.14001d7b8(arg1);\n        *arg2 = iVar1;\n    }\n    return;\n}\n",
        "token_count": 100
    },
    "140018e1": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140018e14(int64_t arg1, int64_t *arg2)\n\n{\n    int64_t iVar1;\n    \n    if ((*arg2 != *0x140047238) && ((*0x14003742c & *(arg1 + 0x3a8)) == 0)) {\n        iVar1 = fcn.14001cb04(arg1);\n        *arg2 = iVar1;\n    }\n    return;\n}\n",
        "token_count": 97
    },
    "14001a65": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.14001a650(ulong arg1, ulong arg2)\n\n{\n    fcn.14001a468(0, arg1, arg2);\n    return;\n}\n",
        "token_count": 40
    },
    "14001ad4": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.14001ad48(void)\n\n{\n    uint64_t uVar1;\n    \n    uVar1 = *0x140047220;\n    while (uVar1 != 0) {\n        uVar1 = uVar1 - 1;\n        (*_sym.imp.KERNEL32.dll_DeleteCriticalSection)(uVar1 * 0x28 + 0x140046ff0);\n        *0x140047220 = *0x140047220 - 1;\n    }\n    return 1;\n}\n",
        "token_count": 111
    },
    "14001cfe": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.14001cfec(int64_t arg1)\n\n{\n    if (arg1 != 0) {\n        if (*(arg1 + 0x18) != *0x1400379a8) {\n            fcn.140015870(*(arg1 + 0x18));\n        }\n        if (*(arg1 + 0x20) != *0x1400379b0) {\n            fcn.140015870(*(arg1 + 0x20));\n        }\n        if (*(arg1 + 0x28) != *0x1400379b8) {\n            fcn.140015870(*(arg1 + 0x28));\n        }\n        if (*(arg1 + 0x30) != *0x1400379c0) {\n            fcn.140015870(*(arg1 + 0x30));\n        }\n        if (*(arg1 + 0x38) != *0x1400379c8) {\n            fcn.140015870(*(arg1 + 0x38));\n        }\n        if (*(arg1 + 0x40) != *0x1400379d0) {\n            fcn.140015870(*(arg1 + 0x40));\n        }\n        if (*(arg1 + 0x48) != *0x1400379d8) {\n            fcn.140015870(*(arg1 + 0x48));\n        }\n        if (*(arg1 + 0x68) != *0x1400379f8) {\n            fcn.140015870(*(arg1 + 0x68));\n        }\n        if (*(arg1 + 0x70) != *0x140037a00) {\n            fcn.140015870(*(arg1 + 0x70));\n        }\n        if (*(arg1 + 0x78) != *0x140037a08) {\n            fcn.140015870(*(arg1 + 0x78));\n        }\n        if (*(arg1 + 0x80) != *0x140037a10) {\n            fcn.140015870(*(arg1 + 0x80));\n        }\n        if (*(arg1 + 0x88) != *0x140037a18) {\n            fcn.140015870(*(arg1 + 0x88));\n        }\n        if (*(arg1 + 0x90) != *0x140037a20) {\n            fcn.140015870(*(arg1 + 0x90));\n        }\n    }\n    return;\n}\n",
        "token_count": 547
    },
    "14001d0f": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.14001d0f8(int64_t *arg1)\n\n{\n    if (arg1 != NULL) {\n        if (*arg1 != *0x140037990) {\n            fcn.140015870(*arg1);\n        }\n        if (arg1[1] != *0x140037998) {\n            fcn.140015870(arg1[1]);\n        }\n        if (arg1[2] != *0x1400379a0) {\n            fcn.140015870(arg1[2]);\n        }\n        if (arg1[0xb] != *0x1400379e8) {\n            fcn.140015870(arg1[0xb]);\n        }\n        if (arg1[0xc] != *0x1400379f0) {\n            fcn.140015870(arg1[0xc]);\n        }\n    }\n    return;\n}\n",
        "token_count": 195
    },
    "14001f80": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.14001f800(uint *arg1)\n\n{\n    uint *puVar1;\n    ulong uVar2;\n    \n    if (arg1 == NULL) {\n        puVar1 = fcn.140015850(0);\n        *puVar1 = 0x16;\n        fcn.140015730();\n        uVar2 = 0x16;\n    }\n    else {\n        *arg1 = *0x140047264;\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 115
    },
    "14001f83": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.14001f830(uint *arg1)\n\n{\n    uint *puVar1;\n    ulong uVar2;\n    \n    if (arg1 == NULL) {\n        puVar1 = fcn.140015850(0);\n        *puVar1 = 0x16;\n        fcn.140015730();\n        uVar2 = 0x16;\n    }\n    else {\n        *arg1 = *0x140047268;\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 115
    },
    "14001f86": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nulong fcn.14001f860(uint *arg1)\n\n{\n    uint *puVar1;\n    ulong uVar2;\n    \n    if (arg1 == NULL) {\n        puVar1 = fcn.140015850(0);\n        *puVar1 = 0x16;\n        fcn.140015730();\n        uVar2 = 0x16;\n    }\n    else {\n        *arg1 = *0x140047260;\n        uVar2 = 0;\n    }\n    return uVar2;\n}\n",
        "token_count": 115
    },
    "14002392": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55"
        ],
        "decompiled_code": "\nvoid fcn.140023920(ulong param_1, ulong param_2, ulong param_3)\n\n{\n    fcn.140023940(param_1, param_2, param_3, 0x1b);\n    return;\n}\n",
        "token_count": 54
    },
    "1400060e": {
        "rules": [
            "execute .NET assembly via CLR host/2c9ef85a2fe94af39efaaae3fc9e6a8a"
        ],
        "decompiled_code": "\nulong fcn.1400060e0(ulong lpMultiByteStr)\n\n{\n    int32_t iVar1;\n    int64_t arg1;\n    ulong uVar2;\n    code *pcVar3;\n    code *pcVar4;\n    char *arg1_00;\n    char *arg2;\n    ulong arg4;\n    uint uStack72;\n    uint uStack68;\n    int64_t iStack64;\n    uchar auStack56 [16];\n    uchar auStack40 [16];\n    ulong uStack24;\n    \n    arg4 = 0xffffffff;\n    uVar2 = lpMultiByteStr;\n    iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0xfde9, 0, lpMultiByteStr, 0xffffffff, 0, 0);\n    if (iVar1 == 0) {\n        arg2 = \"Failed to get wchar_t buffer size.\\n\";\n        lpMultiByteStr = uVar2;\ncode_r0x000140006179:\n        arg1_00 = 0x140027bb0;\n        uVar2 = lpMultiByteStr;\n    }\n    else {\n        arg1 = fcn.14000c97c(iVar1 + 1, 2);\n        if (arg1 != 0) {\n            arg4 = 0xffffffff;\n            iVar1 = (*_sym.imp.KERNEL32.dll_MultiByteToWideChar)(0xfde9, 0, lpMultiByteStr, 0xffffffff, arg1, iVar1);\n            if (iVar1 != 0) goto code_r0x000140006187;\n            arg2 = \"Failed to decode wchar_t from UTF-8\\n\";\n            goto code_r0x000140006179;\n        }\n        arg2 = \"Out of memory.\\n\";\n        arg1_00 = \"win32_utils_from_utf8\";\n    }\n    fcn.140001cd0(arg1_00, arg2, uVar2, arg4);\n    arg1 = 0;\ncode_r0x000140006187:\n    uVar2 = (*_sym.imp.KERNEL32.dll_LoadLibraryA)(0x140027a60);\n    pcVar3 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2, \"CreateActCtxW\");\n    pcVar4 = (*_sym.imp.KERNEL32.dll_GetProcAddress)(uVar2, \"ActivateActCtx\");\n    if ((pcVar3 != NULL) && (pcVar4 != NULL)) {\n        uStack24 = 0;\n        uStack72 = 0x38;\n        auStack56 = ZEXT816(0);\n        uStack68 = 0x10;\n        auStack40 = ZEXT816(0);\n        iStack64 = arg1;\n        *0x140037000 = (*pcVar3)(&uStack72);\n        fcn.14000c984(arg1);\n        if (*0x140037000 != -1) {\n            iVar1 = (*pcVar4)(*0x140037000, 0x140044f80);\n            if (iVar1 != 0) {\n                return 1;\n            }\n        }\n        *0x140037000 = 0xffffffffffffffff;\n        fcn.140006270(0);\n    }\n    return 0;\n}\n",
        "token_count": 709
    },
    "14000c99": {
        "rules": [
            "contain loop"
        ],
        "decompiled_code": "\nint64_t fcn.14000c998(uint64_t arg1)\n\n{\n    int32_t iVar1;\n    int64_t iVar2;\n    uint *puVar3;\n    uint64_t arg1_00;\n    \n    if (arg1 < 0xffffffffffffffe1) {\n        arg1_00 = arg1;\n        if (arg1 == 0) {\n            arg1_00 = 1;\n        }\n        do {\n            arg1 = *0x140047250;\n            iVar2 = (*_sym.imp.KERNEL32.dll_HeapAlloc)(*0x140047250, 0, arg1_00);\n            if (iVar2 != 0) {\n                return iVar2;\n            }\n            iVar1 = fcn.14001439c();\n        } while ((iVar1 != 0) && (arg1 = arg1_00,  iVar1 = fcn.14001da14(arg1_00),  iVar1 != 0));\n    }\n    puVar3 = fcn.140015850(arg1);\n    *puVar3 = 0xc;\n    return 0;\n}\n",
        "token_count": 241
    },
    "14001423": {
        "rules": [
            "parse PE header"
        ],
        "decompiled_code": "\nvoid fcn.140014230(ulong arg1)\n\n{\n    code *pcVar1;\n    int16_t *piVar2;\n    int32_t *piVar3;\n    uint auStackX16 [2];\n    int32_t aiStackX24 [2];\n    uchar auStackX32 [8];\n    uchar auStack56 [4];\n    uint uStack52;\n    uint auStack48 [2];\n    uint *puStack40;\n    int32_t *piStack32;\n    uchar *puStack24;\n    \n    aiStackX24[0] = 0;\n    auStackX16[0] = 2;\n    piVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    if ((((piVar2 != NULL) && (*piVar2 == 0x5a4d)) && (piVar3 = *(piVar2 + 0x1e) + piVar2,  *piVar3 == 0x4550)) &&\n       (((*(piVar3 + 6) == 0x20b && (0xe < piVar3[0x21])) && (piVar3[0x3e] != 0)))) {\n        fcn.1400141ac(arg1);\n    }\n    puStack40 = auStackX16;\n    auStackX32[0] = 0;\n    piStack32 = aiStackX24;\n    puStack24 = auStackX32;\n    uStack52 = 2;\n    auStack48[0] = 2;\n    fcn.140013f9c(auStack56, auStack48, &puStack40, &uStack52);\n    if (aiStackX24[0] == 0) {\n        fcn.140014160(arg1);\n        pcVar1 = swi(3);\n        (*pcVar1)();\n        return;\n    }\n    return;\n}\n",
        "token_count": 413
    },
    "14001427": {
        "rules": [
            "parse PE header"
        ],
        "decompiled_code": "\nvoid fcn.140014278(ulong arg1)\n\n{\n    code *pcVar1;\n    int16_t *piVar2;\n    int32_t *piVar3;\n    uint auStackX16 [2];\n    int32_t aiStackX24 [2];\n    uchar auStackX32 [8];\n    uchar auStack56 [4];\n    uint uStack52;\n    uint auStack48 [2];\n    uint *puStack40;\n    int32_t *piStack32;\n    uchar *puStack24;\n    \n    aiStackX24[0] = 0;\n    auStackX16[0] = 0;\n    piVar2 = (*_sym.imp.KERNEL32.dll_GetModuleHandleW)(0);\n    if ((((piVar2 != NULL) && (*piVar2 == 0x5a4d)) && (piVar3 = *(piVar2 + 0x1e) + piVar2,  *piVar3 == 0x4550)) &&\n       (((*(piVar3 + 6) == 0x20b && (0xe < piVar3[0x21])) && (piVar3[0x3e] != 0)))) {\n        fcn.1400141ac(arg1);\n    }\n    puStack40 = auStackX16;\n    auStackX32[0] = 0;\n    piStack32 = aiStackX24;\n    puStack24 = auStackX32;\n    uStack52 = 2;\n    auStack48[0] = 2;\n    fcn.140013f9c(auStack56, auStack48, &puStack40, &uStack52);\n    if (aiStackX24[0] == 0) {\n        fcn.140014160(arg1);\n        pcVar1 = swi(3);\n        (*pcVar1)();\n        return;\n    }\n    return;\n}\n",
        "token_count": 413
    }
}