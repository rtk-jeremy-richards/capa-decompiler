{
    "00401006": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuchar fcn.00401006(void)\n\n{\n    uint16_t uVar1;\n    uint16_t uVar2;\n    uint cBitsPixel;\n    uint lpPolyCounts;\n    uint lpCPInfoEx;\n    uint hWndNewViewer;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    code *var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    var_10h = *0x43a00c;\n    var_1ch._0_1_ = 0xa2;\n    for (var_14h = *0x43a014; var_14h != 0; var_14h = var_14h + -1) {\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(0, 0, 0);\n        if (uVar2 != 0) {\n            (*_sym.imp.USER32.dll_CallMsgFilterA)(0, 0xb4);\n            (*_sym.imp.MSVCRT.dll__fileinfo)(0xb4, 0xb5, 0xffffff40);\n            uVar1 = uVar2 >> 1;\n            (*_sym.imp.USER32.dll_CreateIcon)(uVar2 + 0x30, uVar2 + uVar1, -0xb4 - uVar2, 0xec910000, 0, uVar2, uVar2);\n            (*_sym.imp.GDI32.dll_PolyPolygon)(0xb4 - (uVar2 | 0x5b00), 0xffff413f, uVar1 * 0x2de8ce5b + uVar1, uVar2);\n            (*_sym.imp.USER32.dll_SetClipboardViewer)(uVar2 | 0x38a9);\n        }\n        *0x429057 = *var_10h ^ var_1ch;\n        *var_10h = *0x429057;\n        var_1ch._0_1_ = var_1ch ^ *0x429057;\n        var_10h = var_10h + 1;\n    }\n    (**0x43a00c)();\n    return 0xcb;\n}\n",
        "token_count": 499
    },
    "004013c9": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint16_t __cdecl fcn.004013c9(uint arg_8h, uint32_t arg_ch)\n\n{\n    uint8_t uVar1;\n    uint16_t uVar2;\n    uint32_t noname_1;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = arg_ch;\n    noname_1 = uVar1 + (arg_8h - uVar1) | arg_ch & 0xffff;\n    uVar2 = (uVar1 + 1) % 0x43;\n    if (uVar2 == 1) {\n        fcn.00402259(noname_1 + 0xc6, noname_1, noname_1);\n    }\n    return uVar2 >> 1;\n}\n",
        "token_count": 183
    },
    "0040192c": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0040192c(uint noname_0, uint noname_1, uint32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint var_4h;\n    \n    uVar2 = ((arg_10h & 0xffff) >> 2) - 1 & 0xffff;\n    uVar1 = uVar2 >> 3;\n    if (uVar1 == 0x1fff) {\n        fcn.004045d4(0x1fff, uVar2 + 0x5f000000 & 0xffff);\n    }\n    return uVar1;\n}\n",
        "token_count": 150
    },
    "00401a4a": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint fcn.00401a4a(void)\n\n{\n    uint var_4h;\n    \n    fcn.00403c17(0x78, 0x78, 0x78);\n    return 0xffff4778;\n}\n",
        "token_count": 53
    },
    "00401cf6": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuchar __cdecl fcn.00401cf6(int32_t arg_8h, uint arg_ch)\n\n{\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.004032c7(arg_8h * arg_8h & 0xff, arg_8h, 0);\n    return 0;\n}\n",
        "token_count": 87
    },
    "00402346": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402346(uint32_t arg_8h, uint arg_ch)\n\n{\n    uint var_8h;\n    uint var_4h;\n    \n    if (arg_8h / arg_8h == 1) {\n        fcn.00401a4a();\n    }\n    return 0;\n}\n",
        "token_count": 73
    },
    "00402638": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00402638(uint arg_8h)\n\n{\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.00401327();\n    return 0;\n}\n",
        "token_count": 46
    },
    "004028e4": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nushort __cdecl fcn.004028e4(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint8_t uVar1;\n    uint16_t uVar2;\n    uint8_t uVar3;\n    int32_t iVar4;\n    uint16_t uVar5;\n    uint32_t uVar6;\n    uint32_t uVar7;\n    uint var_6ch;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint lpLCData;\n    uint LCType;\n    uint Locale;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint32_t var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint wMsgFilterMin;\n    uint hWnd;\n    uint wMsgFilterMax;\n    int16_t *var_18h;\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint32_t var_8h;\n    uint var_4h;\n    \n    iVar4 = *((arg_8h & 0xff) % 0xb4 + 0xaf00366 ^ 0xab1b2a2);\n    *0x429039 = iVar4 - ((arg_8h & 0xff) + -0xbc);\n    *0x429047 = 0x775142cb;\n    for (var_18h = iVar4 - *0x429039; uVar3 = arg_ch,  *var_18h != 0x5a4d;\n        var_18h = var_18h - ((uVar3 - (arg_8h & 0xff)) + 0x100bc)) {\n        uVar5 = uVar3 * -0x3000;\n        uVar3 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)\n                          ((arg_ch & 0xff) * uVar5 + -0x14000, (arg_ch & 0xff | uVar5) - 0xa002, uVar3 & arg_8h);\n        if (uVar3 != 0) {\n            (*_sym.imp.USER32.dll_GetMessageW)(uVar3 * 0x75 + uVar5, uVar5, arg_8h & 0x58, uVar3 + 4);\n        }\n    }\n    *0x42903b = var_18h + *(var_18h + *(var_18h + 0x1e) + 0x78);\n    *0x42903f = var_18h + *(*0x42903b + 0x20);\n    for (var_8h = *(*0x42903b + 0x18); var_8h != 0; var_8h = var_8h - ((-uVar3 & arg_8h) - 0xbb)) {\n        var_38h = 0;\n        for (*0x429043 = **0x42903f + var_18h; **0x429043 != '\\0'; *0x429043 = *0x429043 + uVar5 * uVar1 + -0x276ef) {\n            uVar1 = arg_8h * '\\x02';\n            uVar5 = arg_ch + uVar1 * 0x4cd8;\n            var_38h = (var_38h << 7 | var_38h >> 0x19) + ((*0x429043)[(uVar5 - uVar1) + -0x4ca] ^ 0x54);\n        }\n        if (var_38h == *0x429047) {\n            uVar6 = arg_ch & 0xff;\n            uVar7 = uVar6 * 0x10000;\n            uVar2 = (uVar3 >> 1) * 2;\n            iVar4 = (*_sym.imp.KERNEL32.dll_GetLocaleInfoW)\n                              (arg_ch & 0xff ^ arg_ch & 0xffff, (arg_ch & 0xffff) + uVar6 * -0x10000 + 0x1fffe, \n                               (uVar2 | arg_ch & 0xff) - 2, 0);\n            *0x42903b = *0x42903b + iVar4;\n            uVar5 = uVar3 & 0x911c;\n            var_8h = *(var_18h +\n                      ((*(*0x42903b + ((arg_ch & 0xffff) + uVar6 * -0x10000 + 0x20004) * 4) - var_8h) +\n                      (arg_8h & 0xff) * uVar2 + -0x178) * 2 +\n                      (uVar5 - (arg_ch & 0xff)) + -0x20000 + *(*0x42903b + 0x24) + (arg_ch & 0xff) + uVar7);\n            *0x42903f = var_18h + (uVar7 - 0x20000) + *(*0x42903b + ((uVar7 | arg_8h & 0xff) - 0x200b5) * 4);\n            *0x42904b = (*(var_18h + (*0x42903f)[var_8h - (uVar5 & arg_8h & 0xff)]))\n                                  (0, uVar2 + 0x1f81e, (uVar5 & arg_8h & 0xff) + 0x1000, 0x40);\n            *0x43a00c = *0x42904b + (uVar7 - 0x20000);\n        }\n        *0x42903f = *0x42903f + 1;\n    }\n    return 0;\n}\n",
        "token_count": 1324
    },
    "004032c7": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint8_t __cdecl fcn.004032c7(uint arg_8h, uint arg_ch, int32_t arg_10h)\n\n{\n    uint8_t uVar1;\n    uint32_t arg_10h_00;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint dwFlags;\n    uint var_4h;\n    \n    uVar3 = (arg_10h + 0xa8daU & 0xff) << 8;\n    arg_10h_00 = (arg_10h - arg_8h) + 0xc >> 2;\n    uVar1 = arg_10h & arg_ch;\n    if (arg_10h + 0xa8daU == 0xa8da) {\n        uVar3 = fcn.00405156(uVar3, 0xa8da, arg_10h_00);\n        uVar3 = uVar3 & 0xffff;\n    }\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)\n                      ((uVar3 ^ uVar1 * arg_10h - arg_10h_00) + 0x1c, arg_10h_00 * 0x5a + -0x924, (uVar3 ^ uVar1) - 2);\n    if (uVar2 != 0) {\n        (*_sym.imp.MSVCRT.dll__wfindfirsti64)();\n        (*_sym.imp.MSVCRT.dll_ctime)(uVar2 & 0x5a, (uVar3 ^ uVar1) - uVar3, arg_10h_00, uVar3 + 0x5a);\n    }\n    return arg_ch;\n}\n",
        "token_count": 380
    },
    "00403495": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint fcn.00403495(void)\n\n{\n    uint var_4h;\n    \n    fcn.004013c9(0, 0);\n    return 0;\n}\n",
        "token_count": 39
    },
    "004035a3": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004035a3(uint noname_0, uint noname_1, uint32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint var_4h;\n    \n    arg_14h = arg_14h & 0xff;\n    if (arg_14h == 1) {\n        arg_14h = fcn.004026b1(arg_10h | 0x12200000, arg_14h >> 2 | arg_10h | 0x12200000);\n    }\n    return (arg_14h & 0xff) % arg_14h;\n}\n",
        "token_count": 143
    },
    "null": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint main(void)\n\n{\n    uint32_t uVar1;\n    uint var_8h;\n    uint lpTemplateName;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(0, 0, 0);\n    if (uVar1 != 0) {\n        (*_sym.imp.GDI32.dll_SetAbortProc)(0x74, (uVar1 | 0x3000) * 0x2501);\n        (*_sym.imp.USER32.dll_GetTitleBarInfo)(uVar1, uVar1 & 0x1e000074);\n        (*_sym.imp.MSVCRT.dll_acos)(uVar1 & 1, 1, 0x74);\n        uVar1 = uVar1 | 0x2575;\n        (*_sym.imp.USER32.dll_LoadCursorA)(0xb78ef790, 0xd6d50e4);\n        (*_sym.imp.USER32.dll_DialogBoxParamW)((uVar1 ^ 0x74) & 0x53, 0x248e, uVar1, uVar1, 0x74);\n    }\n    fcn.004016bd(0x2501, uVar1 - 1, 0);\n    return 0xfd35;\n}\n",
        "token_count": 280
    },
    "0040376f": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0040376f(uint32_t arg_8h, uint noname_1, uint32_t arg_10h)\n\n{\n    uint16_t uVar1;\n    uint CodePage;\n    \n    arg_8h = arg_8h & 0xff;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)\n                      ((arg_8h >> 1 & arg_10h & 0xffff) - 0x30, 0, \n                       ((arg_8h >> 1) - (arg_10h - (arg_10h & 0xb5) & 0xffff)) + 0xc09);\n    if (uVar1 == 0) {\n        arg_8h = fcn.00402638(arg_8h);\n        arg_8h = arg_8h & 0xff;\n    }\n    else {\n        (*_sym.imp.MSVCRT.dll_ldexp)(uVar1 ^ 0x3f37, arg_8h, arg_8h, arg_8h);\n    }\n    return arg_8h;\n}\n",
        "token_count": 249
    },
    "0040396c": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0040396c(uint32_t arg_8h, uint noname_1, uint32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    uint8_t uVar2;\n    uint8_t uVar3;\n    uint nBottomRect;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    int32_t var_18h;\n    uint dwFlags;\n    code *var_10h;\n    uint var_ch;\n    uint nRightRect;\n    code *var_4h;\n    \n    var_4h = resource.0;\n    uVar2 = arg_10h;\n    uVar3 = (uVar2 ^ 0x27) & uVar2;\n    var_10h = *(((uVar3 - arg_10h) + 0xd9d95d55 ^ 0x70028421) + (arg_10h + 0x9667c65c) * 4);\n    for (var_18h = uVar3 * arg_10h + 0x33e34735; var_18h != arg_10h * 2 + 0x2ccf8cb8; var_18h = var_18h - (uVar3 - 0x96)\n        ) {\n        uVar3 = arg_8h + uVar2;\n        *var_10h = *var_4h;\n        var_10h = var_10h + ((arg_8h & 0xffff & uVar3) - 0x92);\n        var_4h = var_4h + (arg_8h & 0xffff) + (arg_10h & 0xffff) + -0x5896;\n    }\n    uVar1 = arg_10h % arg_10h;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)\n                      (arg_10h + 0x9667c65c, (uVar1 & 0xff) + arg_10h + -0x699839a4, \n                       (arg_10h * 0x1000000 - (uVar1 & 0xff)) + 0x5c000000);\n    if (uVar2 != 0) {\n        (*_sym.imp.USER32.dll_FrameRect)((arg_10h ^ 0x9f) + arg_10h, uVar1 & 0x78, 0);\n        (*_sym.imp.GDI32.dll_IntersectClipRect)\n                  (uVar2, 0, 0x6a4f0000, uVar2 + 0xcbc442d4, (uVar1 & 0xff ^ arg_10h * 0x1000000) + 0xd910a25c);\n        (*_sym.imp.MSVCRT.dll__putw)();\n    }\n    *0x43a010 = var_10h;\n    return arg_10h;\n}\n",
        "token_count": 676
    },
    "00403b5e": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuchar __cdecl fcn.00403b5e(uint arg_8h, uint arg_ch)\n\n{\n    char cVar1;\n    uint var_10h;\n    uint var_ch;\n    uint ch;\n    uint lpCPInfoEx;\n    \n    fcn.00401006();\n    cVar1 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(0, (arg_ch + 0x97) - 0xef, 0);\n    if (cVar1 != '\\0') {\n        (*_sym.imp.USER32.dll_IsCharLowerA)(arg_8h);\n    }\n    return arg_8h;\n}\n",
        "token_count": 138
    },
    "00403ca0": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00403ca0(uint32_t arg_8h)\n\n{\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if (arg_8h >> 1 == 0) {\n        fcn.00402f65(arg_8h, arg_8h & 0xffff, arg_8h, arg_8h & 0xd330);\n    }\n    return arg_8h;\n}\n",
        "token_count": 104
    },
    "00403f45": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nint32_t fcn.00403f45(void)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint var_4h;\n    \n    uVar2 = 0;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(0, 0, 0);\n    if (uVar1 == 0) {\n        fcn.00403d36();\n    }\n    else {\n        (*_sym.imp.MSVCRT.dll__outp)(0x99, 0xff04db00, 0);\n        (*_sym.imp.MSVCRT.dll__ismbbalnum)(0, 0);\n        uVar2 = uVar1 & 0xffff;\n        (*_sym.imp.USER32.dll_DlgDirSelectComboBoxExA)(0, 0, uVar1, 0);\n        (*_sym.imp.GDI32.dll_Escape)(0xffff0827, 0x11f9, 0, 0, uVar2);\n    }\n    return uVar2 - 0x347f;\n}\n",
        "token_count": 236
    },
    "004041ac": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.004041ac(uint32_t arg_8h, uint32_t arg_ch, int32_t arg_10h, int32_t arg_14h)\n\n{\n    uint16_t uVar1;\n    uint8_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint var_14h;\n    uint var_10h;\n    uint CodePage;\n    uint lpPolyCounts;\n    uint fnPolyFillMode;\n    \n    arg_8h = arg_8h & 0xffff;\n    uVar1 = arg_14h * arg_14h;\n    uVar4 = arg_10h + (arg_ch & 0x2b);\n    uVar2 = arg_14h | 0x4a;\n    uVar5 = (arg_8h ^ 0x5a1100) & 0xffff;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)((uVar4 ^ uVar2) - 0x4b, 0, 0);\n    uVar3 = uVar3 & 0xffff;\n    if (uVar3 != 0) {\n        (*_sym.imp.GDI32.dll_TranslateCharsetInfo)(arg_8h ^ uVar3 | uVar4, uVar5 ^ uVar2, uVar4 + 0x677e00);\n        (*_sym.imp.GDI32.dll_CreatePolyPolygonRgn)\n                  (uVar5, (uVar1 & 0x6ee2) * uVar1, uVar5 * (uVar1 & 0xe0), uVar2 & uVar5 | 0x8a7800);\n        (*_sym.imp.GDI32.dll_ExcludeClipRect)\n                  ((uVar5 & uVar1) + uVar2, uVar5 - 0xc9c2, uVar5, uVar3 + 0x9370, uVar2 & uVar3);\n        (*_sym.imp.MSVCRT.dll__snscanf)();\n        (*_sym.imp.MSVCRT.dll__splitpath)(uVar2, uVar1, uVar3 + (uVar3 ^ 0x186f), uVar4 - 0x8400);\n    }\n    if (arg_8h == 0) {\n        fcn.004047ee(uVar2);\n    }\n    return arg_14h + 0x354700;\n}\n",
        "token_count": 548
    },
    "00404334": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint fcn.00404334(void)\n\n{\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.004048d9(0x10);\n    return 0xd0a7d6dc;\n}\n",
        "token_count": 52
    },
    "004045d4": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004045d4(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uchar *puVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    int32_t var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar2 = (arg_8h | arg_ch) & 0xff;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(uVar2 - 0xff, uVar2 - 0xff, uVar2 - 0xff);\n    uVar2 = uVar2 & 0xff;\n    if (uVar2 != '\\0') {\n        (*_sym.imp.GDI32.dll_GetCharABCWidthsW)(uVar2 - 0x30, uVar2 | 0xd6b700, uVar2, uVar2 ^ 0xe6a20000);\n        (*_sym.imp.MSVCRT.dll__mbctombb)(uVar2 * 0x549101, uVar2);\n        (*_sym.imp.GDI32.dll_GetPixel)(uVar2 | 0xfe000000, uVar2 * 0xfbd8, uVar2);\n        (*_sym.imp.MSVCRT.dll__snscanf)(uVar2, uVar2, uVar2);\n        (*_sym.imp.GDI32.dll_SetGraphicsMode)(uVar2 ^ 0x61, uVar2);\n    }\n    uVar3 = arg_ch & 0xffff;\n    puVar1 = (uVar3 - uVar2) + 0x5de820f1 ^ 0x5dabb0f0;\n    var_10h = *((uVar3 + 0x70402432 ^ 0x70028421) + ((uVar3 | uVar2) - 0xffff) * 4);\n    for (var_14h = (uVar2 - uVar3) + 0x10000; var_14h != uVar3 - 0xffff; var_14h = var_14h - ((arg_8h & 0xff) - 0xfe)) {\n        *(var_10h + ((arg_8h & 0xff) - 0xff)) = *puVar1;\n        var_10h = var_10h + 1;\n        puVar1 = puVar1 + (((arg_8h | 0x5d87) ^ arg_8h & 0xff) - 0x5cff);\n    }\n    *(uVar2 + uVar3 * (uVar3 | 0x640c) + 0x70412430 ^ 0x70028421) = var_10h;\n    return arg_ch - uVar3 & 0xffff;\n}\n",
        "token_count": 674
    },
    "004047ee": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004047ee(uint32_t lpCPInfoEx)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint var_4h;\n    \n    uVar1 = lpCPInfoEx * 0x1000000 - 1;\n    uVar2 = (lpCPInfoEx >> 1) - 1;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)\n                      ((uVar2 | uVar1) + 0xb6000001, uVar2 + uVar1 + -0x4a000023, (uVar1 & lpCPInfoEx) - 0x4a);\n    if (uVar3 != 0) {\n        (*_sym.imp.MSVCRT.dll_floor)();\n        (*_sym.imp.MSVCRT.dll_mblen)(uVar2 - (uVar2 & 0x790339f5), uVar1 * uVar2 * uVar2);\n        uVar3 = uVar3 + 1;\n        (*_sym.imp.MSVCRT.dll__mbsinc)(uVar2, uVar2, uVar2, uVar3);\n    }\n    if (uVar3 == 0) {\n        fcn.0040287d(0, uVar3 & 0x119c2c3d);\n    }\n    return uVar3 & 0x119c2c3d;\n}\n",
        "token_count": 327
    },
    "0040499c": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nulong __cdecl fcn.0040499c(uint32_t arg_8h, uint32_t arg_ch, int32_t arg_10h)\n\n{\n    uint16_t uVar1;\n    uint16_t uVar2;\n    uint8_t uVar3;\n    uint16_t uVar4;\n    uint32_t uVar5;\n    int32_t iVar6;\n    uint var_8ch;\n    uint var_88h;\n    uint var_84h;\n    uint var_80h;\n    uint var_7ch;\n    uint var_78h;\n    uint var_74h;\n    uint x;\n    uint32_t lpCPInfoEx;\n    uint var_68h;\n    uint var_64h;\n    uint var_60h;\n    uint var_5ch;\n    uint var_58h;\n    uint var_54h;\n    uint var_50h;\n    uint var_4ch;\n    uint var_48h;\n    uint var_44h;\n    uint var_40h;\n    uint var_3ch;\n    uint var_38h;\n    uint var_34h;\n    uint var_30h;\n    uint var_2ch;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint var_14h;\n    uint8_t *var_10h;\n    int32_t *var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = arg_ch;\n    uVar4 = uVar1 * -0x4085;\n    var_ch = *((arg_ch + 0xdad3f7d ^ 0xdee9f70) + (uVar4 - 0x4085) * 4);\n    var_10h = var_ch + (uVar4 - 0x4085);\n    *0x42904f = (uVar4 | 0x1c8cea04) + 0xe3750d9b;\n    while (*0x42904f != uVar4 * 0x1c8cea04 + -0xfb69414) {\n        uVar3 = arg_10h;\n        if (*0x42904f < (uVar3 + uVar3 * (arg_8h | uVar3) ^ uVar3) + 8) {\n            uVar5 = arg_10h * (arg_ch ^ arg_8h);\n            var_10h[uVar5 * arg_ch] = *var_ch;\n            var_10h = var_10h + (arg_ch & uVar5) + 1;\n            var_ch = var_ch + arg_ch * uVar5 + 1;\n            *0x42904f = *0x42904f - ((arg_ch & 0xffff) + arg_10h + -0xfffe);\n        }\n        else {\n            iVar6 = *var_ch * 0x1000000 + *var_ch * 0x10000 + *(var_ch + ((arg_10h ^ 0x3fbd) - 0x3fbd)) * 0x100 +\n                    *var_ch;\n            *0x429053 = 0;\n            if ((*var_ch == iVar6) && (var_ch[1 - arg_10h] == iVar6)) {\n                *0x429053 = ((arg_8h >> 1) - (arg_8h & 0xffff)) + 1;\n            }\n            if (*0x429053 == 0) {\n                uVar5 = (arg_ch + 0x336898fc) - arg_10h;\n                *var_10h = *(var_ch + ((uVar5 * 0x100 & 0xffff) - uVar5) + 0x33679dfb);\n                uVar2 = uVar5 - (uVar5 | 0xab);\n                var_10h = var_10h + (uVar5 ^ uVar2) + 0xcc976706;\n                var_ch = var_ch + (uVar2 - uVar5) + 0x336898fc;\n                *0x42904f = *0x42904f - ((uVar5 * 0x100 & 0xffff) * 0x100 + uVar5 + -0x346398fa);\n            }\n            else {\n                lpCPInfoEx = 0xbc4a0000;\n                uVar2 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(0, 0, 0);\n                if (uVar2 != 0) {\n                    (*_sym.imp.MSVCRT.dll_getenv)(0xbc4a0000, uVar2);\n                    (*_sym.imp.USER32.dll_EndMenu)();\n                    (*_sym.imp.MSVCRT.dll_log)(uVar2 - 0x4ae, uVar2 ^ 0xbc4a0000);\n                    lpCPInfoEx = uVar2 % 0xbc4a0000;\n                }\n                uVar2 = (uVar1 | uVar2 ^ arg_8h) & uVar1;\n                *0x42904f = *0x42904f - (((lpCPInfoEx >> 3) - uVar2) + -0x17883ff9);\n                var_ch = var_ch + (uVar2 - 1) * (lpCPInfoEx >> 3) + -0x10ed7ff8;\n            }\n        }\n    }\n    *0x42904f = var_10h - *0x43a00c;\n    *((arg_ch & 0x9d40) + 0xc1c4f501 ^ 0xc1863255) = *0x42904f;\n    return CONCAT44(arg_ch, 0x1c8cea04);\n}\n",
        "token_count": 1280
    },
    "00404f69": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00404f69(int32_t arg_8h, uint arg_ch)\n\n{\n    uint var_14h;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if (arg_8h == 0x1c) {\n        fcn.00401dbb(0);\n    }\n    return arg_8h;\n}\n",
        "token_count": 96
    },
    "00404ff0": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00404ff0(uint noname_0, uint arg_ch, uint arg_10h)\n\n{\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.004033af();\n    return 0xdcffffff;\n}\n",
        "token_count": 59
    },
    "00405317": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint32_t fcn.00405317(void)\n\n{\n    uint32_t uVar1;\n    uint32_t arg_8h;\n    int32_t unaff_EDI;\n    uint32_t uVar2;\n    \n    uVar2 = 0;\n    fcn.00405286(0, 0, 0, 0);\n    arg_8h = unaff_EDI * 0x97e4 & 0xff;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(arg_8h, 0, arg_8h);\n    if (uVar1 == 0) {\n        fcn.00401ad0(arg_8h);\n    }\n    else {\n        (*_sym.imp.MSVCRT.dll__except_handler3)(arg_8h, arg_8h, arg_8h);\n        (*_sym.imp.GDI32.dll_GdiGetDC)((arg_8h | uVar1) + 0xeea94dd1);\n    }\n    return (uVar2 & 0xffff) + 1 & 0xffff;\n}\n",
        "token_count": 242
    },
    "00405406": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00405406(uint arg_8h)\n\n{\n    uint8_t uVar1;\n    char cVar2;\n    uint var_4h;\n    \n    cVar2 = arg_8h * arg_8h;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(cVar2, 0, cVar2);\n    if (uVar1 != 0) {\n        (*_sym.imp.USER32.dll_wvsprintfW)(0x5bb200, uVar1, cVar2);\n        (*_sym.imp.GDI32.dll_GdiComment)(uVar1 & 0xf0 & uVar1, uVar1, uVar1);\n        (*_sym.imp.MSVCRT.dll_modf)();\n        (*_sym.imp.MSVCRT.dll__mbsbtype)(cVar2, 0x6100, uVar1);\n        (*_sym.imp.MSVCRT.dll_wcscoll)(uVar1, 0x67752200);\n    }\n    if (cVar2 + 1 == 1) {\n        fcn.0040446a(0, 1, arg_8h);\n    }\n    return cVar2 + 1 | 0xe9000000;\n}\n",
        "token_count": 280
    },
    "00405521": {
        "rules": [
            "decompress data using aPLib/068152e73b06436aa790bef7a99b301a",
            "hash data with CRC32/a4d5eed7afd042fc93e3f1fa27687e43"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nulong __cdecl fcn.00405521(uint noname_0, uint arg_ch, uint arg_10h)\n\n{\n    uint var_10h;\n    uint cchClassNameMax;\n    uint var_8h;\n    uint var_4h;\n    \n    var_4h._0_1_ = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(0, 0, 0);\n    if (var_4h != 0) {\n        (*_sym.imp.MSVCRT.dll__fmode)();\n        var_4h._0_1_ = arg_ch;\n        (*_sym.imp.USER32.dll_RealGetWindowClassA)(0, 0, 0xb7000000);\n    }\n    fcn.00402ef6(0, var_4h);\n    return 0;\n}\n",
        "token_count": 189
    },
    "004012c6": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nuint8_t __cdecl fcn.004012c6(uint32_t arg_8h)\n\n{\n    uint8_t uVar1;\n    int32_t iVar2;\n    uint var_4h;\n    \n    iVar2 = (arg_8h & 0xff) - arg_8h;\n    uVar1 = arg_8h ^ iVar2;\n    if (iVar2 == 0) {\n        fcn.00405317(uVar1, uVar1);\n    }\n    return uVar1;\n}\n",
        "token_count": 112
    },
    "004019ba": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nulong fcn.004019ba(void)\n\n{\n    uint var_4h;\n    \n    fcn.004035a3(0xd, 1, 0xd, 1);\n    return 0x680000786a;\n}\n",
        "token_count": 52
    },
    "0040201d": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nuint __cdecl fcn.0040201d(uint noname_0, uint32_t arg_ch, uint arg_10h)\n\n{\n    uint64_t uVar1;\n    uint arg_8h;\n    uint var_4h;\n    \n    uVar1 = ((arg_ch & 0xff) - arg_ch & 0xffff) % 0x49;\n    arg_8h = uVar1;\n    if (uVar1 == 0) {\n        fcn.004021dd(arg_8h, arg_8h, arg_ch & 0xff);\n    }\n    return arg_8h;\n}\n",
        "token_count": 135
    },
    "004021dd": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004021dd(uint32_t arg_8h, uint arg_ch, uint arg_10h)\n\n{\n    uint var_4h;\n    \n    if (arg_ch == '\\0') {\n        fcn.00405055(arg_8h, 0xd4);\n    }\n    return arg_8h & 0xff;\n}\n",
        "token_count": 80
    },
    "00403e0d": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nuint fcn.00403e0d(void)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint lpOutputFunc;\n    \n    uVar1 = fcn.00405406(0);\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(0, 0, 0);\n    uVar2 = uVar2 & 0xff;\n    if (uVar2 != '\\0') {\n        (*_sym.imp.GDI32.dll_GetCharWidthI)(0x6266, uVar1 | 0x2e000000, 0x4365, 0, 0);\n        (*_sym.imp.GDI32.dll_Escape)(uVar2, uVar1 | 0xb9ce, 0, (uVar2 | 0x550f) * uVar1, uVar2 * uVar2);\n        (*_sym.imp.USER32.dll_DdeQueryStringA)(uVar2 | 0xee00, 0, uVar2, 0, uVar1 ^ 0x4be9);\n        (*_sym.imp.USER32.dll_GrayStringA)(0, 0, uVar2 ^ 0xdd | uVar1, 0, 0, 0, uVar1, 0, 0);\n    }\n    return 0;\n}\n",
        "token_count": 297
    },
    "00404051": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nuint64_t __cdecl fcn.00404051(uint32_t lpCPInfoEx, int32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint var_4h;\n    \n    uVar2 = lpCPInfoEx + (lpCPInfoEx ^ 0x1351) & 0xffff;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(uVar2 * lpCPInfoEx, lpCPInfoEx * uVar2, lpCPInfoEx + uVar2 + -0x1351);\n    if (uVar1 != 0) {\n        (*_sym.imp.MSVCRT.dll__beep)(uVar2, uVar1 * 0x2f5c - uVar2, uVar1, uVar1 & uVar2 & uVar2);\n        (*_sym.imp.MSVCRT.dll_wcspbrk)(uVar1, -uVar1, uVar2 ^ 0x5b7100, 0);\n        uVar1 = uVar1 - 1;\n    }\n    uVar2 = uVar1 + (uVar1 ^ uVar2) & 0xffff;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)\n                      (uVar2 * (uVar2 | 0xb7c2) + -0xdded2c3, (uVar2 | uVar2 | 0xb7c2) - 0xb7d3, 0);\n    uVar1 = uVar1 & 0xffff;\n    if (uVar1 != 0) {\n        (*_sym.imp.USER32.dll_EnumPropsA)(uVar1 & uVar2, uVar1 & uVar2 & 0x7898de52);\n        (*_sym.imp.USER32.dll_IsCharUpperA)(uVar2);\n    }\n    if (uVar2 == 0x1351) {\n        fcn.004043cc(0x1351);\n    }\n    return uVar1 / uVar2 | (lpCPInfoEx & 0x2478) * arg_ch << 0x20;\n}\n",
        "token_count": 481
    },
    "0040446a": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0040446a(uint noname_0, int32_t arg_ch, uint arg_10h)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint fnPolyFillMode;\n    \n    fcn.00405602(0x601a5200);\n    arg_10h._0_1_ = arg_10h - (arg_10h ^ 0xf8);\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(0, arg_ch + 0x9fe5ae00U & 0x52, (arg_10h ^ 0x601a5200) + 0x9fe5adf8);\n    uVar2 = uVar2 & 0xff;\n    if (uVar2 != '\\0') {\n        (*_sym.imp.GDI32.dll_GetWindowOrgEx)(arg_10h, (arg_10h & 0xff601a52) - 0x9fe5ae);\n    }\n    uVar3 = uVar2 + 0x8c;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(uVar2, (uVar3 & arg_10h) - 8, (arg_10h - uVar3) + 0x84);\n    if (uVar1 != 0) {\n        (*_sym.imp.MSVCRT.dll__findnext64)();\n        (*_sym.imp.USER32.dll_GetTitleBarInfo)(uVar1, uVar1 * uVar3);\n        (*_sym.imp.MSVCRT.dll__c_exit)(uVar3 * uVar3 - uVar3, uVar1 * uVar3 + -0x9a56, 0x5072dc98, uVar3);\n        (*_sym.imp.GDI32.dll_CreatePolygonRgn)(uVar1, uVar3 * uVar1, uVar1 + uVar3);\n        (*_sym.imp.MSVCRT.dll__ismbstrail)(uVar3 ^ 0x42, uVar3, uVar1 ^ uVar3);\n    }\n    return uVar2 + 1 & 0xff;\n}\n",
        "token_count": 495
    },
    "0040575d": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nuchar fcn.0040575d(void)\n\n{\n    uchar uVar1;\n    uint var_4h;\n    \n    uVar1 = fcn.004028e4(0xf7bc, 2);\n    return uVar1;\n}\n",
        "token_count": 54
    },
    "004057dc": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004057dc(uint32_t arg_8h, uint noname_1, uint32_t CodePage)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint32_t arg_14h;\n    uint dwFlags;\n    \n    uVar2 = (arg_8h | 0xe508) - 0x2d;\n    arg_14h = uVar2 & 0xff;\n    uVar3 = arg_14h ^ CodePage;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)\n                      (uVar3 - 0xda, uVar3 - 0xda, ((arg_14h >> 3) - 1 & 0xff | arg_14h) - 0xdb);\n    if (uVar1 != 0) {\n        (*_sym.imp.GDI32.dll_CreateSolidBrush)(uVar1 + (uVar2 & 0x39));\n    }\n    if (arg_8h * '\\x1b' - CodePage == -1) {\n        fcn.00401ee7(0xff, 0xff, arg_14h / uVar3, arg_14h);\n    }\n    return arg_8h;\n}\n",
        "token_count": 287
    },
    "004058c1": {
        "rules": [
            "decompress data using LZO/0e44f942d5744579a3d2494f64545baa"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004058c1(uint noname_0, int32_t arg_ch, uint32_t arg_10h)\n\n{\n    uint32_t noname_0_00;\n    uint32_t uVar1;\n    uint var_4h;\n    \n    uVar1 = arg_ch - 2;\n    noname_0_00 = (arg_10h & 0xff) >> 3;\n    if (uVar1 == 0x70) {\n        uVar1 = fcn.0040201d(noname_0_00, noname_0_00, 0x70);\n    }\n    return noname_0_00 * (uVar1 & 0xde0241d9) & 0xff;\n}\n",
        "token_count": 168
    },
    "00401327": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nuint fcn.00401327(void)\n\n{\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.00402480(0, 0xb00, 0);\n    return 0x2c0;\n}\n",
        "token_count": 59
    },
    "004014a7": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004014a7(uint32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    int32_t iVar4;\n    uint var_28h;\n    uint var_24h;\n    uint var_20h;\n    uint var_1ch;\n    uint var_18h;\n    uint32_t var_14h;\n    int32_t var_10h;\n    uint var_ch;\n    uint var_8h;\n    uchar *var_4h;\n    \n    uVar1 = arg_8h & 0xff | 0x5700;\n    uVar2 = uVar1 & 0x59ed;\n    var_4h = uVar2 * uVar1 + 0x41f2565d ^ 0x5da9b1bf;\n    uVar3 = uVar2 >> 2;\n    var_10h = *((uVar3 * uVar2 + 0x72b8214 ^ 0xdee9f70) + ((uVar3 & uVar1) - 0x1420) * 4);\n    uVar1 = (arg_8h & 0xff) - arg_8h & 0xff;\n    for (var_14h = uVar3 + uVar2 + 0xaf3b; var_14h != (uVar2 & uVar1); var_14h = var_14h - (arg_8h - 0x49b2)) {\n        *(var_10h + ((arg_8h | arg_8h & 0xff) - 0x49b3)) = *var_4h;\n        iVar4 = arg_8h + (arg_8h & 0xff) * -0x11f95c66;\n        var_10h = var_10h + (arg_8h & 0xff) + iVar4 + -0x6ea4af13;\n        var_4h = var_4h + iVar4 + (arg_8h & 0xff) + -0x6ea4af13;\n    }\n    *0x43a010 = var_10h;\n    return uVar1;\n}\n",
        "token_count": 500
    },
    "004016bd": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004016bd(uint arg_8h, int32_t arg_ch, int32_t arg_10h)\n\n{\n    int16_t iVar1;\n    uint16_t uVar2;\n    uint16_t uVar3;\n    uint32_t uVar4;\n    uint lpCPInfoEx;\n    uint nXStart;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(0, 0, 0);\n    if (iVar1 != 0) {\n        (*_sym.imp.MSVCRT.dll__ismbcsymbol)(0x89b76fff);\n        (*_sym.imp.MSVCRT.dll_ldexp)();\n        (*_sym.imp.USER32.dll_SetRect)(0x9465d17a, 0, iVar1, 0, 0x6b44);\n        (*_sym.imp.GDI32.dll_GetClipBox)(0x677b, iVar1);\n    }\n    uVar2 = fcn.00403f45();\n    uVar4 = arg_10h + arg_ch & 0xffff;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(0xffff - uVar4, 0xcb81 - uVar2, uVar2 - 0xcb81);\n    if (uVar3 != 0) {\n        (*_sym.imp.MSVCRT.dll_towlower)(uVar4, uVar2 * uVar2 * 0x24f90000, 0xdd667c, 0xf897);\n        (*_sym.imp.GDI32.dll_ResetDCA)(0xcbf7f897, 0xf897);\n        (*_sym.imp.GDI32.dll_TextOutW)(uVar3, (uVar3 ^ uVar2) * 0xb423, 0, 0, uVar2 + 0xf896);\n    }\n    return uVar4;\n}\n",
        "token_count": 419
    },
    "00402480": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nuint64_t __cdecl fcn.00402480(uint arg_8h, uint noname_1, uint arg_10h)\n\n{\n    uint8_t uVar1;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = fcn.00404334();\n    return CONCAT14(uVar1 >> 2, uVar1);\n}\n",
        "token_count": 87
    },
    "004025d8": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nuint fcn.004025d8(void)\n\n{\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.0040575d();\n    return 0x4200;\n}\n",
        "token_count": 45
    },
    "0040287d": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.0040287d(int32_t arg_8h, int32_t arg_ch)\n\n{\n    uint var_8h;\n    uint var_4h;\n    \n    if (arg_ch == 0) {\n        fcn.0040499c(0, arg_8h + -1, 0);\n    }\n    return (arg_8h * 0x100 + -1) * 0x10000;\n}\n",
        "token_count": 101
    },
    "00402ef6": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00402ef6(uint32_t arg_8h, uint arg_ch)\n\n{\n    uint var_8h;\n    uint var_4h;\n    \n    if ((arg_8h & 0xffff) == 0) {\n        fcn.004020b7();\n    }\n    return (arg_8h & 0xffff) % 7 - 0x8e00;\n}\n",
        "token_count": 93
    },
    "004030b4": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nulong __cdecl fcn.004030b4(uint arg_8h)\n\n{\n    uint8_t uVar1;\n    uint8_t uVar2;\n    uint32_t uVar3;\n    uint var_10h;\n    uint errnum;\n    uint CodePage;\n    uint lpszInData;\n    \n    uVar1 = (arg_8h & 0xf6) - 0x3d >> 3;\n    uVar2 = (arg_8h & 0xd8) + arg_8h;\n    uVar3 = arg_8h + 1;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)\n                      ((uVar1 ^ uVar3) - 199, (uVar3 | uVar2) - 0xf5, (arg_8h ^ uVar1) - 0xc6);\n    if (uVar1 != 0) {\n        (*_sym.imp.MSVCRT.dll__strerror)(uVar2);\n        (*_sym.imp.MSVCRT.dll__cprintf)(uVar1, (uVar2 - 7) + arg_8h, uVar2);\n        (*_sym.imp.GDI32.dll_CreateRectRgnIndirect)(uVar2);\n        (*_sym.imp.MSVCRT.dll_iswupper)(uVar1 | 0xc3, uVar2 * 0xee);\n        (*_sym.imp.GDI32.dll_DrawEscape)(uVar2 | 0x1a1300, uVar1 ^ 0x60000000, uVar3 ^ 0xe7fa | uVar3, 0);\n    }\n    fcn.00403ca0(uVar1);\n    return CONCAT44(uVar1 << 0x10, -uVar2);\n}\n",
        "token_count": 393
    },
    "00403417": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nuchar fcn.00403417(void)\n\n{\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.0040188a(0x1e0000, 0x1e0000);\n    return 0x44;\n}\n",
        "token_count": 63
    },
    "00405055": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nuint8_t __cdecl fcn.00405055(uint32_t arg_8h, uint arg_ch)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar2 = arg_ch;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)\n                      (0, ((arg_8h & 0xffff) - uVar2) + 0xd4, (uVar2 ^ arg_8h & 0xffff) - 0xd4);\n    uVar1 = uVar1 & 0xffff;\n    if (uVar1 != 0) {\n        (*_sym.imp.MSVCRT.dll_rand)(uVar2);\n        (*_sym.imp.USER32.dll_MessageBeep)(uVar2 ^ uVar1);\n    }\n    if (arg_ch == 0xd4) {\n        uVar1 = fcn.004030b4(0xd4);\n        uVar1 = uVar1 & 0xffff;\n    }\n    if (uVar1 - (arg_8h & 0x28) == '\\\\') {\n        arg_ch._0_1_ = fcn.00402346(0x5c, arg_ch);\n    }\n    return arg_ch;\n}\n",
        "token_count": 293
    },
    "00405156": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nulong __cdecl fcn.00405156(uint arg_8h, int32_t arg_ch, uint32_t arg_10h)\n\n{\n    uint64_t uVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = (arg_10h / arg_10h) / (arg_10h / arg_10h);\n    uVar2 = uVar1;\n    uVar3 = 0xff % uVar1;\n    uVar3 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(uVar3 & uVar2, (uVar2 - uVar3) + -1, 0);\n    if (uVar3 != 0) {\n        (*_sym.imp.USER32.dll_IMPGetIMEA)(uVar3 + 6, uVar3 & 0xff);\n        (*_sym.imp.USER32.dll_GetMenuStringW)(0xff - uVar2, uVar2 + 0x3e15, 0x9d4a18, uVar2, 0xff);\n        (*_sym.imp.MSVCRT.dll__lrotl)(uVar3, uVar3);\n        (*_sym.imp.USER32.dll_EqualRect)(uVar2 * uVar2, uVar3 * 0xf900 - uVar2);\n        (*_sym.imp.MSVCRT.dll__getcwd)();\n    }\n    var_ch._0_1_ = uVar1;\n    if (arg_ch == 0xa8da) {\n        var_ch._0_1_ = fcn.004038ea(uVar3, var_ch, uVar2 & 0xff);\n    }\n    return CONCAT44(var_ch * 0x10000 + arg_10h, arg_10h & 0x3143);\n}\n",
        "token_count": 432
    },
    "00405602": {
        "rules": [
            "compute adler32 checksum/59ba9d7991e641c88d7c729645f1cfca"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00405602(uint32_t arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar2 = (arg_8h & 0xff) + 1 & 0xff;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(uVar2 - 1, uVar2 - 1, 0);\n    uVar1 = uVar1 & 0xff;\n    if (uVar1 != '\\0') {\n        (*_sym.imp.GDI32.dll_GetGlyphOutlineA)(0, uVar1, uVar1 - 0x1400, 0, 0, uVar1 & uVar2 & 0xc4e3, uVar1 ^ 0x6c5b);\n        (*_sym.imp.USER32.dll_SetWindowContextHelpId)(uVar1 ^ 0x832a, 0x6300);\n        (*_sym.imp.GDI32.dll_DeleteEnhMetaFile)(uVar1 * 0x8b);\n        (*_sym.imp.GDI32.dll_ResizePalette)(uVar1, 0);\n        uVar2 = uVar1;\n    }\n    fcn.00404051(0, 0);\n    if (uVar1 == '\\0') {\n        fcn.00405521(0, 0, uVar2 - arg_8h & 0xff);\n    }\n    return 0;\n}\n",
        "token_count": 339
    },
    "00401ad0": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00401ad0(uint arg_8h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(0, 0, 0);\n    uVar2 = uVar1 & 0xff;\n    if (uVar2 != '\\0') {\n        (*_sym.imp.MSVCRT.dll__wexecvpe)(uVar1 & 0x28, uVar2 + 0x4557bc44, 0xed9e00);\n        (*_sym.imp.MSVCRT.dll_sinh)(uVar2 ^ 1, 0);\n        (*_sym.imp.MSVCRT.dll__cwprintf)(uVar2, uVar2, uVar2, uVar2);\n    }\n    if (arg_8h == '\\0') {\n        fcn.004041ac(0, 0, 1, 0);\n    }\n    fcn.00404ff0(0, 0, 0);\n    return 0;\n}\n",
        "token_count": 260
    },
    "00401dbb": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\nulong fcn.00401dbb(uint32_t param_1)\n\n{\n    uint32_t uVar1;\n    int32_t arg_8h;\n    uint32_t uVar2;\n    \n    uVar2 = param_1 & 0xffff;\n    uVar1 = uVar2 >> 3;\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(uVar2 - uVar1, param_1 & uVar2 | uVar1, uVar1 | uVar2);\n    uVar2 = uVar2 & 0xffff;\n    if (uVar2 != 0) {\n        (*_sym.imp.MSVCRT.dll__wgetdcwd)(uVar2 + uVar1);\n    }\n    uVar2 = uVar2 + 1 & 0xffff;\n    arg_8h = (uVar1 & 0xff) << 8;\n    if (uVar2 == 1) {\n        uVar2 = fcn.004057dc(arg_8h, arg_8h, 1);\n        uVar2 = uVar2 & 0xffff;\n    }\n    return CONCAT44(uVar2 * 0x7200, uVar1);\n}\n",
        "token_count": 268
    },
    "00402259": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00402259(uint noname_0, uint noname_1, uint arg_10h)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(0, 0, 0);\n    uVar2 = uVar1 & 0xff;\n    if (uVar2 != '\\0') {\n        (*_sym.imp.GDI32.dll_SetPixelFormat)(uVar2, uVar1 & 0x36, uVar2 * 0x479c0000);\n        (*_sym.imp.GDI32.dll_GetTextMetricsW)(uVar2 * -0x4bdc0000, 0xb4240000);\n        (*_sym.imp.MSVCRT.dll_strlen)(0, 0xb4240000, uVar2, 0xd2900000);\n        (*_sym.imp.GDI32.dll_GetRandomRgn)(0, uVar2, 0);\n    }\n    fcn.004019ba();\n    return uVar2;\n}\n",
        "token_count": 256
    },
    "004023e5": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\nint64_t __cdecl fcn.004023e5(int32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t uVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = arg_8h + 0x4c032521 + arg_ch;\n    if (uVar1 == 0x4c032605) {\n        fcn.004058c1(0, arg_ch & 0xff, 0x4c032605);\n    }\n    return uVar1 << 0x20;\n}\n",
        "token_count": 128
    },
    "004026b1": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\nulong __cdecl fcn.004026b1(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint16_t uVar1;\n    uint16_t uVar2;\n    uint32_t uVar3;\n    uint32_t uVar4;\n    uint32_t uVar5;\n    uint CodePage;\n    uint var_20h;\n    int32_t var_1ch;\n    uint var_18h;\n    uchar *var_14h;\n    uint var_10h;\n    uint32_t var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar5 = arg_8h & 0xffff;\n    uVar4 = arg_ch & 0xff;\n    uVar1 = uVar4 + arg_8h * 2;\n    var_ch = uVar1 * arg_8h + 0x9b091ef5 ^ 0x5da89100;\n    uVar3 = uVar5 + arg_8h * 0xc536;\n    var_14h = *(((uVar5 & uVar4) + 0x70412424 ^ 0x70028421) + ((uVar3 | uVar5) + 0x8d35fc31) * 4);\n    for (var_1ch = (uVar4 | uVar5) + 0xc999; var_1ch != uVar1 + uVar5 + -0x34; var_1ch = var_1ch - (uVar4 * uVar2 + 1))\n    {\n        *var_14h = *(var_ch + (((arg_ch ^ arg_8h & 0xffff ^ 0xfae500 | 0xe187) - arg_8h) - (arg_8h & 0xffff)) +\n                              -0xbae56d);\n        uVar4 = arg_8h & 0xffff;\n        var_14h = var_14h + (uVar4 - 0xc);\n        var_ch = var_ch + (arg_8h & 0xffff) + uVar4 + -0x19;\n        uVar2 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)\n                          ((uVar4 - (uVar4 << 8 & 0xffff)) + 0xcf3, 0, uVar4 << 8 & 0xffff & uVar4);\n        if (uVar2 != 0) {\n            (*_sym.imp.MSVCRT.dll__itoa)(0, uVar4 ^ 0xac000000, uVar4, uVar4 ^ uVar2);\n        }\n    }\n    *(uVar3 + uVar1 + 0xfd77203f ^ 0x70028421) = var_14h;\n    return CONCAT44(uVar3 >> 2, uVar3);\n}\n",
        "token_count": 625
    },
    "00403834": {
        "rules": [
            "decompress data using aPLib/06666ba0b6a14a5481e4ee6eb664d454"
        ],
        "decompiled_code": "\nuint __cdecl fcn.00403834(uint noname_0, uint arg_ch)\n\n{\n    int32_t iVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar1 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(0, 0, 0);\n    if (iVar1 != 0) {\n        (*_sym.imp.MSVCRT.dll_vswprintf)();\n    }\n    fcn.00401611(0, 0);\n    return 0x2c000000;\n}\n",
        "token_count": 119
    },
    "0040188a": {
        "rules": [
            "hash data using aphash/10489b186fc44711a1078750698db7a9",
            "encrypt data using HC-128/1d01b23c04404fe18b84a06c7e7d83b0"
        ],
        "decompiled_code": "\nuchar __cdecl fcn.0040188a(uint arg_8h, uint arg_ch)\n\n{\n    uint var_8h;\n    uint var_4h;\n    \n    if (arg_8h == '\\0') {\n        fcn.0040252c(0);\n    }\n    return 0;\n}\n",
        "token_count": 68
    },
    "00401c38": {
        "rules": [
            "hash data using aphash/10489b186fc44711a1078750698db7a9",
            "encrypt data using HC-128/1d01b23c04404fe18b84a06c7e7d83b0"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nuint8_t __cdecl fcn.00401c38(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint32_t arg_8h_00;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    arg_8h_00 = arg_8h & 0xff;\n    var_ch._0_1_ = arg_8h | (arg_ch - arg_8h_00 & 0xffff) * (arg_ch & arg_8h) - 1 >> 3;\n    if (var_ch == 0xfb) {\n        var_ch._0_1_ = fcn.004023e5(arg_8h_00, arg_8h_00);\n    }\n    return var_ch;\n}\n",
        "token_count": 188
    },
    "0040252c": {
        "rules": [
            "hash data using aphash/10489b186fc44711a1078750698db7a9",
            "encrypt data using HC-128/1d01b23c04404fe18b84a06c7e7d83b0"
        ],
        "decompiled_code": "\nuint32_t fcn.0040252c(int32_t param_1)\n\n{\n    int32_t iVar1;\n    uint32_t uVar2;\n    uint32_t uVar3;\n    \n    uVar2 = 0x1c;\n    uVar3 = param_1 + 0x67a4e2U & 0xffff;\n    if (uVar3 == 0xa4e2) {\n        uVar2 = fcn.00404f69(0x1c, 0xe2);\n        uVar2 = uVar2 & 0xff;\n    }\n    iVar1 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)\n                      ((uVar2 ^ 0x5eae0000) * uVar2 + -0x5b080310, ((uVar2 ^ 0x5eae0000) - uVar2) + -0x5eae0000, \n                       (uVar2 | uVar3) - 0xa4fe);\n    if (iVar1 != 0) {\n        (*_sym.imp.GDI32.dll_CreateDIBPatternBrushPt)(iVar1 + (uVar2 | 0xe756), uVar3);\n    }\n    return uVar2 + 0x291e0000 & 0xff;\n}\n",
        "token_count": 287
    },
    "004034f7": {
        "rules": [
            "hash data using aphash/10489b186fc44711a1078750698db7a9",
            "encrypt data using HC-128/1d01b23c04404fe18b84a06c7e7d83b0"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004034f7(uint32_t arg_8h, uint32_t arg_ch, uint32_t arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t uVar1;\n    uint32_t arg_8h_00;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = (arg_14h & 0xff) >> 2;\n    arg_8h_00 = ((arg_ch | arg_10h) ^ uVar1) & 0xffff;\n    uVar1 = (arg_8h_00 | uVar1) * 0x22 & 0xff;\n    if (uVar1 == 0x56) {\n        fcn.0040396c(arg_8h_00, arg_8h & 0xff, arg_ch * uVar1 * 0xa057);\n    }\n    return arg_8h_00;\n}\n",
        "token_count": 217
    },
    "004038ea": {
        "rules": [
            "hash data using aphash/10489b186fc44711a1078750698db7a9",
            "encrypt data using HC-128/1d01b23c04404fe18b84a06c7e7d83b0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.004038ea(uint arg_8h, uint noname_1, uint arg_10h)\n\n{\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if ((arg_10h & 0x9d) == 1) {\n        fcn.004014a7(0x49b3);\n    }\n    return 0x10000008a;\n}\n",
        "token_count": 103
    },
    "00403c17": {
        "rules": [
            "hash data using aphash/10489b186fc44711a1078750698db7a9",
            "encrypt data using HC-128/1d01b23c04404fe18b84a06c7e7d83b0"
        ],
        "decompiled_code": "\nulong __cdecl fcn.00403c17(uint arg_8h, uint arg_ch, uint32_t arg_10h)\n\n{\n    uint32_t uVar1;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = (arg_10h & 0xffff) + 0xf2 & 0xffff;\n    if (uVar1 >> 2 == 0x5a) {\n        fcn.00401e51(arg_10h & 0xff);\n    }\n    return CONCAT44(uVar1 >> 7, arg_ch + (uVar1 >> 4));\n}\n",
        "token_count": 137
    },
    "004043cc": {
        "rules": [
            "hash data using aphash/10489b186fc44711a1078750698db7a9",
            "encrypt data using HC-128/1d01b23c04404fe18b84a06c7e7d83b0"
        ],
        "decompiled_code": "\nuint __cdecl fcn.004043cc(uint arg_8h)\n\n{\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if ((arg_8h | 0x3ad4) == 0x3bd5) {\n        fcn.00401cf6(-arg_8h, 0x3bd5);\n    }\n    return 0;\n}\n",
        "token_count": 97
    },
    "00401611": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint fcn.00401611(void)\n\n{\n    uint32_t uVar1;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(0, 0, 0);\n    uVar1 = uVar1 & 0xff;\n    if (uVar1 != '\\0') {\n        (*_sym.imp.GDI32.dll_RectVisible)(0xdb000000, 0);\n        (*_sym.imp.MSVCRT.dll__wspawnvpe)(0, uVar1, 0, 0xdb000000);\n    }\n    fcn.0040192c(uVar1, uVar1, 0xdb000000);\n    return 0;\n}\n",
        "token_count": 178
    },
    "00401ee7": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nushort __cdecl fcn.00401ee7(uint noname_0, uint arg_ch, uint arg_10h, uint arg_14h)\n\n{\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    if (arg_10h - ((arg_10h & 0xff) + 0xb516 & 0xff) == -0x16) {\n        fcn.0040321a(0xffea);\n    }\n    return arg_ch;\n}\n",
        "token_count": 110
    },
    "004020b7": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nulong fcn.004020b7(void)\n\n{\n    uint8_t uVar1;\n    uint32_t uVar2;\n    uint var_14h;\n    uint var_10h;\n    uint nSize;\n    uint var_8h;\n    uint dwVer;\n    \n    uVar1 = fcn.00401f4b(0x17, 0x17);\n    uVar2 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(0, 0, 0);\n    uVar2 = uVar2 & 0xff;\n    if (uVar2 != '\\0') {\n        (*_sym.imp.MSVCRT.dll__heapused)(0, 0xb2, uVar1, (uVar2 ^ 0x24) & 0x17);\n        (*_sym.imp.GDI32.dll_GetMetaFileBitsEx)(0, 0, 7);\n        (*_sym.imp.USER32.dll_CreateIconFromResource)(uVar2, 0, 0x4f00, uVar1 - uVar1);\n    }\n    return CONCAT44(uVar2 + 1, 0x17);\n}\n",
        "token_count": 252
    },
    "00402f65": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.00402f65(uint arg_8h, uint arg_ch, uint arg_10h, uint32_t arg_14h)\n\n{\n    uint32_t noname_0;\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    noname_0 = (arg_14h & 0xff) >> 2;\n    if (noname_0 == 0) {\n        fcn.00403834(noname_0, noname_0 * 2);\n    }\n    return arg_14h & 0xff;\n}\n",
        "token_count": 140
    },
    "00402ff6": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint16_t __cdecl fcn.00402ff6(uint arg_8h)\n\n{\n    uint16_t uVar1;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar1 = arg_8h * 0xb1;\n    if (uVar1 == 0xc72) {\n        fcn.0040376f(0xc72, (arg_8h | uVar1) ^ uVar1 << 0x18, 0xc72);\n    }\n    return arg_8h | uVar1;\n}\n",
        "token_count": 128
    },
    "0040321a": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.0040321a(uint32_t arg_8h)\n\n{\n    uint var_10h;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    arg_8h = arg_8h & 0xff;\n    if (arg_8h == 0xea) {\n        arg_8h = fcn.004034f7(arg_8h * -0xe276, arg_8h + 0x7900 >> 2, 0xea, arg_8h * -0xe276);\n        arg_8h = arg_8h & 0xff;\n    }\n    return arg_8h;\n}\n",
        "token_count": 153
    },
    "00403d36": {
        "rules": [
            "decompress data using LZO/119ff19994674493853a9d8636ba63bf",
            "hash data using jshash/b1c33655e5b8435da69c7094541b75b8"
        ],
        "decompiled_code": "\nint16_t fcn.00403d36(void)\n\n{\n    int16_t iVar1;\n    uint var_ch;\n    uint var_8h;\n    uint var_4h;\n    \n    iVar1 = fcn.004025d8(0, 0, 0);\n    fcn.00403e0d();\n    return iVar1 + -0x1100;\n}\n",
        "token_count": 83
    },
    "00401e51": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nint32_t __cdecl fcn.00401e51(int32_t arg_8h)\n\n{\n    uint var_ch;\n    uint var_8h;\n    int32_t var_4h;\n    \n    var_4h = (arg_8h + 0x58bea8ce) * 0x1000000;\n    if ((arg_8h * arg_8h & 0xffU) == 0x40) {\n        var_4h = fcn.004012c6(0x40);\n    }\n    return var_4h;\n}\n",
        "token_count": 126
    },
    "00401f4b": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\n// WARNING: Could not reconcile some variable overlaps\n\nint16_t __cdecl fcn.00401f4b(uint32_t arg_8h, uint32_t arg_ch)\n\n{\n    uint16_t uVar1;\n    uint32_t uVar2;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar2 = arg_ch & (arg_8h & 0x3f53) - 1 & 0xffff;\n    arg_ch = arg_ch * 0x9e;\n    if (uVar2 == 0x12) {\n        arg_ch = fcn.00402ff6(0x12);\n    }\n    uVar1 = uVar2 - (arg_ch & 0xff);\n    var_8h._0_2_ = arg_8h;\n    if (((arg_8h ^ uVar1) & 0xffff) == 0xffb7) {\n        var_8h._0_2_ = fcn.00401c38(arg_ch & 0xff, uVar1 + 1);\n    }\n    return var_8h + 1;\n}\n",
        "token_count": 246
    },
    "004033af": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382"
        ],
        "decompiled_code": "\nushort fcn.004033af(void)\n\n{\n    uint var_8h;\n    uint var_4h;\n    \n    fcn.00403b5e(0x1d00, 0xe658);\n    return 0x1d00;\n}\n",
        "token_count": 57
    },
    "004048d9": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "encrypt data using RC4 KSA/41e5dbd1fcbf406ebac8c999dfc1b5ff"
        ],
        "decompiled_code": "\nuint32_t __cdecl fcn.004048d9(uint32_t lpCPInfoEx)\n\n{\n    uint32_t uVar1;\n    uint32_t uVar2;\n    uint var_8h;\n    uint var_4h;\n    \n    uVar2 = lpCPInfoEx & 0xffff;\n    uVar1 = (*_sym.imp.KERNEL32.dll_GetCPInfoExA)(lpCPInfoEx + uVar2 + -0x20, uVar2 - lpCPInfoEx, lpCPInfoEx - 0x10);\n    uVar1 = uVar1 & 0xff;\n    if (uVar1 != '\\0') {\n        (*_sym.imp.USER32.dll_ModifyMenuA)(uVar2, (lpCPInfoEx & uVar2) + 0x70, uVar1, uVar1, lpCPInfoEx);\n        (*_sym.imp.GDI32.dll_GetArcDirection)(lpCPInfoEx ^ 0xde0e00 ^ uVar1);\n        (*_sym.imp.MSVCRT.dll__getpid)(lpCPInfoEx);\n    }\n    if (lpCPInfoEx == 0x10) {\n        uVar1 = fcn.00403495();\n        uVar1 = uVar1 & 0xff;\n    }\n    return uVar1 - 1 & 0xff;\n}\n",
        "token_count": 294
    },
    "00405286": {
        "rules": [
            "validate payment card number using luhn algorithm with no lookup table/ca2c8d7b7d994625afebb42274522c55",
            "check for time delay via GetTickCount/79c6cbe28590449abc100fa77278b382",
            "enumerate PE sections/e92b906b5db4485ea433dde72854611a"
        ],
        "decompiled_code": "\nuint64_t fcn.00405286(uint param_1, uint32_t param_2, int32_t param_3)\n\n{\n    uint32_t uVar1;\n    \n    uVar1 = param_3 + param_2;\n    if (((param_2 - (param_2 & 0x7be6) & 0xff) - 1 & 0xff) == 0xff) {\n        uVar1 = fcn.00403417();\n    }\n    uVar1 = (uVar1 & 0xffff) - 1;\n    return CONCAT44(uVar1, (uVar1 & 0xffff) + 1) & 0x87400000ffff;\n}\n",
        "token_count": 153
    }
}